(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var JSBloom = {};
JSBloom.filter = function (items, target_prob) {
  if (typeof items !== "number" || typeof target_prob !== "number" || target_prob >= 1) {
    throw Error("Usage: new JSBloom.filter(items, target_probability)");
  }
  ;
  var BUFFER_LEN = function () {
      var buffer = Math.ceil(items * Math.log(target_prob) / Math.log(1.0 / Math.pow(2.0, Math.log(2.0))));
      if (buffer % 8 !== 0) {
        buffer += 8 - buffer % 8;
      }
      ;
      return buffer;
    }(),
    HASH_ROUNDS = Math.round(Math.log(2.0) * BUFFER_LEN / items),
    bVector = new Uint8Array(BUFFER_LEN / 8),
    hashes = {
      djb2: function djb2(str) {
        var hash = 5381;
        for (var len = str.length, count = 0; count < len; count++) {
          hash = hash * 33 ^ str.charCodeAt(count);
        }
        ;
        return (hash >>> 0) % BUFFER_LEN;
      },
      sdbm: function sdbm(str) {
        var hash = 0;
        for (var len = str.length, count = 0; count < len; count++) {
          hash = str.charCodeAt(count) + (hash << 6) + (hash << 16) - hash;
        }
        ;
        return (hash >>> 0) % BUFFER_LEN;
      }
    },
    addEntry = function addEntry(str) {
      var h1 = hashes.djb2(str);
      var h2 = hashes.sdbm(str);
      var added = false;
      for (var round = 0; round <= HASH_ROUNDS; round++) {
        var new_hash = round == 0 ? h1 : round == 1 ? h2 : (h1 + round * h2 + (round ^ 2)) % BUFFER_LEN;
        var extra_indices = new_hash % 8,
          index = (new_hash - extra_indices) / 8;
        if (extra_indices != 0 && (bVector[index] & 128 >> extra_indices - 1) == 0) {
          bVector[index] ^= 128 >> extra_indices - 1;
          added = true;
        } else if (extra_indices == 0 && (bVector[index] & 1) == 0) {
          bVector[index] ^= 1;
          added = true;
        }
      }
      ;
      return added;
    },
    addEntries = function addEntries(arr) {
      for (var i = arr.length - 1; i >= 0; i--) {
        addEntry(arr[i]);
      }
      ;
      return true;
    },
    checkEntry = function checkEntry(str) {
      var index, extra_indices;
      var h1 = hashes.djb2(str);
      extra_indices = h1 % 8;
      index = (h1 - extra_indices) / 8;
      if (extra_indices != 0 && (bVector[index] & 128 >> extra_indices - 1) == 0) {
        return false;
      } else if (extra_indices == 0 && (bVector[index] & 1) == 0) {
        return false;
      }
      var h2 = hashes.sdbm(str);
      extra_indices = h2 % 8;
      index = (h2 - extra_indices) / 8;
      if (extra_indices != 0 && (bVector[index] & 128 >> extra_indices - 1) == 0) {
        return false;
      } else if (extra_indices == 0 && (bVector[index] & 1) == 0) {
        return false;
      }
      for (var round = 2; round <= HASH_ROUNDS; round++) {
        var new_hash = round == 0 ? h1 : round == 1 ? h2 : (h1 + round * h2 + (round ^ 2)) % BUFFER_LEN;
        var extra_indices = new_hash % 8,
          index = (new_hash - extra_indices) / 8;
        if (extra_indices != 0 && (bVector[index] & 128 >> extra_indices - 1) == 0) {
          return false;
        } else if (extra_indices == 0 && (bVector[index] & 1) == 0) {
          return false;
        }
      }
      ;
      return true;
    },
    importData = function importData(data) {
      bVector = data;
    },
    exportData = function exportData() {
      return bVector;
    };
  return {
    info: {
      type: "regular",
      buffer: BUFFER_LEN,
      hashes: HASH_ROUNDS,
      raw_buffer: bVector
    },
    hashes: hashes,
    addEntry: addEntry,
    addEntries: addEntries,
    checkEntry: checkEntry,
    importData: importData,
    exportData: exportData
  };
};
if (typeof exports !== "undefined") {
  exports.filter = JSBloom.filter;
}
;

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":2,"buffer":4,"ieee754":7}],5:[function(require,module,exports){
(function (global,setImmediate){(function (){
/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 3.2.3, Mon Jan 23 2023
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */
 
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dexie = factory());
})(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var _global = typeof globalThis !== 'undefined' ? globalThis :
        typeof self !== 'undefined' ? self :
            typeof window !== 'undefined' ? window :
                global;

    var keys = Object.keys;
    var isArray = Array.isArray;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend(obj, extension) {
        if (typeof extension !== 'object')
            return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function')
            extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
            { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function (Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b)
            throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
        if (_global.setImmediate)
            setImmediate(fn);
        else
            setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
        return array.reduce(function (result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
                result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function tryCatch(fn, onerror, args) {
        try {
            fn.apply(null, args);
        }
        catch (ex) {
            onerror && onerror(ex);
        }
    }
    function getByKeyPath(obj, keyPath) {
        if (hasOwn(obj, keyPath))
            return obj[keyPath];
        if (!keyPath)
            return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined)
            return;
        if ('isFrozen' in Object && Object.isFrozen(obj))
            return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        }
        else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "")
                    if (value === undefined) {
                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                            obj.splice(currentKeyPath, 1);
                        else
                            delete obj[currentKeyPath];
                    }
                    else
                        obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj || !hasOwn(obj, currentKeyPath))
                        innerObj = (obj[currentKeyPath] = {});
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            }
            else {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(keyPath)))
                        obj.splice(keyPath, 1);
                    else
                        delete obj[keyPath];
                }
                else
                    obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string')
            setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath)
            [].map.call(keyPath, function (kp) {
                setByKeyPath(obj, kp, undefined);
            });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn(obj, m))
                rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return ["Int", "Uint", "Float"].map(function (t) { return t + num + "Array"; }); }))).filter(function (t) { return _global[t]; });
    var intrinsicTypes = intrinsicTypeNames.map(function (t) { return _global[t]; });
    arrayToObject(intrinsicTypeNames, function (x) { return [x, true]; });
    var circularRefs = null;
    function deepClone(any) {
        circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
    }
    function innerDeepClone(any) {
        if (!any || typeof any !== 'object')
            return any;
        var rv = circularRefs && circularRefs.get(any);
        if (rv)
            return rv;
        if (isArray(any)) {
            rv = [];
            circularRefs && circularRefs.set(any, rv);
            for (var i = 0, l = any.length; i < l; ++i) {
                rv.push(innerDeepClone(any[i]));
            }
        }
        else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
            rv = any;
        }
        else {
            var proto = getProto(any);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs && circularRefs.set(any, rv);
            for (var prop in any) {
                if (hasOwn(any, prop)) {
                    rv[prop] = innerDeepClone(any[prop]);
                }
            }
        }
        return rv;
    }
    var toString = {}.toString;
    function toStringTag(o) {
        return toString.call(o).slice(8, -1);
    }
    var iteratorSymbol = typeof Symbol !== 'undefined' ?
        Symbol.iterator :
        '@@iterator';
    var getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () { return null; };
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike))
                return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                return [arrayLike];
            if ((it = getIteratorOf(arrayLike))) {
                a = [];
                while ((x = it.next()), !x.done)
                    a.push(x.value);
                return a;
            }
            if (arrayLike == null)
                return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--)
                    a[i] = arrayLike[i];
                return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
            a[i] = arguments[i];
        return a;
    }
    var isAsyncFunction = typeof Symbol !== 'undefined'
        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }
        : function () { return false; };

    var debug = typeof location !== 'undefined' &&
        /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
        libraryFilter = filter;
    }
    var libraryFilter = function () { return true; };
    var NEEDS_THROW_FOR_STACK = !new Error("").stack;
    function getErrorWithStack() {
        if (NEEDS_THROW_FOR_STACK)
            try {
                getErrorWithStack.arguments;
                throw new Error();
            }
            catch (e) {
                return e;
            }
        return new Error();
    }
    function prettyStack(exception, numIgnoredFrames) {
        var stack = exception.stack;
        if (!stack)
            return "";
        numIgnoredFrames = (numIgnoredFrames || 0);
        if (stack.indexOf(exception.name) === 0)
            numIgnoredFrames += (exception.name + exception.message).split('\n').length;
        return stack.split('\n')
            .slice(numIgnoredFrames)
            .filter(libraryFilter)
            .map(function (frame) { return "\n" + frame; })
            .join('');
    }

    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
        this._e = getErrorWithStack();
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        stack: {
            get: function () {
                return this._stack ||
                    (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
            }
        },
        toString: function () { return this.name + ": " + this.message; }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures)
            .map(function (key) { return failures[key].toString(); })
            .filter(function (v, i, s) { return s.indexOf(v) === i; })
            .join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this._e = getErrorWithStack();
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this._e = getErrorWithStack();
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + "Error", obj); }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function (obj, name) {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this._e = getErrorWithStack();
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            }
            else if (typeof msgOrInner === 'string') {
                this.message = "" + msgOrInner + (!inner ? '' : '\n ' + inner);
                this.inner = inner || null;
            }
            else if (typeof msgOrInner === 'object') {
                this.message = msgOrInner.name + " " + msgOrInner.message;
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", { get: function () {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function (obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() { }
    function mirror(val) { return val; }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
            return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined)
                arguments[0] = res;
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ?
                (res2 === undefined ? undefined : res2) :
                (extend(res, res2));
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            if (f2.apply(this, arguments) === false)
                return false;
            return f1.apply(this, arguments);
        };
    }
    function promisableChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while (i--)
                    args[i] = arguments[i];
                return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    var INTERNAL = {};
    var LONG_STACKS_CLIP_LIMIT = 100,
    MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?
        [] :
        (function () {
            var globalP = Promise.resolve();
            if (typeof crypto === 'undefined' || !crypto.subtle)
                return [globalP, getProto(globalP), globalP];
            var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
            return [
                nativeP,
                getProto(nativeP),
                globalP
            ];
        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    var stack_being_generated = false;
    var schedulePhysicalTick = resolvedGlobalPromise ?
        function () { resolvedGlobalPromise.then(physicalTick); }
        :
            _global.setImmediate ?
                setImmediate.bind(null, physicalTick) :
                _global.MutationObserver ?
                    function () {
                        var hiddenDiv = document.createElement("div");
                        (new MutationObserver(function () {
                            physicalTick();
                            hiddenDiv = null;
                        })).observe(hiddenDiv, { attributes: true });
                        hiddenDiv.setAttribute('i', '1');
                    } :
                    function () { setTimeout(physicalTick, 0); };
    var asap = function (callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true,
    needsNewPhysicalTick = true,
    unhandledErrors = [],
    rejectingErrors = [],
    currentFulfiller = null, rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: globalError,
        pgp: false,
        env: {},
        finalize: function () {
            this.unhandleds.forEach(function (uh) {
                try {
                    globalError(uh[0], uh[1]);
                }
                catch (e) { }
            });
        }
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this.onuncatched = nop;
        this._lib = false;
        var psd = (this._PSD = PSD);
        if (debug) {
            this._stackHolder = getErrorWithStack();
            this._prev = null;
            this._numPrev = 0;
        }
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL)
                throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
                handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    var thenProp = {
        get: function () {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                var cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise(function (resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                debug && linkToPreviousPromise(rv, this);
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function (value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ?
                thenProp :
                {
                    get: function () {
                        return value;
                    },
                    set: thenProp.set
                });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function (onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function (onRejected) {
            if (arguments.length === 1)
                return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function (err) {
                return err instanceof type ? handler(err) : PromiseReject(err);
            })
                : this.then(null, function (err) {
                    return err && err.name === type ? handler(err) : PromiseReject(err);
                });
        },
        finally: function (onFinally) {
            return this.then(function (value) {
                onFinally();
                return value;
            }, function (err) {
                onFinally();
                return PromiseReject(err);
            });
        },
        stack: {
            get: function () {
                if (this._stack)
                    return this._stack;
                try {
                    stack_being_generated = true;
                    var stacks = getStack(this, [], MAX_LONG_STACKS);
                    var stack = stacks.join("\nFrom previous: ");
                    if (this._state !== null)
                        this._stack = stack;
                    return stack;
                }
                finally {
                    stack_being_generated = false;
                }
            }
        },
        timeout: function (ms, msg) {
            var _this = this;
            return ms < Infinity ?
                new DexiePromise(function (resolve, reject) {
                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);
                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function () {
            var values = getArrayOf.apply(null, arguments)
                .map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                if (values.length === 0)
                    resolve([]);
                var remaining = values.length;
                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {
                    values[i] = x;
                    if (!--remaining)
                        resolve(values);
                }, reject); });
            });
        },
        resolve: function (value) {
            if (value instanceof DexiePromise)
                return value;
            if (value && typeof value.then === 'function')
                return new DexiePromise(function (resolve, reject) {
                    value.then(resolve, reject);
                });
            var rv = new DexiePromise(INTERNAL, true, value);
            linkToPreviousPromise(rv, currentFulfiller);
            return rv;
        },
        reject: PromiseReject,
        race: function () {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });
            });
        },
        PSD: {
            get: function () { return PSD; },
            set: function (value) { return PSD = value; }
        },
        totalEchoes: { get: function () { return totalEchoes; } },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function () { return asap; },
            set: function (value) { asap = value; }
        },
        rejectionMapper: {
            get: function () { return rejectionMapper; },
            set: function (value) { rejectionMapper = value; }
        },
        follow: function (fn, zoneProps) {
            return new DexiePromise(function (resolve, reject) {
                return newScope(function (resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function () {
                        var _this = this;
                        run_at_end_of_this_or_next_physical_tick(function () {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve) {
                    if (possiblePromises.length === 0)
                        resolve([]);
                    var remaining = possiblePromises.length;
                    var results = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: "fulfilled", value: value }; }, function (reason) { return results[i] = { status: "rejected", reason: reason }; })
                        .then(function () { return --remaining || resolve(results); }); });
                });
            });
        if (NativePromise.any && typeof AggregateError !== 'undefined')
            setProp(DexiePromise, "any", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve, reject) {
                    if (possiblePromises.length === 0)
                        reject(new AggregateError([]));
                    var remaining = possiblePromises.length;
                    var failures = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {
                        failures[i] = failure;
                        if (!--remaining)
                            reject(new AggregateError(failures));
                    }); });
                });
            });
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(function (value) {
                if (promise._state !== null)
                    return;
                if (value === promise)
                    throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function (resolve, reject) {
                        value instanceof DexiePromise ?
                            value._then(resolve, reject) :
                            value.then(resolve, reject);
                    });
                }
                else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick)
                    endMicroTickScope();
            }, handleRejection.bind(null, promise));
        }
        catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
            return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {
            var origProp = getPropertyDescriptor(reason, "stack");
            reason._promise = promise;
            setProp(reason, "stack", {
                get: function () {
                    return stack_being_generated ?
                        origProp && (origProp.get ?
                            origProp.get.apply(reason) :
                            origProp.value) :
                        promise.stack;
                }
            });
        });
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
            endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function () {
                if (--numScheduledCalls === 0)
                    finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            currentFulfiller = promise;
            var ret, value = promise._value;
            if (promise._state) {
                ret = cb(value);
            }
            else {
                if (rejectingErrors.length)
                    rejectingErrors = [];
                ret = cb(value);
                if (rejectingErrors.indexOf(value) === -1)
                    markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        }
        catch (e) {
            listener.reject(e);
        }
        finally {
            currentFulfiller = null;
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function getStack(promise, stacks, limit) {
        if (stacks.length === limit)
            return stacks;
        var stack = "";
        if (promise._state === false) {
            var failure = promise._value, errorName, message;
            if (failure != null) {
                errorName = failure.name || "Error";
                message = failure.message || failure;
                stack = prettyStack(failure, 0);
            }
            else {
                errorName = failure;
                message = "";
            }
            stacks.push(errorName + (message ? ": " + message : "") + stack);
        }
        if (debug) {
            stack = prettyStack(promise._stackHolder, 2);
            if (stack && stacks.indexOf(stack) === -1)
                stacks.push(stack);
            if (promise._prev)
                getStack(promise._prev, stacks, limit);
        }
        return stacks;
    }
    function linkToPreviousPromise(promise, prev) {
        var numPrev = prev ? prev._numPrev + 1 : 0;
        if (numPrev < LONG_STACKS_CLIP_LIMIT) {
            promise._prev = prev;
            promise._numPrev = numPrev;
        }
    }
    function physicalTick() {
        beginMicroTickScope() && endMicroTickScope();
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function (p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
            finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(function () {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))
            unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
            if (unhandledErrors[--i]._value === promise._value) {
                unhandledErrors.splice(i, 1);
                return;
            }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            }
            catch (e) {
                errorCatcher && errorCatcher(e);
            }
            finally {
                switchToZone(outerScope, false);
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
    }
    var task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        var globalEnv = globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject,
            nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
            gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
        } : {};
        if (props)
            extend(psd, props);
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
            psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id)
            task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits)
            return false;
        if (--task.awaits === 0)
            task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function (x) {
                decrementExpectedAwaits();
                return x;
            }, function (e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
            return;
        PSD = targetZone;
        if (currentZone === globalPSD)
            globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise_1 = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            nativePromiseProto.then = targetEnv.nthen;
            GlobalPromise_1.prototype.then = targetEnv.gthen;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise_1.all = targetEnv.all;
                GlobalPromise_1.race = targetEnv.race;
                GlobalPromise_1.resolve = targetEnv.resolve;
                GlobalPromise_1.reject = targetEnv.reject;
                if (targetEnv.allSettled)
                    GlobalPromise_1.allSettled = targetEnv.allSettled;
                if (targetEnv.any)
                    GlobalPromise_1.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
            nthen: nativePromiseProto.then,
            gthen: GlobalPromise.prototype.then
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        }
        finally {
            switchToZone(outerScope, false);
        }
    }
    function enqueueNativeMicroTask(job) {
        nativePromiseThen.call(resolvedNativePromise, job);
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait)
                incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                switchToZone(outerZone, false);
                if (cleanup)
                    enqueueNativeMicroTask(decrementExpectedAwaits);
            }
        };
    }
    function getPatchedPromiseThen(origThen, zone) {
        return function (onResolved, onRejected) {
            return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
        };
    }
    var UNHANDLEDREJECTION = "unhandledrejection";
    function globalError(err, promise) {
        var rv;
        try {
            rv = promise.onuncatched(err);
        }
        catch (e) { }
        if (rv !== false)
            try {
                var event, eventData = { promise: promise, reason: err };
                if (_global.document && document.createEvent) {
                    event = document.createEvent('Event');
                    event.initEvent(UNHANDLEDREJECTION, true, true);
                    extend(event, eventData);
                }
                else if (_global.CustomEvent) {
                    event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
                    extend(event, eventData);
                }
                if (event && _global.dispatchEvent) {
                    dispatchEvent(event);
                    if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                        try {
                            _global.onunhandledrejection(event);
                        }
                        catch (_) { }
                }
                if (debug && event && !event.defaultPrevented) {
                    console.warn("Unhandled rejection: " + (err.stack || err));
                }
            }
            catch (e) { }
    }
    var rejection = DexiePromise.reject;

    function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
            if (db._state.openComplete) {
                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
            }
            if (!db._state.isBeingOpened) {
                if (!db._options.autoOpen)
                    return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });
        }
        else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            }
            catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db._close();
                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });
                }
                return rejection(ex);
            }
            return trans._promise(mode, function (resolve, reject) {
                return newScope(function () {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(function (result) {
                return trans._completion.then(function () { return result; });
            });
        }
    }

    var DEXIE_VERSION = '3.2.3';
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
    var hasIEDeleteObjectStoreBug = isIEOrEdge;
    var hangsOnDeleteLargeKeyRange = isIEOrEdge;
    var dexieStackFrameFilter = function (frame) { return !/(dexie\.js|dexie\.min\.js)/.test(frame); };
    var DBNAMES_DB = '__dbnames';
    var READONLY = 'readonly';
    var READWRITE = 'readwrite';

    function combine(filter1, filter2) {
        return filter1 ?
            filter2 ?
                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                filter1 :
            filter2;
    }

    var AnyRange = {
        type: 3 ,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
    };

    function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath)
            ? function (obj) {
                if (obj[keyPath] === undefined && (keyPath in obj)) {
                    obj = deepClone(obj);
                    delete obj[keyPath];
                }
                return obj;
            }
            : function (obj) { return obj; };
    }

    var Table =  (function () {
        function Table() {
        }
        Table.prototype._trans = function (mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName])
                    throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            var wasRootExec = beginMicroTickScope();
            try {
                return trans && trans.db === this.db ?
                    trans === PSD.trans ?
                        trans._promise(mode, checkTableInTransaction, writeLocked) :
                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :
                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            }
            finally {
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
        Table.prototype.get = function (keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
                return this.where(keyOrCrit).first(cb);
            return this._trans('readonly', function (trans) {
                return _this.core.get({ trans: trans, key: keyOrCrit })
                    .then(function (res) { return _this.hook.reading.fire(res); });
            }).then(cb);
        };
        Table.prototype.where = function (indexOrCrit) {
            if (typeof indexOrCrit === 'string')
                return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit))
                return new this.db.WhereClause(this, "[" + indexOrCrit.join('+') + "]");
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
                return this
                    .where(keyPaths[0])
                    .equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                return ix.compound &&
                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; }) &&
                    ix.keyPath.every(function (keyPath) { return keyPaths.indexOf(keyPath) >= 0; });
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString)
                return this
                    .where(compoundIndex.name)
                    .equals(compoundIndex.keyPath.map(function (kp) { return indexOrCrit[kp]; }));
            if (!compoundIndex && debug)
                console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " +
                    ("compound index [" + keyPaths.join('+') + "]"));
            var idxByName = this.schema.idxByName;
            var idb = this.db._deps.indexedDB;
            function equals(a, b) {
                try {
                    return idb.cmp(a, b) === 0;
                }
                catch (e) {
                    return false;
                }
            }
            var _a = keyPaths.reduce(function (_a, keyPath) {
                var prevIndex = _a[0], prevFilterFn = _a[1];
                var index = idxByName[keyPath];
                var value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ?
                        combine(prevFilterFn, index && index.multi ?
                            function (x) {
                                var prop = getByKeyPath(x, keyPath);
                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });
                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })
                        : prevFilterFn
                ];
            }, [null, null]), idx = _a[0], filterFunction = _a[1];
            return idx ?
                this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                    .filter(filterFunction) :
                compoundIndex ?
                    this.filter(filterFunction) :
                    this.where(keyPaths).equals('');
        };
        Table.prototype.filter = function (filterFunction) {
            return this.toCollection().and(filterFunction);
        };
        Table.prototype.count = function (thenShortcut) {
            return this.toCollection().count(thenShortcut);
        };
        Table.prototype.offset = function (offset) {
            return this.toCollection().offset(offset);
        };
        Table.prototype.limit = function (numRows) {
            return this.toCollection().limit(numRows);
        };
        Table.prototype.each = function (callback) {
            return this.toCollection().each(callback);
        };
        Table.prototype.toArray = function (thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        };
        Table.prototype.toCollection = function () {
            return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table.prototype.orderBy = function (index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
                "[" + index.join('+') + "]" :
                index));
        };
        Table.prototype.reverse = function () {
            return this.toCollection().reverse();
        };
        Table.prototype.mapToClass = function (constructor) {
            this.schema.mappedClass = constructor;
            var readHook = function (obj) {
                if (!obj)
                    return obj;
                var res = Object.create(constructor.prototype);
                for (var m in obj)
                    if (hasOwn(obj, m))
                        try {
                            res[m] = obj[m];
                        }
                        catch (_) { }
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        };
        Table.prototype.defineClass = function () {
            function Class(content) {
                extend(this, content);
            }
            return this.mapToClass(Class);
        };
        Table.prototype.add = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.update = function (keyOrObject, modifications) {
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined)
                    return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                try {
                    if (typeof modifications !== "function") {
                        keys(modifications).forEach(function (keyPath) {
                            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                        });
                    }
                    else {
                        modifications(keyOrObject, { value: keyOrObject, primKey: key });
                    }
                }
                catch (_a) {
                }
                return this.where(":id").equals(key).modify(modifications);
            }
            else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        };
        Table.prototype.put = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.delete = function (key) {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.clear = function () {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.bulkGet = function (keys) {
            var _this = this;
            return this._trans('readonly', function (trans) {
                return _this.core.getMany({
                    keys: keys,
                    trans: trans
                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });
            });
        };
        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToAdd = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(_this.name + ".bulkAdd(): " + numFailures + " of " + numObjects + " operations failed", failures);
                });
            });
        };
        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToPut = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(_this.name + ".bulkPut(): " + numFailures + " of " + numObjects + " operations failed", failures);
                });
            });
        };
        Table.prototype.bulkDelete = function (keys) {
            var _this = this;
            var numKeys = keys.length;
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });
            }).then(function (_a) {
                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                if (numFailures === 0)
                    return lastResult;
                throw new BulkError(_this.name + ".bulkDelete(): " + numFailures + " of " + numKeys + " operations failed", failures);
            });
        };
        return Table;
    }());

    function Events(ctx) {
        var evs = {};
        var rv = function (eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            }
            else if (typeof (eventName) === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object')
                return addConfiguredEvents(eventName);
            if (!chainFunction)
                chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
                defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function (cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function (cb) {
                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                }
                else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        context.subscribers.forEach(function (fn) {
                            asap$1(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                }
                else
                    throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype: prototype });
        return constructor;
    }

    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        });
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) &&
            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
            return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans: trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index: index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        }
        else {
            var set_1 = {};
            var union = function (item, cursor, advance) {
                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]')
                        key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn(set_1, key)) {
                        set_1[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function (cursor) {
            if (cursor) {
                return cursor.start(function () {
                    var c = function () { return cursor.continue(); };
                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))
                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });
                    c();
                });
            }
        });
    }

    function cmp(a, b) {
        try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
                if (ta === 'Array')
                    return 1;
                if (tb === 'Array')
                    return -1;
                if (ta === 'binary')
                    return 1;
                if (tb === 'binary')
                    return -1;
                if (ta === 'string')
                    return 1;
                if (tb === 'string')
                    return -1;
                if (ta === 'Date')
                    return 1;
                if (tb !== 'Date')
                    return NaN;
                return -1;
            }
            switch (ta) {
                case 'number':
                case 'Date':
                case 'string':
                    return a > b ? 1 : a < b ? -1 : 0;
                case 'binary': {
                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                }
                case 'Array':
                    return compareArrays(a, b);
            }
        }
        catch (_a) { }
        return NaN;
    }
    function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            var res = cmp(a[i], b[i]);
            if (res !== 0)
                return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
                return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function type(x) {
        var t = typeof x;
        if (t !== 'object')
            return t;
        if (ArrayBuffer.isView(x))
            return 'binary';
        var tsTag = toStringTag(x);
        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
    }
    function getUint8Array(a) {
        if (a instanceof Uint8Array)
            return a;
        if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
    }

    var Collection =  (function () {
        function Collection() {
        }
        Collection.prototype._read = function (fn, cb) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readonly', fn).then(cb);
        };
        Collection.prototype._write = function (fn) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readwrite', fn, "locked");
        };
        Collection.prototype._addAlgorithm = function (fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection.prototype._iterate = function (fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection.prototype.clone = function (props) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props)
                extend(ctx, props);
            rv._ctx = ctx;
            return rv;
        };
        Collection.prototype.raw = function () {
            this._ctx.valueMapper = null;
            return this;
        };
        Collection.prototype.each = function (fn) {
            var ctx = this._ctx;
            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });
        };
        Collection.prototype.count = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                var coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans: trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(function (count) { return Math.min(count, ctx.limit); });
                }
                else {
                    var count = 0;
                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)
                        .then(function () { return count; });
                }
            }).then(cb);
        };
        Collection.prototype.sortBy = function (keyPath, cb) {
            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i)
                    return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return aVal < bVal ? -order : aVal > bVal ? order : 0;
            }
            return this.toArray(function (a) {
                return a.sort(sorter);
            }).then(cb);
        };
        Collection.prototype.toArray = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    var valueMapper_1 = ctx.valueMapper;
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    }).then(function (_a) {
                        var result = _a.result;
                        return valueMapper_1 ? result.map(valueMapper_1) : result;
                    });
                }
                else {
                    var a_1 = [];
                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });
                }
            }, cb);
        };
        Collection.prototype.offset = function (offset) {
            var ctx = this._ctx;
            if (offset <= 0)
                return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function (cursor, advance) {
                        if (offsetLeft === 0)
                            return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(function () {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            }
            else {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function () { return (--offsetLeft < 0); };
                });
            }
            return this;
        };
        Collection.prototype.limit = function (numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function () {
                var rowsLeft = numRows;
                return function (cursor, advance, resolve) {
                    if (--rowsLeft <= 0)
                        advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        };
        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function (cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                }
                else {
                    return true;
                }
            });
            return this;
        };
        Collection.prototype.first = function (cb) {
            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.last = function (cb) {
            return this.reverse().first(cb);
        };
        Collection.prototype.filter = function (filterFunction) {
            addFilter(this._ctx, function (cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        };
        Collection.prototype.and = function (filter) {
            return this.filter(filter);
        };
        Collection.prototype.or = function (indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection.prototype.reverse = function () {
            this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
            if (this._ondirectionchange)
                this._ondirectionchange(this._ctx.dir);
            return this;
        };
        Collection.prototype.desc = function () {
            return this.reverse();
        };
        Collection.prototype.eachKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.key, cursor); });
        };
        Collection.prototype.eachUniqueKey = function (cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        };
        Collection.prototype.eachPrimaryKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
        };
        Collection.prototype.keys = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.key);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.primaryKeys = function (cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(function (trans) {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    });
                }).then(function (_a) {
                    var result = _a.result;
                    return result;
                }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.uniqueKeys = function (cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        };
        Collection.prototype.firstKey = function (cb) {
            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.lastKey = function (cb) {
            return this.reverse().firstKey(cb);
        };
        Collection.prototype.distinct = function () {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
                return this;
            var set = {};
            addFilter(this._ctx, function (cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        };
        Collection.prototype.modify = function (changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function (trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                }
                else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i], val = changes[keyPath];
                            if (getByKeyPath(item, keyPath) !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                var coreTable = ctx.table.core;
                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                var limit = _this.db._options.modifyChunkSize || 200;
                var totalFailures = [];
                var successCount = 0;
                var failedKeys = [];
                var applyMutateResult = function (expectedCount, res) {
                    var failures = res.failures, numFailures = res.numFailures;
                    successCount += expectedCount - numFailures;
                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
                        var pos = _a[_i];
                        totalFailures.push(failures[pos]);
                    }
                };
                return _this.clone().primaryKeys().then(function (keys) {
                    var nextChunk = function (offset) {
                        var count = Math.min(limit, keys.length - offset);
                        return coreTable.getMany({
                            trans: trans,
                            keys: keys.slice(offset, offset + count),
                            cache: "immutable"
                        }).then(function (values) {
                            var addValues = [];
                            var putValues = [];
                            var putKeys = outbound ? [] : null;
                            var deleteKeys = [];
                            for (var i = 0; i < count; ++i) {
                                var origValue = values[i];
                                var ctx_1 = {
                                    value: deepClone(origValue),
                                    primKey: keys[offset + i]
                                };
                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                    if (ctx_1.value == null) {
                                        deleteKeys.push(keys[offset + i]);
                                    }
                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                        deleteKeys.push(keys[offset + i]);
                                        addValues.push(ctx_1.value);
                                    }
                                    else {
                                        putValues.push(ctx_1.value);
                                        if (outbound)
                                            putKeys.push(keys[offset + i]);
                                    }
                                }
                            }
                            var criteria = isPlainKeyRange(ctx) &&
                                ctx.limit === Infinity &&
                                (typeof changes !== 'function' || changes === deleteCallback) && {
                                index: ctx.index,
                                range: ctx.range
                            };
                            return Promise.resolve(addValues.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })
                                    .then(function (res) {
                                    for (var pos in res.failures) {
                                        deleteKeys.splice(parseInt(pos), 1);
                                    }
                                    applyMutateResult(addValues.length, res);
                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'put',
                                    keys: putKeys,
                                    values: putValues,
                                    criteria: criteria,
                                    changeSpec: typeof changes !== 'function'
                                        && changes
                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'delete',
                                    keys: deleteKeys,
                                    criteria: criteria
                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {
                                return keys.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(function () {
                        if (totalFailures.length > 0)
                            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys.length;
                    });
                });
            });
        };
        Collection.prototype.delete = function () {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) &&
                ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))
             {
                return this._write(function (trans) {
                    var primaryKey = ctx.table.core.schema.primaryKey;
                    var coreRange = range;
                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {
                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })
                            .then(function (_a) {
                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;
                            if (numFailures)
                                throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(deleteCallback);
        };
        return Collection;
    }());
    var deleteCallback = function (value, ctx) { return ctx.value = null; };

    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
            this.db = db;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
                try {
                    keyRange = keyRangeGenerator();
                }
                catch (ex) {
                    error = ex;
                }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ?
            new collectionOrWhereClause.Collection(collectionOrWhereClause) :
            collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function () { return rangeEqual(""); }).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toUpperCase(); } :
            function (s) { return s.toLowerCase(); };
    }
    function lowerFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toLowerCase(); } :
            function (s) { return s.toUpperCase(); };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0)
                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0)
                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0)
                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0)
                llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function (s) { return typeof s === 'string'; })) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
            var needleBounds = needles.map(function (needle) {
                return { lower: lower(needle), upper: upper(needle) };
            }).sort(function (a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
            direction = dir;
            nextKeySuffix = (dir === "next" ? "" : suffix);
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });
        c._ondirectionchange = function (direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function (cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string')
                return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            }
            else {
                var lowestPossibleCasing = null;
                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null)
                        firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                }
                else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2 ,
            lower: lower,
            upper: upper,
            lowerOpen: lowerOpen,
            upperOpen: upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1 ,
            lower: value,
            upper: value
        };
    }

    var WhereClause =  (function () {
        function WhereClause() {
        }
        Object.defineProperty(WhereClause.prototype, "Collection", {
            get: function () {
                return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
        });
        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if ((this._cmp(lower, upper) > 0) ||
                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                    return emptyCollection(this);
                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        };
        WhereClause.prototype.equals = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return rangeEqual(value); });
        };
        WhereClause.prototype.above = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, true); });
        };
        WhereClause.prototype.aboveOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, false); });
        };
        WhereClause.prototype.below = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });
        };
        WhereClause.prototype.belowOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value); });
        };
        WhereClause.prototype.startsWith = function (str) {
            if (typeof str !== 'string')
                return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        };
        WhereClause.prototype.startsWithIgnoreCase = function (str) {
            if (str === "")
                return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);
        };
        WhereClause.prototype.equalsIgnoreCase = function (str) {
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], "");
        };
        WhereClause.prototype.anyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, "");
        };
        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);
        };
        WhereClause.prototype.anyOf = function () {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
                set.sort(compare);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
                return emptyCollection(this);
            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });
            c._ondirectionchange = function (direction) {
                compare = (direction === "next" ?
                    _this._ascending :
                    _this._descending);
                set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (compare(key, set[i]) > 0) {
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                }
                else {
                    advance(function () { cursor.continue(set[i]); });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.notEqual = function (value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.noneOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return new this.Collection(this);
            try {
                set.sort(this._ascending);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function (res, val) { return res ?
                res.concat([[res[res.length - 1][1], val]]) :
                [[minKey, val]]; }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.inAnyRange = function (ranges, options) {
            var _this = this;
            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
                return emptyCollection(this);
            if (!ranges.every(function (range) {
                return range[0] !== undefined &&
                    range[1] !== undefined &&
                    ascending(range[0], range[1]) <= 0;
            })) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                var i = 0, l = ranges.length;
                for (; i < l; ++i) {
                    var range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l)
                    ranges.push(newRange);
                return ranges;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
            var set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            }
            catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ?
                function (key) { return ascending(key, set[rangePos][1]) > 0; } :
                function (key) { return ascending(key, set[rangePos][1]) >= 0; };
            var keyIsBeforeCurrentEntry = includeLowers ?
                function (key) { return descending(key, set[rangePos][0]) > 0; } :
                function (key) { return descending(key, set[rangePos][0]) >= 0; };
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });
            c._ondirectionchange = function (direction) {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                }
                else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (checkKey(key)) {
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                }
                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                }
                else {
                    advance(function () {
                        if (sortDirection === ascending)
                            cursor.continue(set[rangePos][0]);
                        else
                            cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.startsWithAnyOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function (s) { return typeof s === 'string'; })) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
                return emptyCollection(this);
            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));
        };
        return WhereClause;
    }());

    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            var indexedDB = db._deps.indexedDB;
            if (!indexedDB)
                throw new exceptions.MissingAPI();
            this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);
            this._descending = function (a, b) { return indexedDB.cmp(b, a); };
            this._max = function (a, b) { return indexedDB.cmp(a, b) > 0 ? a : b; };
            this._min = function (a, b) { return indexedDB.cmp(a, b) < 0 ? a : b; };
            this._IDBKeyRange = db._deps.IDBKeyRange;
        });
    }

    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation)
            event.stopPropagation();
        if (event.preventDefault)
            event.preventDefault();
    }

    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

    var Transaction =  (function () {
        function Transaction() {
        }
        Transaction.prototype._lock = function () {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
                PSD.lockOwnerFor = this;
            return this;
        };
        Transaction.prototype._unlock = function () {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global)
                    PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    }
                    catch (e) { }
                }
            }
            return this;
        };
        Transaction.prototype._locked = function () {
            return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction.prototype.create = function (idbtrans) {
            var _this = this;
            if (!this.mode)
                return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active)
                throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans ||
                (this.db.core
                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(function (ev) {
                preventDefault(ev);
                _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function (ev) {
                preventDefault(ev);
                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                _this.active = false;
                _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function () {
                _this.active = false;
                _this._resolve();
                if ('mutatedParts' in idbtrans) {
                    globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                }
            });
            return this;
        };
        Transaction.prototype._promise = function (mode, fn, bWriteLock) {
            var _this = this;
            if (mode === 'readwrite' && this.mode !== 'readwrite')
                return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
                return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise(function (resolve, reject) {
                    _this._blockedFuncs.push([function () {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                });
            }
            else if (bWriteLock) {
                return newScope(function () {
                    var p = new DexiePromise(function (resolve, reject) {
                        _this._lock();
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then)
                            rv.then(resolve, reject);
                    });
                    p.finally(function () { return _this._unlock(); });
                    p._lib = true;
                    return p;
                });
            }
            else {
                var p = new DexiePromise(function (resolve, reject) {
                    var rv = fn(resolve, reject, _this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        };
        Transaction.prototype._root = function () {
            return this.parent ? this.parent._root() : this;
        };
        Transaction.prototype.waitFor = function (promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(function () { return promise; });
            }
            else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while (root._waitingQueue.length)
                        (root._waitingQueue.shift())();
                    if (root._waitingFor)
                        store.get(-Infinity).onsuccess = spin;
                }());
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function (resolve, reject) {
                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        };
        Transaction.prototype.abort = function () {
            if (this.active) {
                this.active = false;
                if (this.idbtrans)
                    this.idbtrans.abort();
                this._reject(new exceptions.Abort());
            }
        };
        Transaction.prototype.table = function (tableName) {
            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
            if (hasOwn(memoizedTables, tableName))
                return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        };
        return Transaction;
    }());

    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function () {
                _this.active = false;
                _this.on.complete.fire();
            }, function (e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ?
                    _this.parent._reject(e) :
                    wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e);
            });
        });
    }

    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
            name: name,
            keyPath: keyPath,
            unique: unique,
            multi: multi,
            auto: auto,
            compound: compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ?
            keyPath :
            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
    }

    function createTableSchema(name, primKey, indexes) {
        return {
            name: name,
            primKey: primKey,
            indexes: indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })
        };
    }

    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    var getMaxKey = function (IdbKeyRange) {
        try {
            IdbKeyRange.only([[]]);
            getMaxKey = function () { return [[]]; };
            return [[]];
        }
        catch (e) {
            getMaxKey = function () { return maxString; };
            return maxString;
        }
    };

    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return function () { return undefined; };
        }
        else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split('.');
        if (split.length === 1) {
            return function (obj) { return obj[keyPath]; };
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }

    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }
    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ?
            ":id" :
            typeof keyPath === 'string' ?
                keyPath :
                "[" + keyPath.join('+') + "]";
    }
    function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db, trans) {
            var tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {
                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                        var compound = isArray(keyPath);
                        var outbound = keyPath == null;
                        var indexByKeyPath = {};
                        var result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound: outbound,
                                compound: compound,
                                keyPath: keyPath,
                                autoIncrement: autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })
                                .map(function (index) {
                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                var compound = isArray(keyPath);
                                var result = {
                                    name: name,
                                    compound: compound,
                                    keyPath: keyPath,
                                    unique: unique,
                                    multiEntry: multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3 )
                return null;
            if (range.type === 4 )
                throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === undefined ?
                upper === undefined ?
                    null :
                    IdbKeyRange.upperBound(upper, !!upperOpen) :
                upper === undefined ?
                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a) {
                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var outbound = store.keyPath == null;
                    var isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                        throw new Error("Invalid operation type: " + type);
                    var length = (keys || values || { length: 1 }).length;
                    if (keys && values && keys.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0)
                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                    var req;
                    var reqs = [];
                    var failures = [];
                    var numFailures = 0;
                    var errorHandler = function (event) {
                        ++numFailures;
                        preventDefault(event);
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4 )
                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });
                        if (range.type === 3 )
                            reqs.push(req = store.clear());
                        else
                            reqs.push(req = store.delete(makeIDBKeyRange(range)));
                    }
                    else {
                        var _a = isAddOrPut ?
                            outbound ?
                                [values, keys] :
                                [values, null] :
                            [keys, null], args1 = _a[0], args2 = _a[1];
                        if (isAddOrPut) {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = (args2 && args2[i] !== undefined ?
                                    store[type](args1[i], args2[i]) :
                                    store[type](args1[i])));
                                req.onerror = errorHandler;
                            }
                        }
                        else {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    var done = function (event) {
                        var lastResult = event.target.result;
                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });
                        resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: type === "delete" ? keys : reqs.map(function (req) { return req.result; }),
                            lastResult: lastResult
                        });
                    };
                    req.onerror = function (event) {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor(_a) {
                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ?
                        store :
                        store.index(index.name);
                    var direction = reverse ?
                        unique ?
                            "prevunique" :
                            "prev" :
                        unique ?
                            "nextunique" :
                            "next";
                    var req = values || !('openKeyCursor' in source) ?
                        source.openCursor(makeIDBKeyRange(range), direction) :
                        source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function (ev) {
                        var cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        var _cursorContinue = cursor.continue.bind(cursor);
                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey)
                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        var _cursorAdvance = cursor.advance.bind(cursor);
                        var doThrowCursorIsNotStarted = function () { throw new Error("Cursor not started"); };
                        var doThrowCursorIsStopped = function () { throw new Error("Cursor not stopped"); };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function () {
                            var _this = this;
                            var gotOne = 1;
                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });
                        };
                        cursor.start = function (callback) {
                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = function (value) {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            var guardedCallback = function () {
                                if (req.result) {
                                    try {
                                        callback();
                                    }
                                    catch (err) {
                                        cursor.fail(err);
                                    }
                                }
                                else {
                                    cursor.done = true;
                                    cursor.start = function () { throw new Error("Cursor behind last entry"); };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(function (ev) {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return function (request) {
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                        var nonInfinitLimit = limit === Infinity ? undefined : limit;
                        var index = query.index, range = query.range;
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0)
                            return resolve({ result: [] });
                        if (hasGetAll) {
                            var req = values ?
                                source.getAll(idbKeyRange, nonInfinitLimit) :
                                source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };
                            req.onerror = eventRejectHandler(reject);
                        }
                        else {
                            var count_1 = 0;
                            var req_1 = values || !('openKeyCursor' in source) ?
                                source.openCursor(idbKeyRange) :
                                source.openKeyCursor(idbKeyRange);
                            var result_1 = [];
                            req_1.onsuccess = function (event) {
                                var cursor = req_1.result;
                                if (!cursor)
                                    return resolve({ result: result_1 });
                                result_1.push(values ? cursor.value : cursor.primaryKey);
                                if (++count_1 === limit)
                                    return resolve({ result: result_1 });
                                cursor.continue();
                            };
                            req_1.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate: mutate,
                getMany: function (_a) {
                    var trans = _a.trans, keys = _a.keys;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var length = keys.length;
                        var result = new Array(length);
                        var keyCount = 0;
                        var callbackCount = 0;
                        var req;
                        var successHandler = function (event) {
                            var req = event.target;
                            if ((result[req._pos] = req.result) != null)
                                ;
                            if (++callbackCount === keyCount)
                                resolve(result);
                        };
                        var errorHandler = eventRejectHandler(reject);
                        for (var i = 0; i < length; ++i) {
                            var key = keys[i];
                            if (key != null) {
                                req = store.get(keys[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0)
                            resolve(result);
                    });
                },
                get: function (_a) {
                    var trans = _a.trans, key = _a.key;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var req = store.get(key);
                        req.onsuccess = function (event) { return resolve(event.target.result); };
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor: openCursor,
                count: function (_a) {
                    var query = _a.query, trans = _a.trans;
                    var index = query.index, range = query.range;
                    return new Promise(function (resolve, reject) {
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });
        var tableMap = {};
        tables.forEach(function (table) { return tableMap[table.name] = table; });
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table: function (name) {
                var result = tableMap[name];
                if (!result)
                    throw new Error("Table '" + name + "' not found");
                return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema: schema
        };
    }

    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function (down, _a) {
            var create = _a.create;
            return (__assign(__assign({}, down), create(down)));
        }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore: dbcore
        };
    }
    function generateMiddlewareStacks(_a, tmpTrans) {
        var db = _a._novip;
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function (table) {
            var tableName = table.name;
            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }

    function setApiOnPlace(_a, objs, tableNames, dbschema) {
        var db = _a._novip;
        tableNames.forEach(function (tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function (obj) {
                var propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get: function () { return this.table(tableName); },
                            set: function (value) {
                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });
                            }
                        });
                    }
                    else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi(_a, objs) {
        var db = _a._novip;
        objs.forEach(function (obj) {
            for (var key in obj) {
                if (obj[key] instanceof db.Table)
                    delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function () {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(function (tableName) {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);
            }
            else
                updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
        });
    }
    function updateTablesAndIndexes(_a, oldVersion, trans, idbUpgradeTrans) {
        var db = _a._novip;
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var anyContentUpgraderHasRun = false;
        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });
        versToRun.forEach(function (version) {
            queue.push(function () {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(function (tuple) {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(function (change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    }
                    else {
                        var store_1 = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });
                        change.change.forEach(function (idx) {
                            store_1.deleteIndex(idx.name);
                            addIndex(store_1, idx);
                        });
                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });
                    }
                });
                var contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    anyContentUpgraderHasRun = true;
                    var upgradeSchema_1 = shallowClone(newSchema);
                    diff.del.forEach(function (table) {
                        upgradeSchema_1[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [db.Transaction.prototype]);
                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                    trans.schema = upgradeSchema_1;
                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync_1) {
                        incrementExpectedAwaits();
                    }
                    var returnValue_1;
                    var promiseFollowed = DexiePromise.follow(function () {
                        returnValue_1 = contentUpgrade(trans);
                        if (returnValue_1) {
                            if (contentUpgradeIsAsync_1) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue_1.then(decrementor, decrementor);
                            }
                        }
                    });
                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?
                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));
                }
            });
            queue.push(function (idbtrans) {
                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                    var newSchema = version._cfg.dbschema;
                    deleteRemovedTables(newSchema, idbtrans);
                }
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                DexiePromise.resolve();
        }
        return runQueue().then(function () {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [],
            add: [],
            change: []
        };
        var table;
        for (table in oldSchema) {
            if (!newSchema[table])
                diff.del.push(table);
        }
        for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            }
            else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ((
                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                    (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))
                 {
                    change.recreate = true;
                    diff.change.push(change);
                }
                else {
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    var idxName = void 0;
                    for (idxName in oldIndexes) {
                        if (!newIndexes[idxName])
                            change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx)
                            change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src)
                            change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
            { autoIncrement: primKey.auto });
        indexes.forEach(function (idx) { return addIndex(store, idx); });
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function (tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function (storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema(_a, idbdb, tmpTrans) {
        var db = _a._novip;
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));
    }
    function adjustToExistingIndexNames(_a, schema, idbtrans) {
        var db = _a._novip;
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
            !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
            [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map(function (index, indexNum) {
            index = index.trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
        });
    }

    var Version =  (function () {
        function Version() {
        }
        Version.prototype._parseStoresSpec = function (stores, outSchema) {
            keys(stores).forEach(function (tableName) {
                if (stores[tableName] !== null) {
                    var indexes = parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (primKey.multi)
                        throw new exceptions.Schema("Primary key cannot be multi-valued");
                    indexes.forEach(function (idx) {
                        if (idx.auto)
                            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!idx.keyPath)
                            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                    });
                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
                }
            });
        };
        Version.prototype.stores = function (stores) {
            var db = this.db;
            this._cfg.storesSource = this._cfg.storesSource ?
                extend(this._cfg.storesSource, stores) :
                stores;
            var versions = db._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function (version) {
                extend(storesSpec, version._cfg.storesSource);
                dbschema = (version._cfg.dbschema = {});
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        };
        Version.prototype.upgrade = function (upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
        };
        return Version;
    }());

    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }

    function getDbNamesTable(indexedDB, IDBKeyRange) {
        var dbNamesDB = indexedDB["_dbNamesDB"];
        if (!dbNamesDB) {
            dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                addons: [],
                indexedDB: indexedDB,
                IDBKeyRange: IDBKeyRange,
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB) {
        return indexedDB && typeof indexedDB.databases === "function";
    }
    function getDatabaseNames(_a) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        return hasDatabasesNative(indexedDB)
            ? Promise.resolve(indexedDB.databases()).then(function (infos) {
                return infos
                    .map(function (info) { return info.name; })
                    .filter(function (name) { return name !== DBNAMES_DB; });
            })
            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);
    }
    function _onDatabaseDeleted(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
    }

    function vip(fn) {
        return newScope(function () {
            PSD.letThrough = true;
            return fn();
        });
    }

    function idbReady() {
        var isSafari = !navigator.userAgentData &&
            /Safari\//.test(navigator.userAgent) &&
            !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
        var intervalId;
        return new Promise(function (resolve) {
            var tryIdb = function () { return indexedDB.databases().finally(resolve); };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
        }).finally(function () { return clearInterval(intervalId); });
    }

    function dexieOpen(db) {
        var state = db._state;
        var indexedDB = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
            return state.dbReadyPromise.then(function () { return state.dbOpenError ?
                rejection(state.dbOpenError) :
                db; });
        debug && (state.openCanceller._stackHolder = getErrorWithStack());
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
                throw new exceptions.DatabaseClosed('db.open() was cancelled');
        }
        var resolveDbReady = state.dbReadyResolve,
        upgradeTransaction = null, wasCreated = false;
        return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(function () { return new DexiePromise(function (resolve, reject) {
                throwIfCancelled();
                if (!indexedDB)
                    throw new exceptions.MissingAPI();
                var dbName = db.name;
                var req = state.autoSchema ?
                    indexedDB.open(dbName) :
                    indexedDB.open(dbName, Math.round(db.verno * 10));
                if (!req)
                    throw new exceptions.MissingAPI();
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(db._fireOnBlocked);
                req.onupgradeneeded = wrap(function (e) {
                    upgradeTransaction = req.transaction;
                    if (state.autoSchema && !db._options.allowEmptyDB) {
                        req.onerror = preventDefault;
                        upgradeTransaction.abort();
                        req.result.close();
                        var delreq = indexedDB.deleteDatabase(dbName);
                        delreq.onsuccess = delreq.onerror = wrap(function () {
                            reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
                        });
                    }
                    else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                        wasCreated = oldVer < 1;
                        db._novip.idbdb = req.result;
                        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                    }
                }, reject);
                req.onsuccess = wrap(function () {
                    upgradeTransaction = null;
                    var idbdb = db._novip.idbdb = req.result;
                    var objectStoreNames = slice(idbdb.objectStoreNames);
                    if (objectStoreNames.length > 0)
                        try {
                            var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                            if (state.autoSchema)
                                readGlobalSchema(db, idbdb, tmpTrans);
                            else {
                                adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                                if (!verifyInstalledSchema(db, tmpTrans)) {
                                    console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
                                }
                            }
                            generateMiddlewareStacks(db, tmpTrans);
                        }
                        catch (e) {
                        }
                    connections.push(db);
                    idbdb.onversionchange = wrap(function (ev) {
                        state.vcFired = true;
                        db.on("versionchange").fire(ev);
                    });
                    idbdb.onclose = wrap(function (ev) {
                        db.on("close").fire(ev);
                    });
                    if (wasCreated)
                        _onDatabaseCreated(db._deps, dbName);
                    resolve();
                }, reject);
            }); })]).then(function () {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);
                }
            });
        }).finally(function () {
            state.onReadyBeingFired = null;
            state.isBeingOpened = false;
        }).then(function () {
            return db;
        }).catch(function (err) {
            state.dbOpenError = err;
            try {
                upgradeTransaction && upgradeTransaction.abort();
            }
            catch (_a) { }
            if (openCanceller === state.openCanceller) {
                db._close();
            }
            return rejection(err);
        }).finally(function () {
            state.openComplete = true;
            resolveDbReady();
        });
    }

    function awaitIterator(iterator) {
        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return function (val) {
                var next = getNext(val), value = next.value;
                return next.done ? value :
                    (!value || typeof value.then !== 'function' ?
                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                        value.then(onSuccess, onError));
            };
        }
        return step(callNext)();
    }

    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
            args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function () {
            var transless = PSD.transless || PSD;
            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            var zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            }
            else {
                try {
                    trans.create();
                    db._state.PR1398_maxLoop = 3;
                }
                catch (ex) {
                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                        console.warn('Dexie: Need to reopen db');
                        db._close();
                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });
                    }
                    return rejection(ex);
                }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function () {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    }
                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ?
                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?
                    x
                    : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")); })
                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {
                if (parentTransaction)
                    trans._resolve();
                return trans._completion.then(function () { return x; });
            }).catch(function (e) {
                trans._reject(e);
                return rejection(e);
            });
        });
    }

    function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [a];
        for (var i = 0; i < count; ++i)
            result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function (tableName) {
                var table = down.table(tableName);
                var schema = table.schema;
                var indexLookup = {};
                var allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    var keyPathAlias = getKeyPathAlias(keyPath);
                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    var isVirtual = keyTail > 0;
                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        var virtualKeyPath = keyLength === 2 ?
                            keyPath[0] :
                            keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });
                    return virtualIndex;
                }
                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [primaryKey];
                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
                    var index = _a[_i];
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    var result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1  ?
                            2  :
                            range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    var index = req.query.index;
                    return index.isVirtual ? __assign(__assign({}, req), { query: {
                            index: index,
                            range: translateRange(req.query.range, index.keyTail)
                        } }) : req;
                }
                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {
                        return table.count(translateRequest(req));
                    }, query: function (req) {
                        return table.query(translateRequest(req));
                    }, openCursor: function (req) {
                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                        if (!isVirtual)
                            return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ?
                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                    req.unique ?
                                        cursor.continue(cursor.key.slice(0, keyLength)
                                            .concat(req.reverse
                                            ? down.MIN_KEY
                                            : down.MAX_KEY, keyTail)) :
                                        cursor.continue();
                            }
                            var virtualCursor = Object.create(cursor, {
                                continue: { value: _continue },
                                continuePrimaryKey: {
                                    value: function (key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                primaryKey: {
                                    get: function () {
                                        return cursor.primaryKey;
                                    }
                                },
                                key: {
                                    get: function () {
                                        var key = cursor.key;
                                        return keyLength === 1 ?
                                            key[0] :
                                            key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get: function () {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req))
                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });
                    } });
                return result;
            } });
    }
    var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };

    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function (prop) {
            if (!hasOwn(b, prop)) {
                rv[prfx + prop] = undefined;
            }
            else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    var apTypeName = toStringTag(ap);
                    var bpTypeName = toStringTag(bp);
                    if (apTypeName !== bpTypeName) {
                        rv[prfx + prop] = b[prop];
                    }
                    else if (apTypeName === 'Object') {
                        getObjectDiff(ap, bp, rv, prfx + prop + '.');
                    }
                    else if (ap !== bp) {
                        rv[prfx + prop] = b[prop];
                    }
                }
                else if (ap !== bp)
                    rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach(function (prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }

    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete')
            return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }

    var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {
                var downTable = downCore.table(tableName);
                var primaryKey = downTable.schema.primaryKey;
                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {
                        var dxTrans = PSD.trans;
                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                        switch (req.type) {
                            case 'add':
                                if (creating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'put':
                                if (creating.fire === nop && updating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'delete':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'deleteRange':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            var dxTrans = PSD.trans;
                            var keys = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys)
                                throw new Error("Keys missing");
                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);
                            if (req.type !== 'delete')
                                req.values = __spreadArray([], req.values, true);
                            if (req.keys)
                                req.keys = __spreadArray([], req.keys, true);
                            return getExistingValues(downTable, req, keys).then(function (existingValues) {
                                var contexts = keys.map(function (key, i) {
                                    var existingValue = existingValues[i];
                                    var ctx = { onerror: null, onsuccess: null };
                                    if (req.type === 'delete') {
                                        deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    }
                                    else if (req.type === 'add' || existingValue === undefined) {
                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) {
                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                            }
                                        }
                                    }
                                    else {
                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges_1) {
                                            var requestedValue_1 = req.values[i];
                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {
                                                if (hasOwn(requestedValue_1, keyPath)) {
                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                }
                                                else {
                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                }
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(function (_a) {
                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                    for (var i = 0; i < keys.length; ++i) {
                                        var primKey = results ? results[i] : keys[i];
                                        var ctx = contexts[i];
                                        if (primKey == null) {
                                            ctx.onerror && ctx.onerror(failures[i]);
                                        }
                                        else {
                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                req.values[i] :
                                                primKey
                                            );
                                        }
                                    }
                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };
                                }).catch(function (error) {
                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })
                                .then(function (_a) {
                                var result = _a.result;
                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {
                                    if (res.numFailures > 0)
                                        return Promise.reject(res.failures[0]);
                                    if (result.length < limit) {
                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                    }
                                    else {
                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                                    }
                                });
                            });
                        }
                    } });
                return tableMiddleware;
            } })); }
    };
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add"
            ? Promise.resolve([])
            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
    }

    function getFromTransactionCache(keys, cache, clone) {
        try {
            if (!cache)
                return null;
            if (cache.keys.length < keys.length)
                return null;
            var result = [];
            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
                if (cmp(cache.keys[i], keys[j]) !== 0)
                    continue;
                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                ++j;
            }
            return result.length === keys.length ? result : null;
        }
        catch (_a) {
            return null;
        }
    }
    var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function (core) {
            return {
                table: function (tableName) {
                    var table = core.table(tableName);
                    return __assign(__assign({}, table), { getMany: function (req) {
                            if (!req.cache) {
                                return table.getMany(req);
                            }
                            var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                            if (cachedResult) {
                                return DexiePromise.resolve(cachedResult);
                            }
                            return table.getMany(req).then(function (res) {
                                req.trans["_cache"] = {
                                    keys: req.keys,
                                    values: req.cache === "clone" ? deepClone(res) : res,
                                };
                                return res;
                            });
                        }, mutate: function (req) {
                            if (req.type !== "add")
                                req.trans["_cache"] = null;
                            return table.mutate(req);
                        } });
                },
            };
        },
    };

    var _a;
    function isEmptyRange(node) {
        return !("from" in node);
    }
    var RangeSet = function (fromOrTree, to) {
        if (this) {
            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        }
        else {
            var rv = new RangeSet();
            if (fromOrTree && ("d" in fromOrTree)) {
                extend(rv, fromOrTree);
            }
            return rv;
        }
    };
    props(RangeSet.prototype, (_a = {
            add: function (rangeSet) {
                mergeRanges(this, rangeSet);
                return this;
            },
            addKey: function (key) {
                addRange(this, key, key);
                return this;
            },
            addKeys: function (keys) {
                var _this = this;
                keys.forEach(function (key) { return addRange(_this, key, key); });
                return this;
            }
        },
        _a[iteratorSymbol] = function () {
            return getRangeSetIterator(this);
        },
        _a));
    function addRange(target, from, to) {
        var diff = cmp(from, to);
        if (isNaN(diff))
            return;
        if (diff > 0)
            throw RangeError();
        if (isEmptyRange(target))
            return extend(target, { from: from, to: to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp(to, target.from) < 0) {
            left
                ? addRange(left, from, to)
                : (target.l = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.to) > 0) {
            right
                ? addRange(right, from, to)
                : (target.r = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
        }
        if (cmp(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
            mergeRanges(target, left);
        }
        if (right && rightWasCutOff) {
            mergeRanges(target, right);
        }
    }
    function mergeRanges(target, newSet) {
        function _addRangeSet(target, _a) {
            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
            addRange(target, from, to);
            if (l)
                _addRangeSet(target, l);
            if (r)
                _addRangeSet(target, r);
        }
        if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
            return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
                return true;
            cmp(a.from, b.from) < 0
                ? (a = (nextResult1 = i1.next(b.from)).value)
                : (b = (nextResult2 = i2.next(a.from)).value);
        }
        return false;
    }
    function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
            next: function (key) {
                var keyProvided = arguments.length > 0;
                while (state) {
                    switch (state.s) {
                        case 0:
                            state.s = 1;
                            if (keyProvided) {
                                while (state.n.l && cmp(key, state.n.from) < 0)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                            else {
                                while (state.n.l)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                        case 1:
                            state.s = 2;
                            if (!keyProvided || cmp(key, state.n.to) <= 0)
                                return { value: state.n, done: false };
                        case 2:
                            if (state.n.r) {
                                state.s = 3;
                                state = { up: state, n: state.n.r, s: 0 };
                                continue;
                            }
                        case 3:
                            state = state.up;
                    }
                }
                return { done: true };
            },
        };
    }
    function rebalance(target) {
        var _a, _b;
        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
    }
    function computeDepth(_a) {
        var r = _a.r, l = _a.l;
        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
    }

    var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        create: function (core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), { table: function (tableName) {
                    var table = core.table(tableName);
                    var schema = table.schema;
                    var primaryKey = schema.primaryKey;
                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {
                            var trans = req.trans;
                            var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
                            var getRangeSet = function (indexName) {
                                var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
                                return (mutatedParts[part] ||
                                    (mutatedParts[part] = new RangeSet()));
                            };
                            var pkRangeSet = getRangeSet("");
                            var delsRangeSet = getRangeSet(":dels");
                            var type = req.type;
                            var _a = req.type === "deleteRange"
                                ? [req.range]
                                : req.type === "delete"
                                    ? [req.keys]
                                    : req.values.length < 50
                                        ? [[], req.values]
                                        : [], keys = _a[0], newObjs = _a[1];
                            var oldCache = req.trans["_cache"];
                            return table.mutate(req).then(function (res) {
                                if (isArray(keys)) {
                                    if (type !== "delete")
                                        keys = res.results;
                                    pkRangeSet.addKeys(keys);
                                    var oldObjs = getFromTransactionCache(keys, oldCache);
                                    if (!oldObjs && type !== "add") {
                                        delsRangeSet.addKeys(keys);
                                    }
                                    if (oldObjs || newObjs) {
                                        trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                    }
                                }
                                else if (keys) {
                                    var range = { from: keys.lower, to: keys.upper };
                                    delsRangeSet.add(range);
                                    pkRangeSet.add(range);
                                }
                                else {
                                    pkRangeSet.add(FULL_RANGE);
                                    delsRangeSet.add(FULL_RANGE);
                                    schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });
                                }
                                return res;
                            });
                        } });
                    var getRange = function (_a) {
                        var _b, _c;
                        var _d = _a.query, index = _d.index, range = _d.range;
                        return [
                            index,
                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),
                        ];
                    };
                    var readSubscribers = {
                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },
                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },
                        count: getRange,
                        query: getRange,
                        openCursor: getRange,
                    };
                    keys(readSubscribers).forEach(function (method) {
                        tableClone[method] = function (req) {
                            var subscr = PSD.subscr;
                            if (subscr) {
                                var getRangeSet = function (indexName) {
                                    var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
                                    return (subscr[part] ||
                                        (subscr[part] = new RangeSet()));
                                };
                                var pkRangeSet_1 = getRangeSet("");
                                var delsRangeSet_1 = getRangeSet(":dels");
                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                                getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                if (!queriedIndex.isPrimaryKey) {
                                    if (method === "count") {
                                        delsRangeSet_1.add(FULL_RANGE);
                                    }
                                    else {
                                        var keysPromise_1 = method === "query" &&
                                            outbound &&
                                            req.values &&
                                            table.query(__assign(__assign({}, req), { values: false }));
                                        return table[method].apply(this, arguments).then(function (res) {
                                            if (method === "query") {
                                                if (outbound && req.values) {
                                                    return keysPromise_1.then(function (_a) {
                                                        var resultingKeys = _a.result;
                                                        pkRangeSet_1.addKeys(resultingKeys);
                                                        return res;
                                                    });
                                                }
                                                var pKeys = req.values
                                                    ? res.result.map(extractKey)
                                                    : res.result;
                                                if (req.values) {
                                                    pkRangeSet_1.addKeys(pKeys);
                                                }
                                                else {
                                                    delsRangeSet_1.addKeys(pKeys);
                                                }
                                            }
                                            else if (method === "openCursor") {
                                                var cursor_1 = res;
                                                var wantValues_1 = req.values;
                                                return (cursor_1 &&
                                                    Object.create(cursor_1, {
                                                        key: {
                                                            get: function () {
                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.key;
                                                            },
                                                        },
                                                        primaryKey: {
                                                            get: function () {
                                                                var pkey = cursor_1.primaryKey;
                                                                delsRangeSet_1.addKey(pkey);
                                                                return pkey;
                                                            },
                                                        },
                                                        value: {
                                                            get: function () {
                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.value;
                                                            },
                                                        },
                                                    }));
                                            }
                                            return res;
                                        });
                                    }
                                }
                            }
                            return table[method].apply(this, arguments);
                        };
                    });
                    return tableClone;
                } });
        },
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
                return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)
                ? key.forEach(function (key) { return rangeSet.addKey(key); })
                : rangeSet.addKey(key); };
            (oldObjs || newObjs).forEach(function (_, i) {
                var oldKey = oldObjs && extractKey(oldObjs[i]);
                var newKey = newObjs && extractKey(newObjs[i]);
                if (cmp(oldKey, newKey) !== 0) {
                    if (oldKey != null)
                        addKeyOrKeys(oldKey);
                    if (newKey != null)
                        addKeyOrKeys(newKey);
                }
            });
        }
        schema.indexes.forEach(addAffectedIndex);
    }

    var Dexie$1 =  (function () {
        function Dexie(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie.dependencies;
            this._options = options = __assign({
                addons: Dexie.addons, autoOpen: true,
                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange }, options);
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true,
                PR1398_maxLoop: 3
            };
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
                return function (subscriber, bSticky) {
                    Dexie.vip(function () {
                        var state = _this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError)
                                DexiePromise.resolve().then(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else {
                            subscribe(subscriber);
                            var db_1 = _this;
                            if (!bSticky)
                                subscribe(function unsubscribe() {
                                    db_1.on.ready.unsubscribe(subscriber);
                                    db_1.on.ready.unsubscribe(unsubscribe);
                                });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function (ev) {
                if (ev.newVersion > 0)
                    console.warn("Another connection wants to upgrade database '" + _this.name + "'. Closing db now to resume the upgrade.");
                else
                    console.warn("Another connection wants to delete database '" + _this.name + "'. Closing db now to resume the delete request.");
                _this.close();
            });
            this.on("blocked", function (ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                    console.warn("Dexie.delete('" + _this.name + "') was blocked");
                else
                    console.warn("Upgrade '" + _this.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };
            this._fireOnBlocked = function (ev) {
                _this.on("blocked").fire(ev);
                connections
                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })
                    .map(function (c) { return c.on("versionchange").fire(ev); });
            };
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            this.use(observabilityMiddleware);
            this.use(cacheExistingValuesMiddleware);
            this.vip = Object.create(this, { _vip: { value: true } });
            addons.forEach(function (addon) { return addon(_this); });
        }
        Dexie.prototype.version = function (versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
                throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
                throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];
            if (versionInstance)
                return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        };
        Dexie.prototype._whenReady = function (fn) {
            var _this = this;
            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {
                if (_this._state.openComplete) {
                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
                }
                if (!_this._state.isBeingOpened) {
                    if (!_this._options.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    _this.open().catch(nop);
                }
                _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        Dexie.prototype.use = function (_a) {
            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
            if (name)
                this.unuse({ stack: stack, name: name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });
            middlewares.sort(function (a, b) { return a.level - b.level; });
            return this;
        };
        Dexie.prototype.unuse = function (_a) {
            var stack = _a.stack, name = _a.name, create = _a.create;
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
                    return create ? mw.create !== create :
                        name ? mw.name !== name :
                            false;
                });
            }
            return this;
        };
        Dexie.prototype.open = function () {
            return dexieOpen(this);
        };
        Dexie.prototype._close = function () {
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
                connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                }
                catch (e) { }
                this._novip.idbdb = null;
            }
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
        };
        Dexie.prototype.close = function () {
            this._close();
            var state = this._state;
            this._options.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
            if (state.isBeingOpened)
                state.cancelOpen(state.dbOpenError);
        };
        Dexie.prototype.delete = function () {
            var _this = this;
            var hasArguments = arguments.length > 0;
            var state = this._state;
            return new DexiePromise(function (resolve, reject) {
                var doDelete = function () {
                    _this.close();
                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                    req.onsuccess = wrap(function () {
                        _onDatabaseDeleted(_this._deps, _this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = _this._fireOnBlocked;
                };
                if (hasArguments)
                    throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                }
                else {
                    doDelete();
                }
            });
        };
        Dexie.prototype.backendDB = function () {
            return this.idbdb;
        };
        Dexie.prototype.isOpen = function () {
            return this.idbdb !== null;
        };
        Dexie.prototype.hasBeenClosed = function () {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
        };
        Dexie.prototype.hasFailed = function () {
            return this._state.dbOpenError !== null;
        };
        Dexie.prototype.dynamicallyOpened = function () {
            return this._state.autoSchema;
        };
        Object.defineProperty(Dexie.prototype, "tables", {
            get: function () {
                var _this = this;
                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });
            },
            enumerable: false,
            configurable: true
        });
        Dexie.prototype.transaction = function () {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            var idbMode, storeNames;
            try {
                storeNames = tables.map(function (table) {
                    var storeName = table instanceof _this.Table ? table.name : table;
                    if (typeof storeName !== 'string')
                        throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY)
                    idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE)
                    idbMode = READWRITE;
                else
                    throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        }
                        else
                            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function (storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Table " + storeName +
                                        " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            }
            catch (e) {
                return parentTransaction ?
                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :
                    rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return (parentTransaction ?
                parentTransaction._promise(idbMode, enterTransaction, "lock") :
                PSD.trans ?
                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :
                    this._whenReady(enterTransaction));
        };
        Dexie.prototype.table = function (tableName) {
            if (!hasOwn(this._allTables, tableName)) {
                throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
            }
            return this._allTables[tableName];
        };
        return Dexie;
    }());

    var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
        ? Symbol.observable
        : "@@observable";
    var Observable =  (function () {
        function Observable(subscribe) {
            this._subscribe = subscribe;
        }
        Observable.prototype.subscribe = function (x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error: error, complete: complete } : x);
        };
        Observable.prototype[symbolObservable] = function () {
            return this;
        };
        return Observable;
    }());

    function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function (part) {
            var rangeSet = target[part] || (target[part] = new RangeSet());
            mergeRanges(rangeSet, newSet[part]);
        });
        return target;
    }

    function liveQuery(querier) {
        return new Observable(function (observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(subscr) {
                if (scopeFuncIsAsync) {
                    incrementExpectedAwaits();
                }
                var exec = function () { return newScope(querier, { subscr: subscr, trans: null }); };
                var rv = PSD.trans
                    ?
                        usePSD(PSD.transless, exec)
                    : exec();
                if (scopeFuncIsAsync) {
                    rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
                }
                return rv;
            }
            var closed = false;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
                get closed() {
                    return closed;
                },
                unsubscribe: function () {
                    closed = true;
                    globalEvents.storagemutated.unsubscribe(mutationListener);
                },
            };
            observer.start && observer.start(subscription);
            var querying = false, startedListening = false;
            function shouldNotify() {
                return keys(currentObs).some(function (key) {
                    return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);
                });
            }
            var mutationListener = function (parts) {
                extendObservabilitySet(accumMuts, parts);
                if (shouldNotify()) {
                    doQuery();
                }
            };
            var doQuery = function () {
                if (querying || closed)
                    return;
                accumMuts = {};
                var subscr = {};
                var ret = execute(subscr);
                if (!startedListening) {
                    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                    startedListening = true;
                }
                querying = true;
                Promise.resolve(ret).then(function (result) {
                    querying = false;
                    if (closed)
                        return;
                    if (shouldNotify()) {
                        doQuery();
                    }
                    else {
                        accumMuts = {};
                        currentObs = subscr;
                        observer.next && observer.next(result);
                    }
                }, function (err) {
                    querying = false;
                    observer.error && observer.error(err);
                    subscription.unsubscribe();
                });
            };
            doQuery();
            return subscription;
        });
    }

    var domDeps;
    try {
        domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
    }
    catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
    }

    var Dexie = Dexie$1;
    props(Dexie, __assign(__assign({}, fullNameExceptions), {
        delete: function (databaseName) {
            var db = new Dexie(databaseName, { addons: [] });
            return db.delete();
        },
        exists: function (name) {
            return new Dexie(name, { addons: [] }).open().then(function (db) {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', function () { return false; });
        },
        getDatabaseNames: function (cb) {
            try {
                return getDatabaseNames(Dexie.dependencies).then(cb);
            }
            catch (_a) {
                return rejection(new exceptions.MissingAPI());
            }
        },
        defineClass: function () {
            function Class(content) {
                extend(this, content);
            }
            return Class;
        }, ignoreTransaction: function (scopeFunc) {
            return PSD.trans ?
                usePSD(PSD.transless, scopeFunc) :
                scopeFunc();
        }, vip: vip, async: function (generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function')
                        return DexiePromise.resolve(rv);
                    return rv;
                }
                catch (e) {
                    return rejection(e);
                }
            };
        }, spawn: function (generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: function () { return PSD.trans || null; }
        }, waitFor: function (promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                Dexie.ignoreTransaction(promiseOrFunction) :
                promiseOrFunction)
                .timeout(optionalTimeout || 60000);
            return PSD.trans ?
                PSD.trans.waitFor(promise) :
                promise;
        },
        Promise: DexiePromise,
        debug: {
            get: function () { return debug; },
            set: function (value) {
                setDebug(value, value === 'dexie' ? function () { return true; } : dexieStackFrameFilter);
            }
        },
        derive: derive, extend: extend, props: props, override: override,
        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,
        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: domDeps,
        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')
            .map(function (n) { return parseInt(n); })
            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {
            if (!propagatingLocally) {
                var event_1;
                if (isIEOrEdge) {
                    event_1 = document.createEvent('CustomEvent');
                    event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
                }
                else {
                    event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                        detail: updatedParts
                    });
                }
                propagatingLocally = true;
                dispatchEvent(event_1);
                propagatingLocally = false;
            }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {
            var detail = _a.detail;
            if (!propagatingLocally) {
                propagateLocally(detail);
            }
        });
    }
    function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
        }
        finally {
            propagatingLocally = wasMe;
        }
    }
    var propagatingLocally = false;

    if (typeof BroadcastChannel !== 'undefined') {
        var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
        if (typeof bc_1.unref === 'function') {
            bc_1.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
            if (!propagatingLocally) {
                bc_1.postMessage(changedParts);
            }
        });
        bc_1.onmessage = function (ev) {
            if (ev.data)
                propagateLocally(ev.data);
        };
    }
    else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
            try {
                if (!propagatingLocally) {
                    if (typeof localStorage !== 'undefined') {
                        localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
                            trig: Math.random(),
                            changedParts: changedParts,
                        }));
                    }
                    if (typeof self['clients'] === 'object') {
                        __spreadArray([], self['clients'].matchAll({ includeUncontrolled: true }), true).forEach(function (client) {
                            return client.postMessage({
                                type: STORAGE_MUTATED_DOM_EVENT_NAME,
                                changedParts: changedParts,
                            });
                        });
                    }
                }
            }
            catch (_a) { }
        });
        if (typeof addEventListener !== 'undefined') {
            addEventListener('storage', function (ev) {
                if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
                    var data = JSON.parse(ev.newValue);
                    if (data)
                        propagateLocally(data.changedParts);
                }
            });
        }
        var swContainer = self.document && navigator.serviceWorker;
        if (swContainer) {
            swContainer.addEventListener('message', propagateMessageLocally);
        }
    }
    function propagateMessageLocally(_a) {
        var data = _a.data;
        if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
            propagateLocally(data.changedParts);
        }
    }

    DexiePromise.rejectionMapper = mapError;
    setDebug(debug, dexieStackFrameFilter);

    var namedExports = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery,
        'default': Dexie$1,
        RangeSet: RangeSet,
        mergeRanges: mergeRanges,
        rangesOverlap: rangesOverlap
    });

    __assign(Dexie$1, namedExports, { default: Dexie$1 });

    return Dexie$1;

}));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"timers":9}],6:[function(require,module,exports){
(function (process,setImmediate){(function (){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {
  var hasOwnProperty= Object.hasOwnProperty;
  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;
  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';
  var symbolsSupported= typeof Symbol==='function';
  var reflectSupported= typeof Reflect === 'object';
  var setImmediateSupported= typeof setImmediate === 'function';
  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;
  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){
    var arr= Object.getOwnPropertyNames(obj);
    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
    return arr;
  }) : Object.keys;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);

      if(conf.maxListeners!==undefined){
          this._maxListeners= conf.maxListeners;
      }

      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this._newListener = conf.newListener);
      conf.removeListener && (this._removeListener = conf.removeListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. ' + count + ' listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: ' + eventName + '.';
    }

    if(typeof process !== 'undefined' && process.emitWarning){
      var e = new Error(errorMsg);
      e.name = 'MaxListenersExceededWarning';
      e.emitter = this;
      e.count = count;
      process.emitWarning(e);
    } else {
      console.error(errorMsg);

      if (console.trace){
        console.trace();
      }
    }
  }

  var toArray = function (a, b, c) {
    var n = arguments.length;
    switch (n) {
      case 0:
        return [];
      case 1:
        return [a];
      case 2:
        return [a, b];
      case 3:
        return [a, b, c];
      default:
        var arr = new Array(n);
        while (n--) {
          arr[n] = arguments[n];
        }
        return arr;
    }
  };

  function toObject(keys, values) {
    var obj = {};
    var key;
    var len = keys.length;
    var valuesCount = values ? values.length : 0;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = i < valuesCount ? values[i] : undefined;
    }
    return obj;
  }

  function TargetObserver(emitter, target, options) {
    this._emitter = emitter;
    this._target = target;
    this._listeners = {};
    this._listenersCount = 0;

    var on, off;

    if (options.on || options.off) {
      on = options.on;
      off = options.off;
    }

    if (target.addEventListener) {
      on = target.addEventListener;
      off = target.removeEventListener;
    } else if (target.addListener) {
      on = target.addListener;
      off = target.removeListener;
    } else if (target.on) {
      on = target.on;
      off = target.off;
    }

    if (!on && !off) {
      throw Error('target does not implement any known event API');
    }

    if (typeof on !== 'function') {
      throw TypeError('on method must be a function');
    }

    if (typeof off !== 'function') {
      throw TypeError('off method must be a function');
    }

    this._on = on;
    this._off = off;

    var _observers= emitter._observers;
    if(_observers){
      _observers.push(this);
    }else{
      emitter._observers= [this];
    }
  }

  Object.assign(TargetObserver.prototype, {
    subscribe: function(event, localEvent, reducer){
      var observer= this;
      var target= this._target;
      var emitter= this._emitter;
      var listeners= this._listeners;
      var handler= function(){
        var args= toArray.apply(null, arguments);
        var eventObj= {
          data: args,
          name: localEvent,
          original: event
        };
        if(reducer){
          var result= reducer.call(target, eventObj);
          if(result!==false){
            emitter.emit.apply(emitter, [eventObj.name].concat(args))
          }
          return;
        }
        emitter.emit.apply(emitter, [localEvent].concat(args));
      };


      if(listeners[event]){
        throw Error('Event \'' + event + '\' is already listening');
      }

      this._listenersCount++;

      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){

        this._onNewListener = function (_event) {
          if (_event === localEvent && listeners[event] === null) {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        };

        emitter.on('newListener', this._onNewListener);

        this._onRemoveListener= function(_event){
          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){
            listeners[event]= null;
            observer._off.call(target, event, handler);
          }
        };

        listeners[event]= null;

        emitter.on('removeListener', this._onRemoveListener);
      }else{
        listeners[event]= handler;
        observer._on.call(target, event, handler);
      }
    },

    unsubscribe: function(event){
      var observer= this;
      var listeners= this._listeners;
      var emitter= this._emitter;
      var handler;
      var events;
      var off= this._off;
      var target= this._target;
      var i;

      if(event && typeof event!=='string'){
        throw TypeError('event must be a string');
      }

      function clearRefs(){
        if(observer._onNewListener){
          emitter.off('newListener', observer._onNewListener);
          emitter.off('removeListener', observer._onRemoveListener);
          observer._onNewListener= null;
          observer._onRemoveListener= null;
        }
        var index= findTargetIndex.call(emitter, observer);
        emitter._observers.splice(index, 1);
      }

      if(event){
        handler= listeners[event];
        if(!handler) return;
        off.call(target, event, handler);
        delete listeners[event];
        if(!--this._listenersCount){
          clearRefs();
        }
      }else{
        events= ownKeys(listeners);
        i= events.length;
        while(i-->0){
          event= events[i];
          off.call(target, event, listeners[event]);
        }
        this._listeners= {};
        this._listenersCount= 0;
        clearRefs();
      }
    }
  });

  function resolveOptions(options, schema, reducers, allowUnknown) {
    var computedOptions = Object.assign({}, schema);

    if (!options) return computedOptions;

    if (typeof options !== 'object') {
      throw TypeError('options must be an object')
    }

    var keys = Object.keys(options);
    var length = keys.length;
    var option, value;
    var reducer;

    function reject(reason) {
      throw Error('Invalid "' + option + '" option value' + (reason ? '. Reason: ' + reason : ''))
    }

    for (var i = 0; i < length; i++) {
      option = keys[i];
      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
        throw Error('Unknown "' + option + '" option');
      }
      value = options[option];
      if (value !== undefined) {
        reducer = reducers[option];
        computedOptions[option] = reducer ? reducer(value, reject) : value;
      }
    }
    return computedOptions;
  }

  function constructorReducer(value, reject) {
    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {
      reject('value must be a constructor');
    }
    return value;
  }

  function makeTypeReducer(types) {
    var message= 'value must be type of ' + types.join('|');
    var len= types.length;
    var firstType= types[0];
    var secondType= types[1];

    if (len === 1) {
      return function (v, reject) {
        if (typeof v === firstType) {
          return v;
        }
        reject(message);
      }
    }

    if (len === 2) {
      return function (v, reject) {
        var kind= typeof v;
        if (kind === firstType || kind === secondType) return v;
        reject(message);
      }
    }

    return function (v, reject) {
      var kind = typeof v;
      var i = len;
      while (i-- > 0) {
        if (kind === types[i]) return v;
      }
      reject(message);
    }
  }

  var functionReducer= makeTypeReducer(['function']);

  var objectFunctionReducer= makeTypeReducer(['object', 'function']);

  function makeCancelablePromise(Promise, executor, options) {
    var isCancelable;
    var callbacks;
    var timer= 0;
    var subscriptionClosed;

    var promise = new Promise(function (resolve, reject, onCancel) {
      options= resolveOptions(options, {
        timeout: 0,
        overload: false
      }, {
        timeout: function(value, reject){
          value*= 1;
          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
            reject('timeout must be a positive number');
          }
          return value;
        }
      });

      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';

      function cleanup() {
        if (callbacks) {
          callbacks = null;
        }
        if (timer) {
          clearTimeout(timer);
          timer = 0;
        }
      }

      var _resolve= function(value){
        cleanup();
        resolve(value);
      };

      var _reject= function(err){
        cleanup();
        reject(err);
      };

      if (isCancelable) {
        executor(_resolve, _reject, onCancel);
      } else {
        callbacks = [function(reason){
          _reject(reason || Error('canceled'));
        }];
        executor(_resolve, _reject, function (cb) {
          if (subscriptionClosed) {
            throw Error('Unable to subscribe on cancel event asynchronously')
          }
          if (typeof cb !== 'function') {
            throw TypeError('onCancel callback must be a function');
          }
          callbacks.push(cb);
        });
        subscriptionClosed= true;
      }

      if (options.timeout > 0) {
        timer= setTimeout(function(){
          var reason= Error('timeout');
          reason.code = 'ETIMEDOUT'
          timer= 0;
          promise.cancel(reason);
          reject(reason);
        }, options.timeout);
      }
    });

    if (!isCancelable) {
      promise.cancel = function (reason) {
        if (!callbacks) {
          return;
        }
        var length = callbacks.length;
        for (var i = 1; i < length; i++) {
          callbacks[i](reason);
        }
        // internal callback to reject the promise
        callbacks[0](reason);
        callbacks = null;
      };
    }

    return promise;
  }

  function findTargetIndex(observer) {
    var observers = this._observers;
    if(!observers){
      return -1;
    }
    var len = observers.length;
    for (var i = 0; i < len; i++) {
      if (observers[i]._target === observer) return i;
    }
    return -1;
  }

  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i, typeLength) {
    if (!tree) {
      return null;
    }

    if (i === 0) {
      var kind = typeof type;
      if (kind === 'string') {
        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
        if ((n = type.indexOf(delimiter)) !== -1) {
          ns = new Array(5);
          do {
            ns[l++] = type.slice(j, n);
            j = n + dl;
          } while ((n = type.indexOf(delimiter, j)) !== -1);

          ns[l++] = type.slice(j);
          type = ns;
          typeLength = l;
        } else {
          type = [type];
          typeLength = 1;
        }
      } else if (kind === 'object') {
        typeLength = type.length;
      } else {
        type = [type];
        typeLength = 1;
      }
    }

    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],
        nextType = type[i + 1], branches, _listeners;

    if (i === typeLength) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //

      if(tree._listeners) {
        if (typeof tree._listeners === 'function') {
          handlers && handlers.push(tree._listeners);
          listeners = [tree];
        } else {
          handlers && handlers.push.apply(handlers, tree._listeners);
          listeners = [tree];
        }
      }
    } else {

      if (currentType === '*') {
        //
        // If the event emitted is '*' at this part
        // or there is a concrete match at this patch
        //
        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (currentType === '**') {
        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));
        if (endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
        }

        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            if (branch === '*' || branch === '**') {
              if (tree[branch]._listeners && !endReached) {
                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            } else if (branch === nextType) {
              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
            } else {
              // No match on this one, shift into the tree but not in the type array.
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            }
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (tree[currentType]) {
        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
      }
    }

      xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i + 1, typeLength);
    }

    xxTree = tree['**'];
    if (xxTree) {
      if (i < typeLength) {
        if (xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
        }

        // Build arrays of matching next branches and others.
        branches= ownKeys(xxTree);
        n= branches.length;
        while(n-->0){
          branch= branches[n];
          if (branch !== '_listeners') {
            if (branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
            } else if (branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);
            }
          }
        }
      } else if (xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
      } else if (xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener, prepend) {
    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;

    if(typeof type==='string') {
      if ((i = type.indexOf(delimiter)) !== -1) {
        ns = new Array(5);
        do {
          ns[len++] = type.slice(j, i);
          j = i + dl;
        } while ((i = type.indexOf(delimiter, j)) !== -1);

        ns[len++] = type.slice(j);
      }else{
        ns= [type];
        len= 1;
      }
    }else{
      ns= type;
      len= type.length;
    }

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    if (len > 1) {
      for (i = 0; i + 1 < len; i++) {
        if (ns[i] === '**' && ns[i + 1] === '**') {
          return;
        }
      }
    }



    var tree = this.listenerTree, name;

    for (i = 0; i < len; i++) {
      name = ns[i];

      tree = tree[name] || (tree[name] = {});

      if (i === len - 1) {
        if (!tree._listeners) {
          tree._listeners = listener;
        } else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          if (prepend) {
            tree._listeners.unshift(listener);
          } else {
            tree._listeners.push(listener);
          }

          if (
              !tree._listeners.warned &&
              this._maxListeners > 0 &&
              tree._listeners.length > this._maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
    }

    return true;
  }

  function collectTreeEvents(tree, events, root, asArray){
     var branches= ownKeys(tree);
     var i= branches.length;
     var branch, branchName, path;
     var hasListeners= tree['_listeners'];
     var isArrayPath;

     while(i-->0){
         branchName= branches[i];

         branch= tree[branchName];

         if(branchName==='_listeners'){
             path= root;
         }else {
             path = root ? root.concat(branchName) : [branchName];
         }

         isArrayPath= asArray || typeof branchName==='symbol';

         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));

         if(typeof branch==='object'){
             collectTreeEvents.call(this, branch, events, path, isArrayPath);
         }
     }

     return events;
  }

  function recursivelyGarbageCollect(root) {
    var keys = ownKeys(root);
    var i= keys.length;
    var obj, key, flag;
    while(i-->0){
      key = keys[i];
      obj = root[key];

      if(obj){
          flag= true;
          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){
             delete root[key];
          }
      }
    }

    return flag;
  }

  function Listener(emitter, event, listener){
    this.emitter= emitter;
    this.event= event;
    this.listener= listener;
  }

  Listener.prototype.off= function(){
    this.emitter.off(this.event, this.listener);
    return this;
  };

  function setupListener(event, listener, options){
      if (options === true) {
        promisify = true;
      } else if (options === false) {
        async = true;
      } else {
        if (!options || typeof options !== 'object') {
          throw TypeError('options should be an object or true');
        }
        var async = options.async;
        var promisify = options.promisify;
        var nextTick = options.nextTick;
        var objectify = options.objectify;
      }

      if (async || nextTick || promisify) {
        var _listener = listener;
        var _origin = listener._origin || listener;

        if (nextTick && !nextTickSupported) {
          throw Error('process.nextTick is not supported');
        }

        if (promisify === undefined) {
          promisify = listener.constructor.name === 'AsyncFunction';
        }

        listener = function () {
          var args = arguments;
          var context = this;
          var event = this.event;

          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {
            _setImmediate(resolve);
          }).then(function () {
            context.event = event;
            return _listener.apply(context, args)
          })) : (nextTick ? process.nextTick : _setImmediate)(function () {
            context.event = event;
            _listener.apply(context, args)
          });
        };

        listener._async = true;
        listener._origin = _origin;
      }

    return [listener, objectify? new Listener(this, event, listener): this];
  }

  function EventEmitter(conf) {
    this._events = {};
    this._newListener = false;
    this._removeListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }

  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  EventEmitter.prototype.listenTo= function(target, events, options){
    if(typeof target!=='object'){
      throw TypeError('target musts be an object');
    }

    var emitter= this;

    options = resolveOptions(options, {
      on: undefined,
      off: undefined,
      reducers: undefined
    }, {
      on: functionReducer,
      off: functionReducer,
      reducers: objectFunctionReducer
    });

    function listen(events){
      if(typeof events!=='object'){
        throw TypeError('events must be an object');
      }

      var reducers= options.reducers;
      var index= findTargetIndex.call(emitter, target);
      var observer;

      if(index===-1){
        observer= new TargetObserver(emitter, target, options);
      }else{
        observer= emitter._observers[index];
      }

      var keys= ownKeys(events);
      var len= keys.length;
      var event;
      var isSingleReducer= typeof reducers==='function';

      for(var i=0; i<len; i++){
        event= keys[i];
        observer.subscribe(
            event,
            events[event] || event,
            isSingleReducer ? reducers : reducers && reducers[event]
        );
      }
    }

    isArray(events)?
        listen(toObject(events)) :
        (typeof events==='string'? listen(toObject(events.split(/\s+/))): listen(events));

    return this;
  };

  EventEmitter.prototype.stopListeningTo = function (target, event) {
    var observers = this._observers;

    if(!observers){
      return false;
    }

    var i = observers.length;
    var observer;
    var matched= false;

    if(target && typeof target!=='object'){
      throw TypeError('target should be an object');
    }

    while (i-- > 0) {
      observer = observers[i];
      if (!target || observer._target === target) {
        observer.unsubscribe(event);
        matched= true;
      }
    }

    return matched;
  };

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.getMaxListeners = function() {
    return this._maxListeners;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn, options) {
    return this._once(event, fn, false, options);
  };

  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
    return this._once(event, fn, true, options);
  };

  EventEmitter.prototype._once = function(event, fn, prepend, options) {
    return this._many(event, 1, fn, prepend, options);
  };

  EventEmitter.prototype.many = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, false, options);
  };

  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, true, options);
  };

  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      return fn.apply(this, arguments);
    }

    listener._origin = fn;

    return this._on(event, listener, prepend, options);
  };

  EventEmitter.prototype.emit = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], ns, wildcard= this.wildcard;
    var args,l,i,j, containsSymbol;

    if (type === 'newListener' && !this._newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var al = arguments.length;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, arguments);
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;
    var args,l,i,j;

    if (type === 'newListener' && !this._newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var promises= [];

    var al = arguments.length;
    var handler;

    if (this._all) {
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, arguments));
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      handler = handler.slice();
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener, options) {
    return this._on(type, listener, false, options);
  };

  EventEmitter.prototype.prependListener = function(type, listener, options) {
    return this._on(type, listener, true, options);
  };

  EventEmitter.prototype.onAny = function(fn) {
    return this._onAny(fn, false);
  };

  EventEmitter.prototype.prependAny = function(fn) {
    return this._onAny(fn, true);
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype._onAny = function(fn, prepend){
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    if(prepend){
      this._all.unshift(fn);
    }else{
      this._all.push(fn);
    }

    return this;
  };

  EventEmitter.prototype._on = function(type, listener, prepend, options) {
    if (typeof type === 'function') {
      this._onAny(type, listener);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    var returnValue= this, temp;

    if (options !== undefined) {
      temp = setupListener.call(this, type, listener, options);
      listener = temp[0];
      returnValue = temp[1];
    }

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    if (this._newListener) {
      this.emit('newListener', type, listener);
    }

    if (this.wildcard) {
      growListenerTree.call(this, type, listener, prepend);
      return returnValue;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just add
      if(prepend){
        this._events[type].unshift(listener);
      }else{
        this._events[type].push(listener);
      }

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._maxListeners > 0 &&
        this._events[type].length > this._maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return returnValue;
  };

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
      if(!leafs) return this;
    } else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);
      }
    }

    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          if (this._removeListener)
            this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      if (this._removeListener) {
        for(i = 0, l = fns.length; i < l; i++)
          this.emit("removeListenerAny", fns[i]);
      }
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function (type) {
    if (type === undefined) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
      if (!leafs) return this;
      for (i = 0; i < leafs.length; i++) {
        leaf = leafs[i];
        leaf._listeners = null;
      }
      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
    } else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function (type) {
    var _events = this._events;
    var keys, listeners, allListeners;
    var i;
    var listenerTree;

    if (type === undefined) {
      if (this.wildcard) {
        throw Error('event name required for wildcard emitter');
      }

      if (!_events) {
        return [];
      }

      keys = ownKeys(_events);
      i = keys.length;
      allListeners = [];
      while (i-- > 0) {
        listeners = _events[keys[i]];
        if (typeof listeners === 'function') {
          allListeners.push(listeners);
        } else {
          allListeners.push.apply(allListeners, listeners);
        }
      }
      return allListeners;
    } else {
      if (this.wildcard) {
        listenerTree= this.listenerTree;
        if(!listenerTree) return [];
        var handlers = [];
        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
        searchListenerTree.call(this, handlers, ns, listenerTree, 0);
        return handlers;
      }

      if (!_events) {
        return [];
      }

      listeners = _events[type];

      if (!listeners) {
        return [];
      }
      return typeof listeners === 'function' ? [listeners] : listeners;
    }
  };

  EventEmitter.prototype.eventNames = function(nsAsArray){
    var _events= this._events;
    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.hasListeners = function (type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers.length > 0;
    }

    var _events = this._events;
    var _all = this._all;

    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  EventEmitter.prototype.waitFor = function (event, options) {
    var self = this;
    var type = typeof options;
    if (type === 'number') {
      options = {timeout: options};
    } else if (type === 'function') {
      options = {filter: options};
    }

    options= resolveOptions(options, {
      timeout: 0,
      filter: undefined,
      handleError: false,
      Promise: Promise,
      overload: false
    }, {
      filter: functionReducer,
      Promise: constructorReducer
    });

    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {
      function listener() {
        var filter= options.filter;
        if (filter && !filter.apply(self, arguments)) {
          return;
        }
        self.off(event, listener);
        if (options.handleError) {
          var err = arguments[0];
          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
        } else {
          resolve(toArray.apply(null, arguments));
        }
      }

      onCancel(function(){
        self.off(event, listener);
      });

      self._on(event, listener, false);
    }, {
      timeout: options.timeout,
      overload: options.overload
    })
  };

  function once(emitter, name, options) {
    options= resolveOptions(options, {
      Promise: Promise,
      timeout: 0,
      overload: false
    }, {
      Promise: constructorReducer
    });

    var _Promise= options.Promise;

    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){
      var handler;
      if (typeof emitter.addEventListener === 'function') {
        handler=  function () {
          resolve(toArray.apply(null, arguments));
        };

        onCancel(function(){
          emitter.removeEventListener(name, handler);
        });

        emitter.addEventListener(
            name,
            handler,
            {once: true}
        );
        return;
      }

      var eventListener = function(){
        errorListener && emitter.removeListener('error', errorListener);
        resolve(toArray.apply(null, arguments));
      };

      var errorListener;

      if (name !== 'error') {
        errorListener = function (err){
          emitter.removeListener(name, eventListener);
          reject(err);
        };

        emitter.once('error', errorListener);
      }

      onCancel(function(){
        errorListener && emitter.removeListener('error', errorListener);
        emitter.removeListener(name, eventListener);
      });

      emitter.once(name, eventListener);
    }, {
      timeout: options.timeout,
      overload: options.overload
    });
  }

  var prototype= EventEmitter.prototype;

  Object.defineProperties(EventEmitter, {
    defaultMaxListeners: {
      get: function () {
        return prototype._maxListeners;
      },
      set: function (n) {
        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
          throw TypeError('n must be a non-negative number')
        }
        prototype._maxListeners = n;
      },
      enumerable: true
    },
    once: {
      value: once,
      writable: true,
      configurable: true
    }
  });

  Object.defineProperties(prototype, {
      _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
      },
      _observers: {value: null, writable: true, configurable: true}
  });

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = EventEmitter;
  }
  else {
    // global for any kind of environment.
    var _global= new Function('','return this')();
    _global.EventEmitter2 = EventEmitter;
  }
}();

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":8,"timers":9}],7:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":8,"timers":9}],10:[function(require,module,exports){
'use strict';

/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a '.' (it should not be a partial label).
 *
 * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
 * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
 * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
 */
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return (hostname.length === vhost.length ||
            hostname[hostname.length - vhost.length - 1] === '.');
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */
function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last '.'
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
/**
 * Detects the domain based on rules and upon and a host string
 */
function getDomain$1(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (let i = 0; i < validHosts.length; i += 1) {
            const vhost = validHosts[i];
            if ( /*@__INLINE__*/shareSameDomainSuffix(hostname, vhost) === true) {
                return vhost;
            }
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}

/**
 * Return the part of domain without suffix.
 *
 * Example: for domain 'foo.com', the result would be 'foo'.
 */
function getDomainWithoutSuffix$1(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
}

/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (urlIsValidHostname === false) {
        // Special handling of data URLs
        if (url.startsWith('data:') === true) {
            return null;
        }
        // Trim leading spaces
        while (start < url.length && url.charCodeAt(start) <= 32) {
            start += 1;
        }
        // Trim trailing spaces
        while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* '/' */ &&
            url.charCodeAt(start + 1) === 47 /* '/' */) {
            start += 2;
        }
        else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */ &&
                    c4 === 115 /* 's' */) ;
                else if (protocolSize === 4 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */) ;
                else if (protocolSize === 3 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */ &&
                    c2 === 115 /* 's' */) ;
                else if (protocolSize === 2 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */) ;
                else {
                    // Check that scheme is valid
                    for (let i = start; i < indexOfProtocol; i += 1) {
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (((lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]
                            (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]
                            lowerCaseCode === 46 || // '.'
                            lowerCaseCode === 45 || // '-'
                            lowerCaseCode === 43) === false // '+'
                        ) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more '/' after ':/'
                start = indexOfProtocol + 2;
                while (url.charCodeAt(start) === 47 /* '/' */) {
                    start += 1;
                }
            }
        }
        // Detect first occurrence of '/', '?' or '#'. We also keep track of the
        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for (let i = start; i < end; i += 1) {
            const code = url.charCodeAt(i);
            if (code === 35 || // '#'
                code === 47 || // '/'
                code === 63 // '?'
            ) {
                end = i;
                break;
            }
            else if (code === 64) {
                // '@'
                indexOfIdentifier = i;
            }
            else if (code === 93) {
                // ']'
                indexOfClosingBracket = i;
            }
            else if (code === 58) {
                // ':'
                indexOfPort = i;
            }
            else if (code >= 65 && code <= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: '@'
        if (indexOfIdentifier !== -1 &&
            indexOfIdentifier > start &&
            indexOfIdentifier < end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* '[' */) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        }
        else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
            // Detect port: ':'
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
}

/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */
function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length < 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length > 15) {
        return false;
    }
    let numberOfDots = 0;
    for (let i = 0; i < hostname.length; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            numberOfDots += 1;
        }
        else if (code < 48 /* '0' */ || code > 57 /* '9' */) {
            return false;
        }
    }
    return (numberOfDots === 3 &&
        hostname.charCodeAt(0) !== 46 /* '.' */ &&
        hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */);
}
/**
 * Similar to isProbablyIpv4.
 */
function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
        return false;
    }
    let start = hostname[0] === '[' ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === ']') {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called "IPv4 mapped IPv6 addresses" but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start > 39) {
        return false;
    }
    let hasColon = false;
    for (; start < end; start += 1) {
        const code = hostname.charCodeAt(start);
        if (code === 58 /* ':' */) {
            hasColon = true;
        }
        else if (((code >= 48 && code <= 57) || // 0-9
            (code >= 97 && code <= 102) || // a-f
            (code >= 65 && code <= 90)) === // A-F
            false) {
            return false;
        }
    }
    return hasColon;
}
/**
 * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).
 * This *will not* work on any string. We need `hostname` to be a valid
 * hostname.
 */
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}

/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */
function isValidAscii(code) {
    return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);
}
/**
 * Check if a hostname string is valid. It's usually a preliminary check before
 * trying to use getDomain or anything else.
 *
 * Beware: it does not check if the TLD exists.
 */
function isValidHostname (hostname) {
    if (hostname.length > 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if ( /*@__INLINE__*/isValidAscii(hostname.charCodeAt(0)) === false) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for (let i = 0; i < len; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            if (
            // Check that previous label is < 63 bytes long (64 = 63 + '.')
            i - lastDotIndex > 64 ||
                // Check that previous character was not already a '.'
                lastCharCode === 46 ||
                // Check that the previous label does not end with a '-' (dash)
                lastCharCode === 45 ||
                // Check that the previous label does not end with a '_' (underscore)
                lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        }
        else if (( /*@__INLINE__*/isValidAscii(code) || code === 45 || code === 95) ===
            false) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 &&
        // Check that the last character is an allowed trailing label character.
        // Since we already checked that the char is a valid hostname character,
        // we only need to check that it's different from '-'.
        lastCharCode !== 45);
}

function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname,
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
}

/**
 * Returns the subdomain of a hostname string
 */
function getSubdomain$1(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return '';
    }
    return hostname.slice(0, -domain.length - 1);
}

/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null,
    };
}
function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (options.extractHostname === false) {
        result.hostname = url;
    }
    else if (options.mixedInputs === true) {
        result.hostname = extractHostname(url, isValidHostname(url));
    }
    else {
        result.hostname = extractHostname(url, false);
    }
    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {
        return result;
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp === true) {
        result.isIp = isIp(result.hostname);
        if (result.isIp === true) {
            return result;
        }
    }
    // Perform optional hostname validation. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain.
    if (options.validateHostname === true &&
        options.extractHostname === true &&
        isValidHostname(result.hostname) === false) {
        result.hostname = null;
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = getDomain$1(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = getSubdomain$1(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = getDomainWithoutSuffix$1(result.domain, result.publicSuffix);
    return result;
}

function fastPathLookup (hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (options.allowPrivateDomains === false && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* 'm' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 99 /* 'c' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        }
        else if (c3 === 103 /* 'g' */ &&
            c2 === 114 /* 'r' */ &&
            c1 === 111 /* 'o' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        }
        else if (c3 === 117 /* 'u' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 101 /* 'e' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        }
        else if (c3 === 118 /* 'v' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 103 /* 'g' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        }
        else if (c3 === 116 /* 't' */ &&
            c2 === 101 /* 'e' */ &&
            c1 === 110 /* 'n' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        }
        else if (c3 === 101 /* 'e' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
}

const exceptions = (function () {
    const _0 = { "$": 1, "succ": {} }, _1 = { "$": 0, "succ": { "city": _0 } };
    const exceptions = { "$": 0, "succ": { "ck": { "$": 0, "succ": { "www": _0 } }, "jp": { "$": 0, "succ": { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 } } } };
    return exceptions;
})();
const rules = (function () {
    const _2 = { "$": 1, "succ": {} }, _3 = { "$": 2, "succ": {} }, _4 = { "$": 1, "succ": { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 } }, _5 = { "$": 0, "succ": { "*": _3 } }, _6 = { "$": 1, "succ": { "blogspot": _3 } }, _7 = { "$": 1, "succ": { "gov": _2 } }, _8 = { "$": 0, "succ": { "*": _2 } }, _9 = { "$": 0, "succ": { "cloud": _3 } }, _10 = { "$": 1, "succ": { "co": _3 } }, _11 = { "$": 2, "succ": { "nodes": _3 } }, _12 = { "$": 0, "succ": { "s3": _3 } }, _13 = { "$": 0, "succ": { "direct": _3 } }, _14 = { "$": 2, "succ": { "id": _3 } }, _15 = { "$": 0, "succ": { "vfs": _3, "webview-assets": _3 } }, _16 = { "$": 0, "succ": { "cloud9": _15 } }, _17 = { "$": 0, "succ": { "dualstack": _12, "cloud9": _15 } }, _18 = { "$": 0, "succ": { "dualstack": _12, "s3": _3, "s3-website": _3, "cloud9": _15 } }, _19 = { "$": 0, "succ": { "apps": _3 } }, _20 = { "$": 0, "succ": { "paas": _3 } }, _21 = { "$": 0, "succ": { "app": _3 } }, _22 = { "$": 2, "succ": { "eu": _3 } }, _23 = { "$": 0, "succ": { "site": _3 } }, _24 = { "$": 0, "succ": { "pages": _3 } }, _25 = { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2 } }, _26 = { "$": 0, "succ": { "j": _3 } }, _27 = { "$": 0, "succ": { "jelastic": _3 } }, _28 = { "$": 0, "succ": { "user": _3 } }, _29 = { "$": 1, "succ": { "ybo": _3 } }, _30 = { "$": 0, "succ": { "cust": _3, "reservd": _3 } }, _31 = { "$": 0, "succ": { "cust": _3 } }, _32 = { "$": 1, "succ": { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 } }, _33 = { "$": 1, "succ": { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 } }, _34 = { "$": 1, "succ": { "gov": _2, "blogspot": _3 } }, _35 = { "$": 1, "succ": { "framer": _3 } }, _36 = { "$": 1, "succ": { "barsy": _3 } }, _37 = { "$": 0, "succ": { "forgot": _3 } }, _38 = { "$": 1, "succ": { "gs": _2 } }, _39 = { "$": 0, "succ": { "nes": _2 } }, _40 = { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2 } }, _41 = { "$": 1, "succ": { "cc": _2, "lib": _2 } };
    const rules = { "$": 0, "succ": { "ac": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 } }, "ad": { "$": 1, "succ": { "nom": _2 } }, "ae": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "aero": { "$": 1, "succ": { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 } }, "af": _4, "ag": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 } }, "ai": { "$": 1, "succ": { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 } }, "al": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 } }, "am": { "$": 1, "succ": { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 } }, "ao": { "$": 1, "succ": { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 } }, "aq": _2, "ar": { "$": 1, "succ": { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 } }, "arpa": { "$": 1, "succ": { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 } }, "as": _7, "asia": { "$": 1, "succ": { "cloudns": _3 } }, "at": { "$": 1, "succ": { "ac": { "$": 1, "succ": { "sth": _2 } }, "co": _6, "gv": _2, "or": _2, "funkfeuer": { "$": 0, "succ": { "wien": _3 } }, "futurecms": { "$": 0, "succ": { "*": _3, "ex": _5, "in": _5 } }, "futurehosting": _3, "futuremailing": _3, "ortsinfo": { "$": 0, "succ": { "ex": _5, "kunden": _5 } }, "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "au": { "$": 1, "succ": { "com": { "$": 1, "succ": { "blogspot": _3, "cloudlets": { "$": 0, "succ": { "mel": _3 } }, "myspreadshop": _3 } }, "net": _2, "org": _2, "edu": { "$": 1, "succ": { "act": _2, "catholic": _2, "nsw": { "$": 1, "succ": { "schools": _2 } }, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "gov": { "$": 1, "succ": { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "aw": { "$": 1, "succ": { "com": _2 } }, "ax": { "$": 1, "succ": { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 } }, "az": { "$": 1, "succ": { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 } }, "ba": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 } }, "bb": { "$": 1, "succ": { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 } }, "bd": _8, "be": { "$": 1, "succ": { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": { "$": 0, "succ": { "ezproxy": _3 } }, "123website": _3, "myspreadshop": _3, "transurl": _5 } }, "bf": _7, "bg": { "$": 1, "succ": { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 } }, "bh": _4, "bi": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 } }, "biz": { "$": 1, "succ": { "activetrail": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 } }, "bj": { "$": 1, "succ": { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 } }, "bm": _4, "bn": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 } }, "bo": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 } }, "br": { "$": 1, "succ": { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": { "$": 1, "succ": { "blogspot": _3, "virtualcloud": { "$": 0, "succ": { "scale": { "$": 0, "succ": { "users": _3 } } } }, "simplesite": _3 } }, "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": { "$": 1, "succ": { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 } }, "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": { "$": 1, "succ": { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 } }, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 } }, "bs": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 } }, "bt": _4, "bv": _2, "bw": { "$": 1, "succ": { "co": _2, "org": _2 } }, "by": { "$": 1, "succ": { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 } }, "bz": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 } }, "ca": { "$": 1, "succ": { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 } }, "cat": _2, "cc": { "$": 1, "succ": { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": { "$": 0, "succ": { "instances": _3 } } } }, "cd": _7, "cf": _6, "cg": _2, "ch": { "$": 1, "succ": { "square7": _3, "blogspot": _3, "flow": { "$": 0, "succ": { "ae": { "$": 0, "succ": { "alp1": _3 } }, "appengine": _3 } }, "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": { "$": 0, "succ": { "*": _3, "svc": _5 } }, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "ci": { "$": 1, "succ": { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 } }, "ck": _8, "cl": { "$": 1, "succ": { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "cm": { "$": 1, "succ": { "co": _2, "com": _2, "gov": _2, "net": _2 } }, "cn": { "$": 1, "succ": { "ac": _2, "com": { "$": 1, "succ": { "amazonaws": { "$": 0, "succ": { "compute": _5, "cn-north-1": _12, "eb": { "$": 0, "succ": { "cn-north-1": _3, "cn-northwest-1": _3 } }, "elb": _5 } } } }, "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--od0alg": _2, "": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "instantcloud": _3, "quickconnect": _13 } }, "co": { "$": 1, "succ": { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 } }, "com": { "$": 1, "succ": { "devcdnaccesso": _5, "adobeaemcloud": { "$": 2, "succ": { "dev": _5 } }, "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": { "$": 0, "succ": { "compute": _5, "compute-1": _5, "us-east-1": { "$": 2, "succ": { "dualstack": _12, "cloud9": _15 } }, "ap-northeast-1": _17, "ap-northeast-2": _18, "ap-south-1": _18, "ap-southeast-1": _17, "ap-southeast-2": _17, "ca-central-1": _18, "eu-central-1": _18, "eu-west-1": _17, "eu-west-2": _18, "eu-west-3": _18, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _17, "us-east-2": _18, "af-south-1": _16, "ap-east-1": _16, "ap-northeast-3": _16, "eu-north-1": _16, "eu-south-1": _16, "me-south-1": _16, "us-west-1": _16, "us-west-2": _16, "elb": _5 } }, "elasticbeanstalk": { "$": 2, "succ": { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 } }, "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "customer-oci": { "$": 0, "succ": { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 } }, "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": { "$": 0, "succ": { "demo": _3, "instance": _3 } }, "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": { "$": 0, "succ": { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 } }, "onfabrica": _3, "fbsbx": _19, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": { "$": 2, "succ": { "r": _5 } }, "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "clicketcloud": _3, "dopaas": _3, "hidora": _3, "hosted-by-previder": _20, "hosteur": { "$": 0, "succ": { "rag-cloud": _3, "rag-cloud-ch": _3 } }, "ik-server": { "$": 0, "succ": { "jcloud": _3, "jcloud-ver-jpc": _3 } }, "jelastic": { "$": 0, "succ": { "demo": _3 } }, "kilatiron": _3, "massivegrid": _20, "wafaicloud": { "$": 0, "succ": { "jed": _3, "lon": _3, "ryd": _3 } }, "joyent": { "$": 0, "succ": { "cns": _5 } }, "ktistory": _3, "lpusercontent": _3, "lmpm": _21, "linode": { "$": 0, "succ": { "members": _3, "nodebalancer": _5 } }, "linodeobjects": _5, "linodeusercontent": { "$": 0, "succ": { "ip": _3 } }, "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _22, "hostedpi": _3, "mythic-beasts": { "$": 0, "succ": { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 } }, "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": { "$": 0, "succ": { "static": _3 } }, "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": { "$": 0, "succ": { "xen": _3 } }, "pythonanywhere": _22, "qualifioapp": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _21, "onrender": _3, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": { "$": 0, "succ": { "builder": _5, "dev-builder": _5, "stg-builder": _5 } }, "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": { "$": 2, "succ": { "alpha": _3, "beta": _3 } }, "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": { "$": 0, "succ": { "api": _3 } }, "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "tb-hosting": _23, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": { "$": 0, "succ": { "pro": _3 } }, "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _24, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": { "$": 2, "succ": { "js": _3 } }, "wixsite": _3, "xnbay": { "$": 2, "succ": { "u2": _3, "u2-local": _3 } }, "yolasite": _3 } }, "coop": _2, "cr": { "$": 1, "succ": { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 } }, "cu": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 } }, "cv": { "$": 1, "succ": { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 } }, "cw": _25, "cx": { "$": 1, "succ": { "gov": _2, "ath": _3, "info": _3 } }, "cy": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": { "$": 1, "succ": { "blogspot": _3, "scaleforce": _26 } }, "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 } }, "cz": { "$": 1, "succ": { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": { "$": 0, "succ": { "cloud": _5, "custom": _3 } }, "muni": { "$": 0, "succ": { "cloud": { "$": 0, "succ": { "flt": _3, "usr": _3 } } } } } }, "de": { "$": 1, "succ": { "bplaced": _3, "square7": _3, "com": _3, "cosidns": { "$": 0, "succ": { "dyn": _3 } }, "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": { "$": 2, "succ": { "dyn": _3, "dyndns": _3 } }, "dyndns1": _3, "dyn-ip24": _3, "home-webserver": { "$": 2, "succ": { "dyn": _3 } }, "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "gnstigbestellen": _3, "xn--gnstigliefern-wob": _3, "gnstigliefern": _3, "hs-heilbronn": { "$": 0, "succ": { "it": _24 } }, "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": { "$": 0, "succ": { "customer": _3 } }, "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 } }, "dj": _2, "dk": { "$": 1, "succ": { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "dm": _4, "do": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 } }, "dz": { "$": 1, "succ": { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 } }, "ec": { "$": 1, "succ": { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 } }, "edu": { "$": 1, "succ": { "rit": { "$": 0, "succ": { "git-pages": _3 } } } }, "ee": { "$": 1, "succ": { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 } }, "eg": { "$": 1, "succ": { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 } }, "er": _8, "es": { "$": 1, "succ": { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 } }, "et": { "$": 1, "succ": { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 } }, "eu": { "$": 1, "succ": { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _27, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 } }, "fi": { "$": 1, "succ": { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "hkkinen": _3, "iki": _3, "cloudplatform": { "$": 0, "succ": { "fi": _3 } }, "datacenter": { "$": 0, "succ": { "demo": _3, "paas": _3 } }, "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 } }, "fj": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "fk": _8, "fm": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 } }, "fo": _2, "fr": { "$": 1, "succ": { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "aeroport": _2, "avocat": _2, "avoues": _2, "cci": _2, "chambagri": _2, "chirurgiens-dentistes": _2, "experts-comptables": _2, "geometre-expert": _2, "greta": _2, "huissier-justice": _2, "medecin": _2, "notaires": _2, "pharmacien": _2, "port": _2, "veterinaire": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "myspreadshop": _3, "ynh": _3 } }, "ga": _2, "gb": _2, "gd": { "$": 1, "succ": { "edu": _2, "gov": _2 } }, "ge": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 } }, "gf": _2, "gg": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": { "$": 2, "succ": { "daemon": _3 } } } }, "gh": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 } }, "gi": { "$": 1, "succ": { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 } }, "gl": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 } }, "gm": _2, "gn": { "$": 1, "succ": { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 } }, "gov": _2, "gp": { "$": 1, "succ": { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 } }, "gq": _2, "gr": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 } }, "gs": _2, "gt": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 } }, "gu": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 } }, "gw": _2, "gy": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 } }, "hk": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "": _2, "xn--wcvs22d": _2, "": _2, "xn--lcvr32d": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--gmqw5a": _2, "": _2, "xn--ciqpn": _2, "": _2, "xn--gmq050i": _2, "": _2, "xn--zf0avx": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--mk0axi": _2, "": _2, "xn--od0alg": _2, "": _2, "xn--od0aq3b": _2, "": _2, "xn--tn0ag": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--uc0ay4a": _2, "": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 } }, "hm": _2, "hn": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 } }, "hr": { "$": 1, "succ": { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 } }, "ht": { "$": 1, "succ": { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 } }, "hu": { "$": 1, "succ": { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 } }, "id": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": { "$": 1, "succ": { "rss": _5 } }, "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 } }, "ie": { "$": 1, "succ": { "gov": _2, "blogspot": _3, "myspreadshop": _3 } }, "il": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ravpage": _3, "blogspot": _3, "tabitorder": _3, "mytabit": _3 } }, "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 } }, "xn--4dbrk0ce": { "$": 1, "succ": { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 } }, "": { "$": 1, "succ": { "": _2, "": _2, "": _2, "": _2 } }, "im": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ltd": _2, "plc": _2 } }, "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 } }, "in": { "$": 1, "succ": { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 } }, "info": { "$": 1, "succ": { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 } }, "int": { "$": 1, "succ": { "eu": _2 } }, "io": { "$": 1, "succ": { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": { "$": 0, "succ": { "app": _3, "backyards": _5 } }, "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": { "$": 0, "succ": { "uk0": _3 } }, "cleverapps": _3, "dappnode": { "$": 0, "succ": { "dyndns": _3 } }, "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": { "$": 0, "succ": { "id": _3 } }, "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _20, "beebyteapp": { "$": 0, "succ": { "sekd1": _3 } }, "jele": _3, "unispace": { "$": 0, "succ": { "cloud-fr1": _3 } }, "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": { "$": 2, "succ": { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 } }, "nodeart": { "$": 0, "succ": { "stage": _3 } }, "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": { "$": 2, "succ": { "mock": _3 } }, "protonet": _3, "qoto": _3, "qcx": { "$": 2, "succ": { "sys": _5 } }, "vaporcloud": _3, "vbrplsbx": { "$": 0, "succ": { "g": _3 } }, "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": { "$": 0, "succ": { "devices": _3 } }, "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _19, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": { "$": 0, "succ": { "dev": _30, "disrec": _30, "prod": _31, "testing": _30 } }, "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "basicserver": _3, "virtualserver": _3 } }, "iq": _32, "ir": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2 } }, "is": { "$": 1, "succ": { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 } }, "it": { "$": 1, "succ": { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-sd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-sdtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-sd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-sdtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "valle-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "valle-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valleaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valledaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-sdtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-sdtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-sdtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forl": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforl": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forl-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "sdtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": { "$": 0, "succ": { "jc": _3 } }, "tim": { "$": 0, "succ": { "open": { "$": 0, "succ": { "jelastic": _9 } } } }, "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 } }, "je": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "of": _3 } }, "jm": _8, "jo": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 } }, "jobs": _2, "jp": { "$": 1, "succ": { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": { "$": 1, "succ": { "aseinet": _28, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 } }, "or": _2, "aichi": { "$": 1, "succ": { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 } }, "akita": { "$": 1, "succ": { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 } }, "aomori": { "$": 1, "succ": { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 } }, "chiba": { "$": 1, "succ": { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 } }, "ehime": { "$": 1, "succ": { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 } }, "fukui": { "$": 1, "succ": { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 } }, "fukuoka": { "$": 1, "succ": { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 } }, "fukushima": { "$": 1, "succ": { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 } }, "gifu": { "$": 1, "succ": { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 } }, "gunma": { "$": 1, "succ": { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 } }, "hiroshima": { "$": 1, "succ": { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 } }, "hokkaido": { "$": 1, "succ": { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 } }, "hyogo": { "$": 1, "succ": { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 } }, "ibaraki": { "$": 1, "succ": { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 } }, "ishikawa": { "$": 1, "succ": { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 } }, "iwate": { "$": 1, "succ": { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 } }, "kagawa": { "$": 1, "succ": { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 } }, "kagoshima": { "$": 1, "succ": { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 } }, "kanagawa": { "$": 1, "succ": { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 } }, "kochi": { "$": 1, "succ": { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 } }, "kumamoto": { "$": 1, "succ": { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 } }, "kyoto": { "$": 1, "succ": { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 } }, "mie": { "$": 1, "succ": { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 } }, "miyagi": { "$": 1, "succ": { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 } }, "miyazaki": { "$": 1, "succ": { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 } }, "nagano": { "$": 1, "succ": { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 } }, "nagasaki": { "$": 1, "succ": { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 } }, "nara": { "$": 1, "succ": { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 } }, "niigata": { "$": 1, "succ": { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 } }, "oita": { "$": 1, "succ": { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 } }, "okayama": { "$": 1, "succ": { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 } }, "okinawa": { "$": 1, "succ": { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 } }, "osaka": { "$": 1, "succ": { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 } }, "saga": { "$": 1, "succ": { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 } }, "saitama": { "$": 1, "succ": { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 } }, "shiga": { "$": 1, "succ": { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 } }, "shimane": { "$": 1, "succ": { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 } }, "shizuoka": { "$": 1, "succ": { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 } }, "tochigi": { "$": 1, "succ": { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 } }, "tokushima": { "$": 1, "succ": { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 } }, "tokyo": { "$": 1, "succ": { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 } }, "tottori": { "$": 1, "succ": { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 } }, "toyama": { "$": 1, "succ": { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 } }, "wakayama": { "$": 1, "succ": { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 } }, "yamagata": { "$": 1, "succ": { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 } }, "yamaguchi": { "$": 1, "succ": { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 } }, "yamanashi": { "$": 1, "succ": { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 } }, "xn--4pvxs": _2, "": _2, "xn--vgu402c": _2, "": _2, "xn--c3s14m": _2, "": _2, "xn--f6qx53a": _2, "": _2, "xn--8pvr4u": _2, "": _2, "xn--uist22h": _2, "": _2, "xn--djrs72d6uy": _2, "": _2, "xn--mkru45i": _2, "": _2, "xn--0trq7p7nn": _2, "": _2, "xn--8ltr62k": _2, "": _2, "xn--2m4a15e": _2, "": _2, "xn--efvn9s": _2, "": _2, "xn--32vp30h": _2, "": _2, "xn--4it797k": _2, "": _2, "xn--1lqs71d": _2, "": _2, "xn--5rtp49c": _2, "": _2, "xn--5js045d": _2, "": _2, "xn--ehqz56n": _2, "": _2, "xn--1lqs03n": _2, "": _2, "xn--qqqt11m": _2, "": _2, "xn--kbrq7o": _2, "": _2, "xn--pssu33l": _2, "": _2, "xn--ntsq17g": _2, "": _2, "xn--uisz3g": _2, "": _2, "xn--6btw5a": _2, "": _2, "xn--1ctwo": _2, "": _2, "xn--6orx2r": _2, "": _2, "xn--rht61e": _2, "": _2, "xn--rht27z": _2, "": _2, "xn--djty4k": _2, "": _2, "xn--nit225k": _2, "": _2, "xn--rht3d": _2, "": _2, "xn--klty5x": _2, "": _2, "xn--kltx9a": _2, "": _2, "xn--kltp7d": _2, "": _2, "xn--uuwu58a": _2, "": _2, "xn--zbx025d": _2, "": _2, "xn--ntso0iqx3a": _2, "": _2, "xn--elqq16h": _2, "": _2, "xn--4it168d": _2, "": _2, "xn--klt787d": _2, "": _2, "xn--rny31h": _2, "": _2, "xn--7t0a264c": _2, "": _2, "xn--5rtq34k": _2, "": _2, "xn--k7yn95e": _2, "": _2, "xn--tor131o": _2, "": _2, "xn--d5qv7z876c": _2, "": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": { "$": 0, "succ": { "isk01": _12, "isk02": _12 } }, "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": { "$": 0, "succ": { "rs": _3, "user": _3 } }, "websozai": _3, "xii": _3 } }, "ke": { "$": 1, "succ": { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 } }, "kg": { "$": 1, "succ": { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 } }, "kh": _8, "ki": _33, "km": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 } }, "kn": { "$": 1, "succ": { "net": _2, "org": _2, "edu": _2, "gov": _2 } }, "kp": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 } }, "kr": { "$": 1, "succ": { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 } }, "kw": { "$": 1, "succ": { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 } }, "ky": _25, "kz": { "$": 1, "succ": { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": { "$": 0, "succ": { "upaas": _3 } } } }, "la": { "$": 1, "succ": { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 } }, "lb": _4, "lc": { "$": 1, "succ": { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 } }, "li": { "$": 1, "succ": { "blogspot": _3, "caa": _3 } }, "lk": { "$": 1, "succ": { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 } }, "lr": _4, "ls": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 } }, "lt": _34, "lu": { "$": 1, "succ": { "blogspot": _3, "123website": _3 } }, "lv": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 } }, "ly": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 } }, "ma": { "$": 1, "succ": { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 } }, "mc": { "$": 1, "succ": { "tm": _2, "asso": _2 } }, "md": { "$": 1, "succ": { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 } }, "me": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": { "$": 2, "succ": { "localhost": _3 } }, "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _23, "wedeploy": _3, "yombo": _3, "nohost": _3 } }, "mg": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 } }, "mh": _2, "mil": _2, "mk": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 } }, "ml": { "$": 1, "succ": { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 } }, "mm": _8, "mn": { "$": 1, "succ": { "gov": _2, "edu": _2, "org": _2, "nyc": _3 } }, "mo": _4, "mobi": { "$": 1, "succ": { "barsy": _3, "dscloud": _3 } }, "mp": { "$": 1, "succ": { "ju": _3 } }, "mq": _2, "mr": _34, "ms": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 } }, "mt": { "$": 1, "succ": { "com": _6, "edu": _2, "net": _2, "org": _2 } }, "mu": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 } }, "museum": { "$": 1, "succ": { "academy": _2, "agriculture": _2, "air": _2, "airguard": _2, "alabama": _2, "alaska": _2, "amber": _2, "ambulance": _2, "american": _2, "americana": _2, "americanantiques": _2, "americanart": _2, "amsterdam": _2, "and": _2, "annefrank": _2, "anthro": _2, "anthropology": _2, "antiques": _2, "aquarium": _2, "arboretum": _2, "archaeological": _2, "archaeology": _2, "architecture": _2, "art": _2, "artanddesign": _2, "artcenter": _2, "artdeco": _2, "arteducation": _2, "artgallery": _2, "arts": _2, "artsandcrafts": _2, "asmatart": _2, "assassination": _2, "assisi": _2, "association": _2, "astronomy": _2, "atlanta": _2, "austin": _2, "australia": _2, "automotive": _2, "aviation": _2, "axis": _2, "badajoz": _2, "baghdad": _2, "bahn": _2, "bale": _2, "baltimore": _2, "barcelona": _2, "baseball": _2, "basel": _2, "baths": _2, "bauern": _2, "beauxarts": _2, "beeldengeluid": _2, "bellevue": _2, "bergbau": _2, "berkeley": _2, "berlin": _2, "bern": _2, "bible": _2, "bilbao": _2, "bill": _2, "birdart": _2, "birthplace": _2, "bonn": _2, "boston": _2, "botanical": _2, "botanicalgarden": _2, "botanicgarden": _2, "botany": _2, "brandywinevalley": _2, "brasil": _2, "bristol": _2, "british": _2, "britishcolumbia": _2, "broadcast": _2, "brunel": _2, "brussel": _2, "brussels": _2, "bruxelles": _2, "building": _2, "burghof": _2, "bus": _2, "bushey": _2, "cadaques": _2, "california": _2, "cambridge": _2, "can": _2, "canada": _2, "capebreton": _2, "carrier": _2, "cartoonart": _2, "casadelamoneda": _2, "castle": _2, "castres": _2, "celtic": _2, "center": _2, "chattanooga": _2, "cheltenham": _2, "chesapeakebay": _2, "chicago": _2, "children": _2, "childrens": _2, "childrensgarden": _2, "chiropractic": _2, "chocolate": _2, "christiansburg": _2, "cincinnati": _2, "cinema": _2, "circus": _2, "civilisation": _2, "civilization": _2, "civilwar": _2, "clinton": _2, "clock": _2, "coal": _2, "coastaldefence": _2, "cody": _2, "coldwar": _2, "collection": _2, "colonialwilliamsburg": _2, "coloradoplateau": _2, "columbia": _2, "columbus": _2, "communication": _2, "communications": _2, "community": _2, "computer": _2, "computerhistory": _2, "xn--comunicaes-v6a2o": _2, "comunicaes": _2, "contemporary": _2, "contemporaryart": _2, "convent": _2, "copenhagen": _2, "corporation": _2, "xn--correios-e-telecomunicaes-ghc29a": _2, "correios-e-telecomunicaes": _2, "corvette": _2, "costume": _2, "countryestate": _2, "county": _2, "crafts": _2, "cranbrook": _2, "creation": _2, "cultural": _2, "culturalcenter": _2, "culture": _2, "cyber": _2, "cymru": _2, "dali": _2, "dallas": _2, "database": _2, "ddr": _2, "decorativearts": _2, "delaware": _2, "delmenhorst": _2, "denmark": _2, "depot": _2, "design": _2, "detroit": _2, "dinosaur": _2, "discovery": _2, "dolls": _2, "donostia": _2, "durham": _2, "eastafrica": _2, "eastcoast": _2, "education": _2, "educational": _2, "egyptian": _2, "eisenbahn": _2, "elburg": _2, "elvendrell": _2, "embroidery": _2, "encyclopedic": _2, "england": _2, "entomology": _2, "environment": _2, "environmentalconservation": _2, "epilepsy": _2, "essex": _2, "estate": _2, "ethnology": _2, "exeter": _2, "exhibition": _2, "family": _2, "farm": _2, "farmequipment": _2, "farmers": _2, "farmstead": _2, "field": _2, "figueres": _2, "filatelia": _2, "film": _2, "fineart": _2, "finearts": _2, "finland": _2, "flanders": _2, "florida": _2, "force": _2, "fortmissoula": _2, "fortworth": _2, "foundation": _2, "francaise": _2, "frankfurt": _2, "franziskaner": _2, "freemasonry": _2, "freiburg": _2, "fribourg": _2, "frog": _2, "fundacio": _2, "furniture": _2, "gallery": _2, "garden": _2, "gateway": _2, "geelvinck": _2, "gemological": _2, "geology": _2, "georgia": _2, "giessen": _2, "glas": _2, "glass": _2, "gorge": _2, "grandrapids": _2, "graz": _2, "guernsey": _2, "halloffame": _2, "hamburg": _2, "handson": _2, "harvestcelebration": _2, "hawaii": _2, "health": _2, "heimatunduhren": _2, "hellas": _2, "helsinki": _2, "hembygdsforbund": _2, "heritage": _2, "histoire": _2, "historical": _2, "historicalsociety": _2, "historichouses": _2, "historisch": _2, "historisches": _2, "history": _2, "historyofscience": _2, "horology": _2, "house": _2, "humanities": _2, "illustration": _2, "imageandsound": _2, "indian": _2, "indiana": _2, "indianapolis": _2, "indianmarket": _2, "intelligence": _2, "interactive": _2, "iraq": _2, "iron": _2, "isleofman": _2, "jamison": _2, "jefferson": _2, "jerusalem": _2, "jewelry": _2, "jewish": _2, "jewishart": _2, "jfk": _2, "journalism": _2, "judaica": _2, "judygarland": _2, "juedisches": _2, "juif": _2, "karate": _2, "karikatur": _2, "kids": _2, "koebenhavn": _2, "koeln": _2, "kunst": _2, "kunstsammlung": _2, "kunstunddesign": _2, "labor": _2, "labour": _2, "lajolla": _2, "lancashire": _2, "landes": _2, "lans": _2, "xn--lns-qla": _2, "lns": _2, "larsson": _2, "lewismiller": _2, "lincoln": _2, "linz": _2, "living": _2, "livinghistory": _2, "localhistory": _2, "london": _2, "losangeles": _2, "louvre": _2, "loyalist": _2, "lucerne": _2, "luxembourg": _2, "luzern": _2, "mad": _2, "madrid": _2, "mallorca": _2, "manchester": _2, "mansion": _2, "mansions": _2, "manx": _2, "marburg": _2, "maritime": _2, "maritimo": _2, "maryland": _2, "marylhurst": _2, "media": _2, "medical": _2, "medizinhistorisches": _2, "meeres": _2, "memorial": _2, "mesaverde": _2, "michigan": _2, "midatlantic": _2, "military": _2, "mill": _2, "miners": _2, "mining": _2, "minnesota": _2, "missile": _2, "missoula": _2, "modern": _2, "moma": _2, "money": _2, "monmouth": _2, "monticello": _2, "montreal": _2, "moscow": _2, "motorcycle": _2, "muenchen": _2, "muenster": _2, "mulhouse": _2, "muncie": _2, "museet": _2, "museumcenter": _2, "museumvereniging": _2, "music": _2, "national": _2, "nationalfirearms": _2, "nationalheritage": _2, "nativeamerican": _2, "naturalhistory": _2, "naturalhistorymuseum": _2, "naturalsciences": _2, "nature": _2, "naturhistorisches": _2, "natuurwetenschappen": _2, "naumburg": _2, "naval": _2, "nebraska": _2, "neues": _2, "newhampshire": _2, "newjersey": _2, "newmexico": _2, "newport": _2, "newspaper": _2, "newyork": _2, "niepce": _2, "norfolk": _2, "north": _2, "nrw": _2, "nyc": _2, "nyny": _2, "oceanographic": _2, "oceanographique": _2, "omaha": _2, "online": _2, "ontario": _2, "openair": _2, "oregon": _2, "oregontrail": _2, "otago": _2, "oxford": _2, "pacific": _2, "paderborn": _2, "palace": _2, "paleo": _2, "palmsprings": _2, "panama": _2, "paris": _2, "pasadena": _2, "pharmacy": _2, "philadelphia": _2, "philadelphiaarea": _2, "philately": _2, "phoenix": _2, "photography": _2, "pilots": _2, "pittsburgh": _2, "planetarium": _2, "plantation": _2, "plants": _2, "plaza": _2, "portal": _2, "portland": _2, "portlligat": _2, "posts-and-telecommunications": _2, "preservation": _2, "presidio": _2, "press": _2, "project": _2, "public": _2, "pubol": _2, "quebec": _2, "railroad": _2, "railway": _2, "research": _2, "resistance": _2, "riodejaneiro": _2, "rochester": _2, "rockart": _2, "roma": _2, "russia": _2, "saintlouis": _2, "salem": _2, "salvadordali": _2, "salzburg": _2, "sandiego": _2, "sanfrancisco": _2, "santabarbara": _2, "santacruz": _2, "santafe": _2, "saskatchewan": _2, "satx": _2, "savannahga": _2, "schlesisches": _2, "schoenbrunn": _2, "schokoladen": _2, "school": _2, "schweiz": _2, "science": _2, "scienceandhistory": _2, "scienceandindustry": _2, "sciencecenter": _2, "sciencecenters": _2, "science-fiction": _2, "sciencehistory": _2, "sciences": _2, "sciencesnaturelles": _2, "scotland": _2, "seaport": _2, "settlement": _2, "settlers": _2, "shell": _2, "sherbrooke": _2, "sibenik": _2, "silk": _2, "ski": _2, "skole": _2, "society": _2, "sologne": _2, "soundandvision": _2, "southcarolina": _2, "southwest": _2, "space": _2, "spy": _2, "square": _2, "stadt": _2, "stalbans": _2, "starnberg": _2, "state": _2, "stateofdelaware": _2, "station": _2, "steam": _2, "steiermark": _2, "stjohn": _2, "stockholm": _2, "stpetersburg": _2, "stuttgart": _2, "suisse": _2, "surgeonshall": _2, "surrey": _2, "svizzera": _2, "sweden": _2, "sydney": _2, "tank": _2, "tcm": _2, "technology": _2, "telekommunikation": _2, "television": _2, "texas": _2, "textile": _2, "theater": _2, "time": _2, "timekeeping": _2, "topology": _2, "torino": _2, "touch": _2, "town": _2, "transport": _2, "tree": _2, "trolley": _2, "trust": _2, "trustee": _2, "uhren": _2, "ulm": _2, "undersea": _2, "university": _2, "usa": _2, "usantiques": _2, "usarts": _2, "uscountryestate": _2, "usculture": _2, "usdecorativearts": _2, "usgarden": _2, "ushistory": _2, "ushuaia": _2, "uslivinghistory": _2, "utah": _2, "uvic": _2, "valley": _2, "vantaa": _2, "versailles": _2, "viking": _2, "village": _2, "virginia": _2, "virtual": _2, "virtuel": _2, "vlaanderen": _2, "volkenkunde": _2, "wales": _2, "wallonie": _2, "war": _2, "washingtondc": _2, "watchandclock": _2, "watch-and-clock": _2, "western": _2, "westfalen": _2, "whaling": _2, "wildlife": _2, "williamsburg": _2, "windmill": _2, "workshop": _2, "york": _2, "yorkshire": _2, "yosemite": _2, "youth": _2, "zoological": _2, "zoology": _2, "xn--9dbhblg6di": _2, "": _2, "xn--h1aegh": _2, "": _2 } }, "mv": { "$": 1, "succ": { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "mw": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 } }, "mx": { "$": 1, "succ": { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 } }, "my": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 } }, "mz": { "$": 1, "succ": { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "na": { "$": 1, "succ": { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 } }, "name": { "$": 1, "succ": { "her": _37, "his": _37 } }, "nc": { "$": 1, "succ": { "asso": _2, "nom": _2 } }, "ne": _2, "net": { "$": 1, "succ": { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": { "$": 0, "succ": { "prod": { "$": 0, "succ": { "cdn": _3 } } } }, "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": { "$": 0, "succ": { "r": _3 } }, "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": { "$": 2, "succ": { "u": _3 } }, "fastlylb": { "$": 2, "succ": { "map": _3 } }, "fastly": { "$": 0, "succ": { "freetls": _3, "map": _3, "prod": { "$": 0, "succ": { "a": _3, "global": _3 } }, "ssl": { "$": 0, "succ": { "a": _3, "b": _3, "global": _3 } } } }, "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": { "$": 2, "succ": { "fra1-de": _3, "west1-us": _3 } }, "elastx": { "$": 0, "succ": { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 } }, "faststacks": _3, "massivegrid": { "$": 0, "succ": { "paas": { "$": 0, "succ": { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 } } } }, "saveincloud": { "$": 0, "succ": { "jelastic": _3, "nordeste-idc": _3 } }, "scaleforce": _26, "tsukaeru": _27, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": { "$": 2, "succ": { "1": _3, "2": _3, "3": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 } }, "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": { "$": 0, "succ": { "webpaas": _5, "hosting": _5 } }, "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": { "$": 2, "succ": { "jelastic": { "$": 0, "succ": { "atl": _3, "njs": _3, "ric": _3 } } } }, "myspreadshop": _3, "srcf": { "$": 0, "succ": { "soc": _3, "user": _3 } }, "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": { "$": 0, "succ": { "beta": _3 } }, "ts": _3, "torproject": { "$": 2, "succ": { "pages": _3 } }, "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": { "$": 2, "succ": { "storage": _3, "website": _3 } }, "za": _3 } }, "nf": { "$": 1, "succ": { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 } }, "ng": { "$": 1, "succ": { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 } }, "ni": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 } }, "nl": { "$": 1, "succ": { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 } }, "no": { "$": 1, "succ": { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _38, "ah": _38, "bu": _38, "fm": _38, "hl": _38, "hm": _38, "jan-mayen": _38, "mr": _38, "nl": _38, "nt": _38, "of": _38, "ol": _38, "oslo": _38, "rl": _38, "sf": _38, "st": _38, "svalbard": _38, "tm": _38, "tr": _38, "va": _38, "vf": _38, "akrehamn": _2, "xn--krehamn-dxa": _2, "krehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "lgrd": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brnnysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "flor": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hnefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jrpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osyro": _2, "raholt": _2, "xn--rholt-mra": _2, "rholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjrdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "fjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "l": _2, "alesund": _2, "xn--lesund-hua": _2, "lesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "lt": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "laheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "mli": _2, "amot": _2, "xn--mot-tla": _2, "mot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "rdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "s": _2, "aseral": _2, "xn--seral-lra": _2, "seral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "asky": _2, "asnes": _2, "xn--snes-poa": _2, "snes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-hland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "avery": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "blt": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "bhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bjddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "bidr": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalvhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarky": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bod": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bdddj": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brnny": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "brum": _2, "telemark": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "b": _2 } }, "nordland": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "b": _2, "heroy": _2, "xn--hery-ira": _2, "hery": _2 } }, "bievat": _2, "xn--bievt-0qa": _2, "bievt": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bmlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "btsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "bhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyry": _2, "donna": _2, "xn--dnna-gra": _2, "dnna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "eveni": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finny": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "fl": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "frna": _2, "froya": _2, "xn--frya-hra": _2, "frya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "frde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "ggaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskl": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kranghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hbmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hpmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hmmrfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "koluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": { "$": 0, "succ": { "heroy": _2, "sande": _2 } }, "xn--mre-og-romsdal-qqb": { "$": 0, "succ": { "xn--hery-ira": _2, "sande": _2 } }, "mre-og-romsdal": { "$": 0, "succ": { "hery": _2, "sande": _2 } }, "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtlen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hgebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "hyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "hylandet": _2, "ha": _2, "xn--h-2fa": _2, "h": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "indery": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jlster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "krjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gls": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "krager": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krdsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "rhkkervju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvnangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "nvuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "givuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabt": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leagaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "linds": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "lhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lury": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lrdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "ldingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lrenskog": _2, "loten": _2, "xn--lten-gra": _2, "lten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "msy": _2, "muosat": _2, "xn--muost-0qa": _2, "muost": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "mely": _2, "meraker": _2, "xn--merker-kua": _2, "merker": _2, "moareke": _2, "xn--moreke-jua": _2, "moreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "mlselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "mlatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _39, "buskerud": _39, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjrga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjrga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "risa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nry": _2, "notteroy": _2, "xn--nttery-byae": _2, "nttery": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "ksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegrd": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "rland": _2, "orskog": _2, "xn--rskog-uua": _2, "rskog": _2, "orsta": _2, "xn--rsta-fra": _2, "rsta": _2, "hedmark": { "$": 0, "succ": { "os": _2, "valer": _2, "xn--vler-qoa": _2, "vler": _2 } }, "hordaland": { "$": 0, "succ": { "os": _2 } }, "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "ostery": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "stre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "vre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "yer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "ygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "ystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "rady": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risr": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rlingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rdy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rmskog": _2, "roros": _2, "xn--rros-gra": _2, "rros": _2, "rost": _2, "xn--rst-0na": _2, "rst": _2, "royken": _2, "xn--ryken-vua": _2, "ryken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "ryrvik": _2, "rade": _2, "xn--rde-ula": _2, "rde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "slt": _2, "xn--slat-5na": _2, "slat": _2, "samnanger": _2, "vestfold": { "$": 0, "succ": { "sande": _2 } }, "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervy": _2, "skierva": _2, "xn--skierv-uta": _2, "skierv": _2, "skjak": _2, "xn--skjk-soa": _2, "skjk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "sknland": _2, "skanit": _2, "xn--sknit-yqa": _2, "sknit": _2, "smola": _2, "xn--smla-hra": _2, "smla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjrdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "sgne": _2, "somna": _2, "xn--smna-gra": _2, "smna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "sndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sr-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sr-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sr-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sr-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mtta-vrjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "srfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "srreisa": _2, "sorum": _2, "xn--srum-gra": _2, "srum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "trany": _2, "tromso": _2, "xn--troms-zua": _2, "troms": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "trna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvr": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tnsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vads": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "hcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vard": _2, "varggat": _2, "xn--vrggt-xqad": _2, "vrggt": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegrshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvgy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "vry": _2, "vagan": _2, "xn--vgan-qoa": _2, "vgan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vgsy": _2, "vaga": _2, "xn--vg-yiab": _2, "vg": _2, "ostfold": { "$": 0, "succ": { "valer": _2 } }, "xn--stfold-9xa": { "$": 0, "succ": { "xn--vler-qoa": _2 } }, "stfold": { "$": 0, "succ": { "vler": _2 } }, "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "np": _8, "nr": _33, "nu": { "$": 1, "succ": { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 } }, "nz": { "$": 1, "succ": { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "mori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 } }, "om": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 } }, "onion": _2, "org": { "$": 1, "succ": { "altervista": _3, "amune": { "$": 0, "succ": { "tele": _3 } }, "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": { "$": 0, "succ": { "c": _3, "rsc": _3 } }, "cdn77-secure": { "$": 0, "succ": { "origin": { "$": 0, "succ": { "ssl": _3 } } } }, "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": { "$": 2, "succ": { "go": _3, "home": _3 } }, "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": { "$": 2, "succ": { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 } }, "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": { "$": 0, "succ": { "cloud": _3, "os": _21, "stg": { "$": 0, "succ": { "os": _21 } } } }, "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 } }, "pa": { "$": 1, "succ": { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 } }, "pe": { "$": 1, "succ": { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 } }, "pf": { "$": 1, "succ": { "com": _2, "org": _2, "edu": _2 } }, "pg": _8, "ph": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 } }, "pk": { "$": 1, "succ": { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 } }, "pl": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": { "$": 1, "succ": { "ap": _2, "ic": _2, "is": _2, "us": _2, "kmpsp": _2, "kppsp": _2, "kwpsp": _2, "psp": _2, "wskr": _2, "kwp": _2, "mw": _2, "ug": _2, "um": _2, "umig": _2, "ugim": _2, "upow": _2, "uw": _2, "starostwo": _2, "pa": _2, "po": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "so": _2, "sr": _2, "wsa": _2, "sko": _2, "uzs": _2, "wiih": _2, "winb": _2, "pinb": _2, "wios": _2, "witd": _2, "wzmiuw": _2, "piw": _2, "wiw": _2, "griw": _2, "wif": _2, "oum": _2, "sdn": _2, "zp": _2, "uppo": _2, "mup": _2, "wuoz": _2, "konsulat": _2, "oirm": _2 } }, "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 } }, "pm": { "$": 1, "succ": { "own": _3, "name": _3 } }, "pn": { "$": 1, "succ": { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 } }, "post": _2, "pr": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 } }, "pro": { "$": 1, "succ": { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": { "$": 0, "succ": { "bci": _3 } }, "barsy": _3 } }, "ps": { "$": 1, "succ": { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 } }, "pt": { "$": 1, "succ": { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 } }, "pw": { "$": 1, "succ": { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 } }, "py": { "$": 1, "succ": { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "qa": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 } }, "re": { "$": 1, "succ": { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 } }, "ro": { "$": 1, "succ": { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 } }, "rs": { "$": 1, "succ": { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": { "$": 0, "succ": { "shop": _3 } }, "blogspot": _3, "ua": _3, "ox": _3 } }, "ru": { "$": 1, "succ": { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _27, "myjino": { "$": 2, "succ": { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 } }, "cldmail": { "$": 0, "succ": { "hb": _3 } }, "mcdir": { "$": 2, "succ": { "vps": _3 } }, "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 } }, "rw": { "$": 1, "succ": { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "sa": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 } }, "sb": _4, "sc": _4, "sd": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 } }, "se": { "$": 1, "succ": { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": { "$": 0, "succ": { "su": _3 } } } }, "sg": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 } }, "sh": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": { "$": 0, "succ": { "bc": _3, "ent": _3, "eu": _3, "us": _3 } }, "now": _3, "vxl": _3, "wedeploy": _3 } }, "si": { "$": 1, "succ": { "gitapp": _3, "gitpage": _3, "blogspot": _3 } }, "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 } }, "so": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 } }, "sr": _2, "ss": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 } }, "st": { "$": 1, "succ": { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "kirara": _3, "noho": _3 } }, "su": { "$": 1, "succ": { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 } }, "sv": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 } }, "sx": _7, "sy": _32, "sz": { "$": 1, "succ": { "co": _2, "ac": _2, "org": _2 } }, "tc": { "$": 1, "succ": { "ch": _3, "me": _3, "we": _3 } }, "td": _6, "tel": _2, "tf": { "$": 1, "succ": { "sch": _3 } }, "tg": _2, "th": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 } }, "tj": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 } }, "tk": _2, "tl": _7, "tm": { "$": 1, "succ": { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 } }, "tn": { "$": 1, "succ": { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 } }, "to": { "$": 1, "succ": { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "x0": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 } }, "tr": { "$": 1, "succ": { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 } }, "tt": { "$": 1, "succ": { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 } }, "tv": { "$": 1, "succ": { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 } }, "tw": { "$": 1, "succ": { "edu": _2, "gov": _2, "mil": _2, "com": { "$": 1, "succ": { "mymailer": _3 } }, "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--czrw28b": _2, "": _2, "url": _3, "blogspot": _3 } }, "tz": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 } }, "ua": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 } }, "ug": { "$": 1, "succ": { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 } }, "uk": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "bytemark": { "$": 0, "succ": { "dh": _3, "vm": _3 } }, "blogspot": _3, "layershift": _26, "barsy": _3, "barsyonline": _3, "retrosnub": _31, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3 } }, "gov": { "$": 1, "succ": { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 } }, "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": { "$": 1, "succ": { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 } }, "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 } }, "us": { "$": 1, "succ": { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _40, "al": _40, "ar": _40, "as": _40, "az": _40, "ca": _40, "co": _40, "ct": _40, "dc": _40, "de": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _3 } }, "fl": _40, "ga": _40, "gu": _40, "hi": _41, "ia": _40, "id": _40, "il": _40, "in": _40, "ks": _40, "ky": _40, "la": _40, "ma": { "$": 1, "succ": { "k12": { "$": 1, "succ": { "pvt": _2, "chtr": _2, "paroch": _2 } }, "cc": _2, "lib": _2 } }, "md": _40, "me": _40, "mi": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 } }, "mn": _40, "mo": _40, "ms": _40, "mt": _40, "nc": _40, "nd": _41, "ne": _40, "nh": _40, "nj": _40, "nm": _40, "nv": _40, "ny": _40, "oh": _40, "ok": _40, "or": _40, "pa": _40, "pr": _40, "ri": _41, "sc": _40, "sd": _41, "tn": _40, "tx": _40, "ut": _40, "vi": _40, "vt": _40, "va": _40, "wa": _40, "wi": _40, "wv": { "$": 1, "succ": { "cc": _2 } }, "wy": _40, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": { "$": 0, "succ": { "phx": _3 } }, "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 } }, "uy": { "$": 1, "succ": { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 } }, "uz": { "$": 1, "succ": { "co": _2, "com": _2, "net": _2, "org": _2 } }, "va": _2, "vc": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": { "$": 2, "succ": { "d": _3 } }, "0e": _3 } }, "ve": { "$": 1, "succ": { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 } }, "vg": { "$": 1, "succ": { "at": _3 } }, "vi": { "$": 1, "succ": { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 } }, "vn": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "int": _2, "ac": _2, "biz": _2, "info": _2, "name": _2, "pro": _2, "health": _2, "blogspot": _3 } }, "vu": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 } }, "wf": { "$": 1, "succ": { "biz": _3, "sch": _3 } }, "ws": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 } }, "yt": { "$": 1, "succ": { "org": _3 } }, "xn--mgbaam7a8h": _2, "": _2, "xn--y9a3aq": _2, "": _2, "xn--54b7fta0cc": _2, "": _2, "xn--90ae": _2, "": _2, "xn--mgbcpq6gpa1a": _2, "": _2, "xn--90ais": _2, "": _2, "xn--fiqs8s": _2, "": _2, "xn--fiqz9s": _2, "": _2, "xn--lgbbat1ad8j": _2, "": _2, "xn--wgbh1c": _2, "": _2, "xn--e1a4c": _2, "": _2, "xn--qxa6a": _2, "": _2, "xn--mgbah1a3hjkrd": _2, "": _2, "xn--node": _2, "": _2, "xn--qxam": _2, "": _2, "xn--j6w193g": { "$": 1, "succ": { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 } }, "": { "$": 1, "succ": { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 } }, "xn--2scrj9c": _2, "": _2, "xn--3hcrj9c": _2, "": _2, "xn--45br5cyl": _2, "": _2, "xn--h2breg3eve": _2, "": _2, "xn--h2brj9c8c": _2, "": _2, "xn--mgbgu82a": _2, "": _2, "xn--rvc1e0am3e": _2, "": _2, "xn--h2brj9c": _2, "": _2, "xn--mgbbh1a": _2, "": _2, "xn--mgbbh1a71e": _2, "": _2, "xn--fpcrj9c3d": _2, "": _2, "xn--gecrj9c": _2, "": _2, "xn--s9brj9c": _2, "": _2, "xn--45brj9c": _2, "": _2, "xn--xkc2dl3a5ee0h": _2, "": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2, "xn--mgbtx2b": _2, "": _2, "xn--mgbayh7gpa": _2, "": _2, "xn--3e0b707e": _2, "": _2, "xn--80ao21a": _2, "": _2, "xn--q7ce6a": _2, "": _2, "xn--fzc2c9e2c": _2, "": _2, "xn--xkc2al3hye2a": _2, "": _2, "xn--mgbc0a9azcg": _2, "": _2, "xn--d1alf": _2, "": _2, "xn--l1acc": _2, "": _2, "xn--mix891f": _2, "": _2, "xn--mix082f": _2, "": _2, "xn--mgbx4cd0ab": _2, "": _2, "xn--mgb9awbf": _2, "": _2, "xn--mgbai9azgqp6j": _2, "": _2, "xn--mgbai9a5eva00b": _2, "": _2, "xn--ygbi2ammx": _2, "": _2, "xn--90a3ac": { "$": 1, "succ": { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 } }, "": { "$": 1, "succ": { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 } }, "xn--p1ai": _2, "": _2, "xn--wgbl6a": _2, "": _2, "xn--mgberp4a5d4ar": _2, "": _2, "xn--mgberp4a5d4a87g": _2, "": _2, "xn--mgbqly7c0a67fbc": _2, "": _2, "xn--mgbqly7cvafr": _2, "": _2, "xn--mgbpl2fh": _2, "": _2, "xn--yfro4i67o": _2, "": _2, "xn--clchc0ea0b2g2a9gcd": _2, "": _2, "xn--ogbpf8fl": _2, "": _2, "xn--mgbtf8fl": _2, "": _2, "xn--o3cw4h": { "$": 1, "succ": { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 } }, "": { "$": 1, "succ": { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 } }, "xn--pgbs0dh": _2, "": _2, "xn--kpry57d": _2, "": _2, "xn--kprw13d": _2, "": _2, "xn--nnx388a": _2, "": _2, "xn--j1amh": _2, "": _2, "xn--mgb2ddes": _2, "": _2, "xxx": _2, "ye": _32, "za": { "$": 0, "succ": { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 } }, "zm": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 } }, "zw": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 } }, "aaa": _2, "aarp": _2, "abarth": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": { "$": 1, "succ": { "official": _3 } }, "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alfaromeo": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": { "$": 1, "succ": { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": { "$": 2, "succ": { "a": _3 } }, "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "snowflake": { "$": 2, "succ": { "privatelink": _3 } }, "streamlit": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 } }, "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": { "$": 1, "succ": { "aus": _3, "nz": _3 } }, "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": { "$": 1, "succ": { "cloudsite": _3 } }, "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": { "$": 1, "succ": { "nabu": { "$": 0, "succ": { "ui": _3 } } } }, "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": { "$": 1, "succ": { "banzai": _5, "elementor": _3, "encoway": { "$": 0, "succ": { "eu": _3 } }, "statics": _5, "ravendb": _3, "axarnet": { "$": 0, "succ": { "es-1": _3 } }, "diadem": _3, "jelastic": { "$": 0, "succ": { "vip": _3 } }, "jele": _3, "jenv-aruba": { "$": 0, "succ": { "aruba": { "$": 0, "succ": { "eur": { "$": 0, "succ": { "it1": _3 } } } }, "it1": _3 } }, "keliweb": { "$": 2, "succ": { "cs": _3 } }, "oxa": { "$": 2, "succ": { "tn": _3, "uk": _3 } }, "primetel": { "$": 2, "succ": { "uk": _3 } }, "reclaim": { "$": 0, "succ": { "ca": _3, "uk": _3, "us": _3 } }, "trendhosting": { "$": 0, "succ": { "ch": _3, "de": _3 } }, "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": { "$": 0, "succ": { "baremetal": { "$": 0, "succ": { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 } }, "fr-par": { "$": 0, "succ": { "fnc": { "$": 2, "succ": { "functions": _3 } }, "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "instances": { "$": 0, "succ": { "priv": _3, "pub": _3 } }, "k8s": _3, "nl-ams": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "pl-waw": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3 } }, "scalebook": _3, "smartlabeling": _3 } }, "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 } }, "club": { "$": 1, "succ": { "cloudns": _3, "jele": _3, "barsy": _3 } }, "clubmed": _2, "coach": _2, "codes": { "$": 1, "succ": { "owo": _5 } }, "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": { "$": 1, "succ": { "nog": _3, "ravendb": _3, "myforum": _3 } }, "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cookingchannel": _2, "cool": { "$": 1, "succ": { "elementor": _3, "de": _3 } }, "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": { "$": 1, "succ": { "bss": _3 } }, "dev": { "$": 1, "succ": { "autocode": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": { "$": 0, "succ": { "user": _5 } }, "loginline": _3, "mediatech": _3, "ngrok": _3, "ngrok-free": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 } }, "dhl": _2, "diamonds": _2, "diet": _2, "digital": { "$": 1, "succ": { "cloudapps": { "$": 2, "succ": { "london": _3 } } } }, "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": { "$": 1, "succ": { "dapps": { "$": 0, "succ": { "*": _3, "bzz": _5 } } } }, "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": { "$": 1, "succ": { "compute": _5 } }, "etisalat": _2, "eurovision": _2, "eus": { "$": 1, "succ": { "party": _28 } }, "events": { "$": 1, "succ": { "koobin": _3, "co": _3 } }, "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _29, "family": _2, "fan": _2, "fans": _2, "farm": { "$": 1, "succ": { "storj": _3 } }, "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fiat": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "foodnetwork": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": { "$": 1, "succ": { "cnpy": _3 } }, "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": { "$": 1, "succ": { "cloud": _3, "translate": _3, "usercontent": _5 } }, "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": { "$": 1, "succ": { "discourse": _3 } }, "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": { "$": 1, "succ": { "hra": _3 } }, "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hgtv": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": { "$": 1, "succ": { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 } }, "hosting": { "$": 1, "succ": { "opencraft": _3 } }, "hot": _2, "hoteles": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": { "$": 1, "succ": { "co": _3, "edu": _3 } }, "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "lancia": _2, "land": { "$": 1, "succ": { "static": { "$": 2, "succ": { "dev": _3, "sites": _3 } } } }, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "linde": _2, "link": { "$": 1, "succ": { "cyon": _3, "mypep": _3, "dweb": _5 } }, "lipsy": _2, "live": { "$": 1, "succ": { "hlx": _3 } }, "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": { "$": 1, "succ": { "omg": _3 } }, "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "macys": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": { "$": 1, "succ": { "router": _3 } }, "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "maserati": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _35, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _36, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "mutual": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": { "$": 1, "succ": { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 } }, "neustar": _2, "new": _2, "news": { "$": 1, "succ": { "noticeable": _3 } }, "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "northwesternmutual": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": { "$": 1, "succ": { "onred": { "$": 2, "succ": { "staging": _3 } }, "service": _3, "homelink": _3 } }, "ong": _2, "onl": _2, "online": { "$": 1, "succ": { "eero": _3, "eero-stage": _3, "barsy": _3 } }, "ooo": _2, "open": _2, "oracle": _2, "orange": { "$": 1, "succ": { "tech": _3 } }, "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": { "$": 1, "succ": { "nerdpol": _3 } }, "page": { "$": 1, "succ": { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 } }, "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _29, "passagens": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _35, "physio": _2, "pics": _2, "pictet": _2, "pictures": { "$": 1, "succ": { "1337": _3 } }, "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": { "$": 1, "succ": { "ngrok": _3 } }, "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": { "$": 1, "succ": { "indie": _3 } }, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _36, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _29, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": { "$": 1, "succ": { "clan": _3 } }, "rocher": _2, "rocks": { "$": 1, "succ": { "myddns": _3, "lima-city": _3, "webspace": _3 } }, "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": { "$": 1, "succ": { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3 } }, "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _29, "scot": { "$": 1, "succ": { "edu": _3, "gov": { "$": 2, "succ": { "service": _3 } } } }, "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": { "$": 1, "succ": { "loginline": _3 } }, "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": { "$": 1, "succ": { "base": _3, "hoplix": _3, "barsy": _3 } }, "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": { "$": 1, "succ": { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 } }, "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": { "$": 1, "succ": { "diher": _5 } }, "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": { "$": 1, "succ": { "myfast": _3, "uber": _3, "xs4all": _3 } }, "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": { "$": 1, "succ": { "sellfy": _3, "shopware": _3, "storebase": _3 } }, "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _36, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": { "$": 1, "succ": { "knightpoint": _3 } }, "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": { "$": 1, "succ": { "discourse": _3, "jelastic": _3 } }, "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tiffany": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": { "$": 1, "succ": { "prequalifyme": _3 } }, "tokyo": _2, "tools": _2, "top": { "$": 1, "succ": { "now-dns": _3, "ntdll": _3 } }, "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _29, "trading": _2, "training": _2, "travel": _2, "travelchannel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "vuelos": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _35, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _35, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "": _2, "xn--1ck2e1b": _2, "": _2, "xn--1qqw23a": _2, "": _2, "xn--30rr7y": _2, "": _2, "xn--3bst00m": _2, "": _2, "xn--3ds443g": _2, "": _2, "xn--3pxu8k": _2, "": _2, "xn--42c2d9a": _2, "": _2, "xn--45q11c": _2, "": _2, "xn--4gbrim": _2, "": _2, "xn--55qw42g": _2, "": _2, "xn--55qx5d": _2, "": _2, "xn--5su34j936bgsg": _2, "": _2, "xn--5tzm5g": _2, "": _2, "xn--6frz82g": _2, "": _2, "xn--6qq986b3xl": _2, "": _2, "xn--80adxhks": _2, "": _2, "xn--80aqecdr1a": _2, "": _2, "xn--80asehdb": _2, "": _2, "xn--80aswg": _2, "": _2, "xn--8y0a063a": _2, "": _2, "xn--9dbq2a": _2, "": _2, "xn--9et52u": _2, "": _2, "xn--9krt00a": _2, "": _2, "xn--b4w605ferd": _2, "": _2, "xn--bck1b9a5dre4c": _2, "": _2, "xn--c1avg": _2, "": _2, "xn--c2br7g": _2, "": _2, "xn--cck2b3b": _2, "": _2, "xn--cckwcxetd": _2, "": _2, "xn--cg4bki": _2, "": _2, "xn--czr694b": _2, "": _2, "xn--czrs0t": _2, "": _2, "xn--czru2d": _2, "": _2, "xn--d1acj3b": _2, "": _2, "xn--eckvdtc9d": _2, "": _2, "xn--efvy88h": _2, "": _2, "xn--fct429k": _2, "": _2, "xn--fhbei": _2, "": _2, "xn--fiq228c5hs": _2, "": _2, "xn--fiq64b": _2, "": _2, "xn--fjq720a": _2, "": _2, "xn--flw351e": _2, "": _2, "xn--fzys8d69uvgm": _2, "": _2, "xn--g2xx48c": _2, "": _2, "xn--gckr3f0f": _2, "": _2, "xn--gk3at1e": _2, "": _2, "xn--hxt814e": _2, "": _2, "xn--i1b6b1a6a2e": _2, "": _2, "xn--imr513n": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--j1aef": _2, "": _2, "xn--jlq480n2rg": _2, "": _2, "xn--jvr189m": _2, "": _2, "xn--kcrx77d1x4a": _2, "": _2, "xn--kput3i": _2, "": _2, "xn--mgba3a3ejt": _2, "": _2, "xn--mgba7c0bbn0a": _2, "": _2, "xn--mgbaakc7dvf": _2, "": _2, "xn--mgbab2bd": _2, "": _2, "xn--mgbca7dzdo": _2, "": _2, "xn--mgbi4ecexp": _2, "": _2, "xn--mgbt3dhd": _2, "": _2, "xn--mk1bu44c": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--ngbc5azd": _2, "": _2, "xn--ngbe9e0a": _2, "": _2, "xn--ngbrx": _2, "": _2, "xn--nqv7f": _2, "": _2, "xn--nqv7fs00ema": _2, "": _2, "xn--nyqy26a": _2, "": _2, "xn--otu796d": _2, "": _2, "xn--p1acf": { "$": 1, "succ": { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 } }, "": { "$": 1, "succ": { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 } }, "xn--pssy2u": _2, "": _2, "xn--q9jyb4c": _2, "": _2, "xn--qcka1pmc": _2, "": _2, "xn--rhqv96g": _2, "": _2, "xn--rovu88b": _2, "": _2, "xn--ses554g": _2, "": _2, "xn--t60b56a": _2, "": _2, "xn--tckwe": _2, "": _2, "xn--tiq49xqyj": _2, "": _2, "xn--unup4y": _2, "": _2, "xn--vermgensberater-ctb": _2, "vermgensberater": _2, "xn--vermgensberatung-pwb": _2, "vermgensberatung": _2, "xn--vhquv": _2, "": _2, "xn--vuq861b": _2, "": _2, "xn--w4r85el8fhu5dnra": _2, "": _2, "xn--w4rs40l": _2, "": _2, "xn--xhq521b": _2, "": _2, "xn--zfr164b": _2, "": _2, "xyz": { "$": 1, "succ": { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 } }, "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": { "$": 1, "succ": { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 } }, "zuerich": _2 } };
    return rules;
})();

/**
 * Lookup parts of domain in Trie
 */
function lookupInTrie(parts, trie, index, allowedMask) {
    let result = null;
    let node = trie;
    while (node !== undefined) {
        // We have a match!
        if ((node.$ & allowedMask) !== 0) {
            result = {
                index: index + 1,
                isIcann: node.$ === 1 /* RULE_TYPE.ICANN */,
                isPrivate: node.$ === 2 /* RULE_TYPE.PRIVATE */,
            };
        }
        // No more `parts` to look for
        if (index === -1) {
            break;
        }
        const succ = node.succ;
        node = succ && (succ[parts[index]] || succ['*']);
        index -= 1;
    }
    return result;
}
/**
 * Check if `hostname` has a valid public suffix in `trie`.
 */
function suffixLookup(hostname, options, out) {
    if (fastPathLookup(hostname, options, out) === true) {
        return;
    }
    const hostnameParts = hostname.split('.');
    const allowedMask = (options.allowPrivateDomains === true ? 2 /* RULE_TYPE.PRIVATE */ : 0) |
        (options.allowIcannDomains === true ? 1 /* RULE_TYPE.ICANN */ : 0);
    // Look for exceptions
    const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
    if (exceptionMatch !== null) {
        out.isIcann = exceptionMatch.isIcann;
        out.isPrivate = exceptionMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
        return;
    }
    // Look for a match in rules
    const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
    if (rulesMatch !== null) {
        out.isIcann = rulesMatch.isIcann;
        out.isPrivate = rulesMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
        return;
    }
    // No match found...
    // Prevailing rule is '*' so we consider the top-level domain to be the
    // public suffix of `hostname` (e.g.: 'example.org' => 'org').
    out.isIcann = false;
    out.isPrivate = false;
    out.publicSuffix = hostnameParts[hostnameParts.length - 1];
}

// For all methods but 'parse', it does not make sense to allocate an object
// every single time to only return the value of a specific attribute. To avoid
// this un-necessary allocation, we use a global object which is re-used.
const RESULT = getEmptyResult();
function parse(url, options = {}) {
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, getEmptyResult());
}
function getHostname(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 0 /* FLAG.HOSTNAME */, suffixLookup, options, RESULT).hostname;
}
function getPublicSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 2 /* FLAG.PUBLIC_SUFFIX */, suffixLookup, options, RESULT)
        .publicSuffix;
}
function getDomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 3 /* FLAG.DOMAIN */, suffixLookup, options, RESULT).domain;
}
function getSubdomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 4 /* FLAG.SUB_DOMAIN */, suffixLookup, options, RESULT)
        .subdomain;
}
function getDomainWithoutSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, RESULT)
        .domainWithoutSuffix;
}

exports.getDomain = getDomain;
exports.getDomainWithoutSuffix = getDomainWithoutSuffix;
exports.getHostname = getHostname;
exports.getPublicSuffix = getPublicSuffix;
exports.getSubdomain = getSubdomain;
exports.parse = parse;


},{}],11:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("webextension-polyfill", ["module"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.browser = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (!globalThis.chrome?.runtime?.id) {
    throw new Error("This script should only be loaded in a browser extension.");
  }

  if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received."; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      });
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    }; // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = globalThis.browser;
  }
});


},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
const util_1 = require("./helpers/util");
exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
exports.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
exports.ZodError = ZodError;
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

},{"./helpers/util":18}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
const en_1 = __importDefault(require("./locales/en"));
exports.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
exports.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
exports.getErrorMap = getErrorMap;

},{"./locales/en":20}],14:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./errors"), exports);
__exportStar(require("./helpers/parseUtil"), exports);
__exportStar(require("./helpers/typeAliases"), exports);
__exportStar(require("./helpers/util"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./ZodError"), exports);

},{"./ZodError":12,"./errors":13,"./helpers/parseUtil":16,"./helpers/typeAliases":17,"./helpers/util":18,"./types":21}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorUtil = void 0;
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));

},{}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
const errors_1 = require("../errors");
const en_1 = __importDefault(require("../locales/en"));
const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
exports.makeIssue = makeIssue;
exports.EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = (0, exports.makeIssue)({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            en_1.default,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
exports.addIssueToContext = addIssueToContext;
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return exports.INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return exports.INVALID;
            if (value.status === "aborted")
                return exports.INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
exports.ParseStatus = ParseStatus;
exports.INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
exports.DIRTY = DIRTY;
const OK = (value) => ({ status: "valid", value });
exports.OK = OK;
const isAborted = (x) => x.status === "aborted";
exports.isAborted = isAborted;
const isDirty = (x) => x.status === "dirty";
exports.isDirty = isDirty;
const isValid = (x) => x.status === "valid";
exports.isValid = isValid;
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
exports.isAsync = isAsync;

},{"../errors":13,"../locales/en":20}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function"
        ? (obj) => Object.keys(obj)
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val)
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util = exports.util || (exports.util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return exports.ZodParsedType.undefined;
        case "string":
            return exports.ZodParsedType.string;
        case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
            return exports.ZodParsedType.boolean;
        case "function":
            return exports.ZodParsedType.function;
        case "bigint":
            return exports.ZodParsedType.bigint;
        case "symbol":
            return exports.ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return exports.ZodParsedType.array;
            }
            if (data === null) {
                return exports.ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
        default:
            return exports.ZodParsedType.unknown;
    }
};
exports.getParsedType = getParsedType;

},{}],19:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.z = void 0;
const z = __importStar(require("./external"));
exports.z = z;
__exportStar(require("./external"), exports);
exports.default = z;

},{"./external":14}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../helpers/util");
const ZodError_1 = require("../ZodError");
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
    }
    return { message };
};
exports.default = errorMap;

},{"../ZodError":12,"../helpers/util":18}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discriminatedUnion = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = void 0;
const errors_1 = require("./errors");
const errorUtil_1 = require("./helpers/errorUtil");
const parseUtil_1 = require("./helpers/parseUtil");
const util_1 = require("./helpers/util");
const ZodError_1 = require("./ZodError");
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError_1.ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodError_1.ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
exports.ZodType = ZodType;
exports.Schema = ZodType;
exports.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
        this.nonempty = (message) => this.min(1, errorUtil_1.errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
        this.toLowerCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
        this.toUpperCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodString = ZodString;
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.number,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util_1.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
exports.ZodNumber = ZodNumber;
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.date,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
exports.ZodDate = ZodDate;
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.null,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodNull = ZodNull;
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodAny = ZodAny;
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
}
exports.ZodNever = ZodNever;
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.void,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodVoid = ZodVoid;
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodArray = ZodArray;
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") {
            }
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
    }
}
exports.ZodObject = ZodObject;
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
exports.ZodUnion = ZodUnion;
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
        const optionsMap = new Map();
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === util_1.ZodParsedType.date &&
        bType === util_1.ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
exports.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x);
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
exports.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
exports.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.map,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
exports.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.set,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return parseUtil_1.INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodSet = ZodSet;
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.function,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return (0, parseUtil_1.OK)(async (...args) => {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return (0, parseUtil_1.OK)((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
exports.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
exports.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
exports.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
exports.ZodEnum = ZodEnum;
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string &&
            ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
exports.ZodNativeEnum = ZodNativeEnum;
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
            ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
exports.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!(0, parseUtil_1.isValid)(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!(0, parseUtil_1.isValid)(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util_1.util.assertNever(effect);
    }
}
exports.ZodEffects = ZodEffects;
exports.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodOptional = ZodOptional;
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodNullable = ZodNullable;
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
exports.ZodDefault = ZodDefault;
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError_1.ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError_1.ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
exports.ZodCatch = ZodCatch;
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
exports.ZodNaN = ZodNaN;
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
exports.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
exports.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
exports.ZodPipeline = ZodPipeline;
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
exports.custom = custom;
exports.late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
class Class {
    constructor(..._) { }
}
const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => (0, exports.custom)((data) => data instanceof cls, params);
exports.instanceof = instanceOfType;
const stringType = ZodString.create;
exports.string = stringType;
const numberType = ZodNumber.create;
exports.number = numberType;
const nanType = ZodNaN.create;
exports.nan = nanType;
const bigIntType = ZodBigInt.create;
exports.bigint = bigIntType;
const booleanType = ZodBoolean.create;
exports.boolean = booleanType;
const dateType = ZodDate.create;
exports.date = dateType;
const symbolType = ZodSymbol.create;
exports.symbol = symbolType;
const undefinedType = ZodUndefined.create;
exports.undefined = undefinedType;
const nullType = ZodNull.create;
exports.null = nullType;
const anyType = ZodAny.create;
exports.any = anyType;
const unknownType = ZodUnknown.create;
exports.unknown = unknownType;
const neverType = ZodNever.create;
exports.never = neverType;
const voidType = ZodVoid.create;
exports.void = voidType;
const arrayType = ZodArray.create;
exports.array = arrayType;
const objectType = ZodObject.create;
exports.object = objectType;
const strictObjectType = ZodObject.strictCreate;
exports.strictObject = strictObjectType;
const unionType = ZodUnion.create;
exports.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
exports.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
exports.intersection = intersectionType;
const tupleType = ZodTuple.create;
exports.tuple = tupleType;
const recordType = ZodRecord.create;
exports.record = recordType;
const mapType = ZodMap.create;
exports.map = mapType;
const setType = ZodSet.create;
exports.set = setType;
const functionType = ZodFunction.create;
exports.function = functionType;
const lazyType = ZodLazy.create;
exports.lazy = lazyType;
const literalType = ZodLiteral.create;
exports.literal = literalType;
const enumType = ZodEnum.create;
exports.enum = enumType;
const nativeEnumType = ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
exports.promise = promiseType;
const effectsType = ZodEffects.create;
exports.effect = effectsType;
exports.transformer = effectsType;
const optionalType = ZodOptional.create;
exports.optional = optionalType;
const nullableType = ZodNullable.create;
exports.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
exports.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
exports.pipeline = pipelineType;
const ostring = () => stringType().optional();
exports.ostring = ostring;
const onumber = () => numberType().optional();
exports.onumber = onumber;
const oboolean = () => booleanType().optional();
exports.oboolean = oboolean;
exports.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
exports.NEVER = parseUtil_1.INVALID;

},{"./ZodError":12,"./errors":13,"./helpers/errorUtil":15,"./helpers/parseUtil":16,"./helpers/util":18}],22:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/** @module tds */

var _require = require('./utils'),
  generateDNRRule = _require.generateDNRRule;
var AMP_PROTECTION_PRIORITY = 40000;

/**
 * @typedef generateAmpProtectionRulesResult
 * @property {import('./utils').DNRRule} rule
 * @property {object} matchDetails
 */

/**
 * Function to produce the declarativeNetRequest rules and corresponding match
 * details for the given trackerAllowlist configuration.
 * @param {object} extensionConfiguration
 *   The extension configuration.
 * @param {function} isRegexSupported
 *   A function compatible with chrome.declarativeNetRequest.isRegexSupported.
 *   See https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#method-isRegexSupported
 * @return {Promise<generateAmpProtectionRulesResult[]>}
 */
function generateAmpProtectionRules(_x, _x2) {
  return _generateAmpProtectionRules.apply(this, arguments);
}
function _generateAmpProtectionRules() {
  _generateAmpProtectionRules = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref, isRegexSupported) {
    var ampLinks, results, ampLinkRegexps, excludedDomains, _iterator, _step, ampLinkRegex, regexFilter, _yield$isRegexSupport, isSupported, rule, matchDetails;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ampLinks = _ref.features.ampLinks;
            results = [];
            if (!(!ampLinks || ampLinks.state !== 'enabled' || !ampLinks.settings || !ampLinks.settings.linkFormats || ampLinks.settings.linkFormats.length === 0)) {
              _context.next = 4;
              break;
            }
            return _context.abrupt("return", results);
          case 4:
            ampLinkRegexps = ampLinks.settings.linkFormats;
            excludedDomains = ((ampLinks === null || ampLinks === void 0 ? void 0 : ampLinks.exceptions) || []).map(function (_ref2) {
              var domain = _ref2.domain;
              return domain;
            });
            _iterator = _createForOfIteratorHelper(ampLinkRegexps);
            _context.prev = 7;
            _iterator.s();
          case 9:
            if ((_step = _iterator.n()).done) {
              _context.next = 23;
              break;
            }
            ampLinkRegex = _step.value;
            // It seems that \S (non-whitespace character class) is not always
            // matched correctly. Luckily whitespace in URLs should be encoded
            // anyway, so let's match . (any character) instead.
            // TODO: Figure out minimal test case and file a Chromium bug.
            regexFilter = ampLinkRegex.replaceAll('\\S', '.');
            _context.next = 14;
            return isRegexSupported({
              regex: regexFilter,
              isCaseSensitive: false,
              requireCapturing: true
            });
          case 14:
            _yield$isRegexSupport = _context.sent;
            isSupported = _yield$isRegexSupport.isSupported;
            if (isSupported) {
              _context.next = 18;
              break;
            }
            return _context.abrupt("continue", 21);
          case 18:
            rule = generateDNRRule({
              priority: AMP_PROTECTION_PRIORITY,
              actionType: 'redirect',
              regexFilter: regexFilter,
              redirect: {
                regexSubstitution: 'https://\\1'
              },
              resourceTypes: ['main_frame'],
              excludedInitiatorDomains: excludedDomains,
              excludedRequestDomains: excludedDomains
            });
            matchDetails = {
              type: 'ampProtection'
            };
            results.push({
              rule: rule,
              matchDetails: matchDetails
            });
          case 21:
            _context.next = 9;
            break;
          case 23:
            _context.next = 28;
            break;
          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](7);
            _iterator.e(_context.t0);
          case 28:
            _context.prev = 28;
            _iterator.f();
            return _context.finish(28);
          case 31:
            return _context.abrupt("return", results);
          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 25, 28, 31]]);
  }));
  return _generateAmpProtectionRules.apply(this, arguments);
}
exports.AMP_PROTECTION_PRIORITY = AMP_PROTECTION_PRIORITY;
exports.generateAmpProtectionRules = generateAmpProtectionRules;

},{"./utils":33}],23:[function(require,module,exports){
"use strict";

var _require = require('./cookies'),
  generateCookieBlockingRuleset = _require.generateCookieBlockingRuleset;

/**
 * Build blocklist rules which depend on both the privacy configuration and blocklist. This
 * currently covers:
 *   - cookie header blocking
 * @param {import('./utils').TDS} tds The tracker blocklist
 * @param {import('./utils').PrivacyConfiguration} config Privacy config
 * @param {string[]} denylistedDomains
 *   Domains that the user has specifically denylisted. These domains should be
 *   excluded from any contentBlocking/unprotectedTemporary allowlisting rules.
 * @returns {import('./utils').RulesetResult}
 */
function generateCombinedConfigBlocklistRuleset(tds, config, denylistedDomains) {
  var _config$features, _config$features$cook, _config$features$cook2, _config$features$cook3;
  var startingRuleId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  // Note: If more features are covered by the combined ruleset generator in
  //       the future, this logic will need to be refactored. A pattern
  //       similar to generateExtensionConfigurationRuleset could be used.
  if (((_config$features = config.features) === null || _config$features === void 0 ? void 0 : (_config$features$cook = _config$features.cookie) === null || _config$features$cook === void 0 ? void 0 : _config$features$cook.state) !== 'enabled') {
    return {
      ruleset: [],
      matchDetailsByRuleId: {}
    };
  }

  // Merge cookie feature exceptions with unprotectedTemporary, then remove any denylisted domains
  var cookieAllowlist = (((_config$features$cook2 = config.features.cookie) === null || _config$features$cook2 === void 0 ? void 0 : _config$features$cook2.exceptions.map(function (entry) {
    return entry.domain;
  })) || []).concat(config.unprotectedTemporary.map(function (entry) {
    return entry.domain;
  })).filter(function (domain) {
    return !denylistedDomains.includes(domain);
  });
  var excludedCookieDomains = (_config$features$cook3 = config.features.cookie) === null || _config$features$cook3 === void 0 ? void 0 : _config$features$cook3.settings.excludedCookieDomains.map(function (entry) {
    return entry.domain;
  });
  return generateCookieBlockingRuleset(tds, excludedCookieDomains, cookieAllowlist, startingRuleId);
}
exports.generateCombinedConfigBlocklistRuleset = generateCombinedConfigBlocklistRuleset;

},{"./cookies":24}],24:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var _require = require('./utils'),
  generateRequestDomainsByTrackerDomain = _require.generateRequestDomainsByTrackerDomain,
  getTrackerEntryDomain = _require.getTrackerEntryDomain,
  storeInLookup = _require.storeInLookup;
var COOKIE_PRIORITY = 40000;

/**
 * Build HTTP cookie blocking rules from the blocklist and cookie configuration
 * @param {import('./utils').TDS} tds The tracker blocklist
 * @param {string[]} excludedCookieDomains 3p domains for which we shouldn't block cookies
 * @param {string[]} siteAllowlist Sites on which we shouldn't block 3p cookies
 * @returns {import('./utils').RulesetResult} Cookie blocking rules
 */
function generateCookieBlockingRuleset(tds, excludedCookieDomains, siteAllowlist) {
  var startingRuleId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  /** @type {import('./utils').DNRRule[]} */
  var rules = [];
  /** @type {Map<string, { domains: Set<string>, trackerDomains: Set<string> }>} */
  var entityDomainMapping = new Map();
  /** @type {Map<string, string[]>} */
  var trackerDomainExclusions = new Map();
  /** @type {import('./utils').MatchDetailsByRuleId} */
  var matchDetailsByRuleId = {};
  /**
   * @type {string[]} tracker domains that are part of entities which only have a single domain
   * associated with them. These domains have a simplified same entity rule, which we can
   * implement with the `domainType: thirdParty` rule condition. This allows us to collapse
   * all these domains into a single rule.
   */
  var singleDomainEntityDomains = [];
  // collect CNAMEs for each tracker
  var requestDomainsByTrackerDomain = generateRequestDomainsByTrackerDomain(tds);

  // process exclusions: Find the tracker domain associated with each excluded cookie domain,
  // so that the correct exclusions can be added with each declarativeNetRequest rule.
  var _iterator = _createForOfIteratorHelper(excludedCookieDomains),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var domain = _step.value;
      var trackerEntryDomain = getTrackerEntryDomain(tds.trackers, domain);
      storeInLookup(trackerDomainExclusions, trackerEntryDomain, [domain]);
    }

    // Gather trackers by owner and build the set of owned and owned tracker domains for each
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _loop = function _loop() {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      trackerDomain = _Object$entries$_i[0],
      trackerEntry = _Object$entries$_i[1];
    var mapEntry = entityDomainMapping.get(trackerEntry.owner.name) || {
      domains: new Set(),
      trackerDomains: new Set()
    };
    var _iterator2 = _createForOfIteratorHelper(requestDomainsByTrackerDomain.get(trackerDomain) || []),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var domain = _step2.value;
        mapEntry.domains.add(domain);
        mapEntry.trackerDomains.add(domain);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    tds.entities[trackerEntry.owner.name].domains.forEach(function (d) {
      return mapEntry.domains.add(d);
    });
    entityDomainMapping.set(trackerEntry.owner.name, mapEntry);
  };
  for (var _i = 0, _Object$entries = Object.entries(tds.trackers); _i < _Object$entries.length; _i++) {
    _loop();
  }
  var _iterator3 = _createForOfIteratorHelper(entityDomainMapping.entries()),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
        _step3$value$ = _step3$value[1],
        domains = _step3$value$.domains,
        trackerDomains = _step3$value$.trackerDomains;
      // find if domains are excluded for this entity
      var excludedRequestDomains = [];
      var _iterator4 = _createForOfIteratorHelper(trackerDomains),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _domain = _step4.value;
          if (trackerDomainExclusions.has(_domain)) {
            var _excludedRequestDomai;
            (_excludedRequestDomai = excludedRequestDomains).push.apply(_excludedRequestDomai, _toConsumableArray(trackerDomainExclusions.get(_domain) || []));
          }
        }
        // If this is a single tracker domain entity, put it to the side. We'll generate a single
        // DNR rule for all of these (see description of `singleDomainEntityDomains` for more)
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (domains.size === 1 && trackerDomains.size === 1 && excludedRequestDomains.length === 0) {
        singleDomainEntityDomains.push.apply(singleDomainEntityDomains, _toConsumableArray(domains));
        continue;
      }
      rules.push({
        id: startingRuleId++,
        priority: COOKIE_PRIORITY,
        action: {
          type: 'modifyHeaders',
          requestHeaders: [{
            header: 'cookie',
            operation: 'remove'
          }],
          responseHeaders: [{
            header: 'set-cookie',
            operation: 'remove'
          }]
        },
        condition: {
          requestDomains: Array.from(trackerDomains),
          excludedInitiatorDomains: [].concat(_toConsumableArray(domains), _toConsumableArray(siteAllowlist)),
          excludedRequestDomains: excludedRequestDomains
        }
      });
      matchDetailsByRuleId[startingRuleId] = {
        type: 'cookieBlocking',
        possibleTrackerDomains: Array.from(trackerDomains)
      };
    }
    // create a single rule for all domains which only have 1 domain
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  if (singleDomainEntityDomains.length > 0) {
    rules.push({
      id: ++startingRuleId,
      priority: COOKIE_PRIORITY,
      action: {
        type: 'modifyHeaders',
        requestHeaders: [{
          header: 'cookie',
          operation: 'remove'
        }],
        responseHeaders: [{
          header: 'set-cookie',
          operation: 'remove'
        }]
      },
      condition: {
        requestDomains: singleDomainEntityDomains,
        excludedInitiatorDomains: siteAllowlist,
        domainType: 'thirdParty'
      }
    });
    matchDetailsByRuleId[startingRuleId] = {
      type: 'cookieBlocking',
      possibleTrackerDomains: singleDomainEntityDomains
    };
  }
  return {
    ruleset: rules,
    matchDetailsByRuleId: matchDetailsByRuleId
  };
}
exports.generateCookieBlockingRuleset = generateCookieBlockingRuleset;
exports.COOKIE_PRIORITY = COOKIE_PRIORITY;

},{"./utils":33}],25:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/** @module extensionConfiguration */

var _require = require('./ampProtection'),
  generateAmpProtectionRules = _require.generateAmpProtectionRules;
var _require2 = require('./trackerAllowlist'),
  generateTrackerAllowlistRules = _require2.generateTrackerAllowlistRules;
var _require3 = require('./temporaryAllowlist'),
  generateTemporaryAllowlistRules = _require3.generateTemporaryAllowlistRules;
var _require4 = require('./gpc'),
  generateGPCheaderRules = _require4.generateGPCheaderRules;
var _require5 = require('./trackingParams'),
  generateTrackingParameterRules = _require5.generateTrackingParameterRules;
var _require6 = require('./smarterEncryption'),
  createSmarterEncryptionTemporaryRule = _require6.createSmarterEncryptionTemporaryRule;

/**
 * Generated an extension configuration declarativeNetRequest ruleset.
 * @param {object} extensionConfig
 *   The extension configuration.
 * @param {string[]} denylistedDomains
 *   Domains that the user has specifically denylisted. These domains should be
 *   excluded from any contentBlocking/unprotectedTemporary allowlisting rules.
 * @param {function} isRegexSupported
 *   A function compatible with chrome.declarativeNetRequest.isRegexSupported.
 *   See https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#method-isRegexSupported
 * @param {number} [startingRuleId = 1]
 *   Rule ID for the generated declarativeNetRequest rules to start from. Rule
 *   IDs are incremented sequentially from the starting point.
 * @return {Promise<import('./utils.js').RulesetResult>}
 */
function generateExtensionConfigurationRuleset(_x, _x2, _x3) {
  return _generateExtensionConfigurationRuleset.apply(this, arguments);
}
function _generateExtensionConfigurationRuleset() {
  _generateExtensionConfigurationRuleset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(extensionConfig, denylistedDomains, isRegexSupported) {
    var _extensionConfig$feat, _extensionConfig$feat2, _extensionConfig$feat3;
    var startingRuleId,
      ruleId,
      ruleset,
      matchDetailsByRuleId,
      appendRuleResult,
      _iterator,
      _step,
      result,
      _iterator2,
      _step2,
      _result,
      _iterator3,
      _step3,
      _result2,
      _iterator4,
      _step4,
      _result3,
      _iterator5,
      _step5,
      _result4,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            startingRuleId = _args.length > 3 && _args[3] !== undefined ? _args[3] : 1;
            if (!(typeof isRegexSupported !== 'function')) {
              _context.next = 3;
              break;
            }
            throw new Error('Missing isRegexSupported function.');
          case 3:
            ruleId = startingRuleId;
            ruleset = [];
            /** @type {import('./utils').MatchDetailsByRuleId} */
            matchDetailsByRuleId = {};
            appendRuleResult = function appendRuleResult(result) {
              if (result) {
                var matchDetails = result.matchDetails,
                  rule = result.rule;
                rule.id = ruleId++;
                ruleset.push(rule);
                matchDetailsByRuleId[rule.id] = matchDetails;
              }
            }; // AMP link protection.
            _context.t0 = _createForOfIteratorHelper;
            _context.next = 10;
            return generateAmpProtectionRules(extensionConfig, isRegexSupported);
          case 10:
            _context.t1 = _context.sent;
            _iterator = (0, _context.t0)(_context.t1);
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                result = _step.value;
                appendRuleResult(result);
              }

              // Tracker Allowlist.
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            _iterator2 = _createForOfIteratorHelper(generateTrackerAllowlistRules(extensionConfig));
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _result = _step2.value;
                appendRuleResult(_result);
              }

              // Content Blocking and Unprotected Temporary allowlists.
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            _iterator3 = _createForOfIteratorHelper(generateTemporaryAllowlistRules(extensionConfig, denylistedDomains));
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                _result2 = _step3.value;
                appendRuleResult(_result2);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            _iterator4 = _createForOfIteratorHelper(generateGPCheaderRules(extensionConfig));
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                _result3 = _step4.value;
                appendRuleResult(_result3);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            _iterator5 = _createForOfIteratorHelper(generateTrackingParameterRules(extensionConfig));
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                _result4 = _step5.value;
                appendRuleResult(_result4);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            if (((_extensionConfig$feat = extensionConfig.features) === null || _extensionConfig$feat === void 0 ? void 0 : (_extensionConfig$feat2 = _extensionConfig$feat.https) === null || _extensionConfig$feat2 === void 0 ? void 0 : (_extensionConfig$feat3 = _extensionConfig$feat2.exceptions) === null || _extensionConfig$feat3 === void 0 ? void 0 : _extensionConfig$feat3.length) > 0) {
              appendRuleResult(createSmarterEncryptionTemporaryRule(extensionConfig.features.https.exceptions.map(function (entry) {
                return entry.domain;
              })));
            }
            return _context.abrupt("return", {
              ruleset: ruleset,
              matchDetailsByRuleId: matchDetailsByRuleId
            });
          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _generateExtensionConfigurationRuleset.apply(this, arguments);
}
exports.generateExtensionConfigurationRuleset = generateExtensionConfigurationRuleset;

},{"./ampProtection":22,"./gpc":26,"./smarterEncryption":28,"./temporaryAllowlist":30,"./trackerAllowlist":31,"./trackingParams":32}],26:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/** @module gpc */
var _require = require('./utils'),
  resourceTypes = _require.resourceTypes,
  generateDNRRule = _require.generateDNRRule;
var GPC_HEADER_PRIORITY = 40000;
function generateGPCheaderRules(config) {
  var _config$features, _config$features$gpc, _config$features$gpc$;
  if (((_config$features = config.features) === null || _config$features === void 0 ? void 0 : (_config$features$gpc = _config$features.gpc) === null || _config$features$gpc === void 0 ? void 0 : _config$features$gpc.state) !== 'enabled') {
    return [];
  }
  var allowedDomains = (_config$features$gpc$ = config.features.gpc.exceptions) === null || _config$features$gpc$ === void 0 ? void 0 : _config$features$gpc$.map(function (e) {
    return e.domain;
  });

  // const rule = Object.assign({}, baseHeaderRule)
  var rule = generateDNRRule({
    priority: GPC_HEADER_PRIORITY,
    actionType: 'modifyHeaders',
    requestHeaders: [{
      header: 'Sec-GPC',
      operation: 'set',
      value: '1'
    }],
    resourceTypes: _toConsumableArray(resourceTypes),
    excludedInitiatorDomains: allowedDomains,
    excludedRequestDomains: allowedDomains
  });
  return [{
    matchDetails: {
      type: 'gpc'
    },
    rule: rule
  }];
}
exports.GPC_HEADER_PRIORITY = GPC_HEADER_PRIORITY;
exports.generateGPCheaderRules = generateGPCheaderRules;

},{"./utils":33}],27:[function(require,module,exports){
"use strict";

/** @module rulePriorities */

// Note: Rule priorities for configuration associated rules are kept in the
//       ddg2dnr respective modules. Rule priorities are only added here when
//       there is not a better place to put them.

exports.AD_ATTRIBUTION_POLICY_PRIORITY = 30000;
exports.SERVICE_WORKER_INITIATED_ALLOWING_PRIORITY = 1000000;
exports.USER_ALLOWLISTED_PRIORITY = 1000000;
exports.ATB_PARAM_PRIORITY = 2000000;
exports.NEWTAB_TRACKER_STATS_REDIRECT_PRIORITY = 2000000;

},{}],28:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/** @module smarterEncryption */

var _require = require('./utils'),
  storeInLookup = _require.storeInLookup;
var SMARTER_ENCRYPTION_PRIORITY = 5000;
function generateRegexFilter(subdomainCount, matchWwwSubdomain) {
  return '^http://' + (matchWwwSubdomain ? '(www\\.)?' : '') + Array(subdomainCount).fill('[^.]+').join('\\.') + '(:|/|$)';
}
function generateRule(id, subdomainCount, domains, matchWwwSubdomain) {
  return {
    id: id,
    priority: SMARTER_ENCRYPTION_PRIORITY,
    action: {
      type: 'upgradeScheme'
    },
    condition: {
      resourceTypes: ['main_frame', 'sub_frame', 'stylesheet', 'script', 'image', 'font', 'object', 'xmlhttprequest', 'ping', 'csp_report', 'media', 'websocket', 'webtransport', 'webbundle', 'other'],
      requestDomains: domains,
      regexFilter: generateRegexFilter(subdomainCount, matchWwwSubdomain)
    }
  };
}

/**
 * Converts a list of HTTPS enabled domains into a declarativeNetRequest ruleset
 * that upgrades HTTP requests to HTTPS for those domains.
 * @param {string[]} domains
 *   The domains to include in the ruleset.
 *   Note: Subdomains must be explicitly listed, they are not included by
 *         default.
 * @return {Object[]}
 *   The declarativeNetRequest rules.
 */
function generateSmarterEncryptionRuleset(domains) {
  var startingRuleId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var domainsBySubdomainCount = new Map();
  var domainsWithOptionalWwwBySubdomainCount = new Map();

  // Separate domains with the www. prefix. Many domains are listed both with
  // and without the www subdomain, so it makes sense to combine those entries
  // in the ruleset.
  var domainsToMatchWithWwwPrefix = new Set();
  var nonWwwDomains = [];
  var _iterator = _createForOfIteratorHelper(domains),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _domain = _step.value;
      if (_domain.startsWith('www.')) {
        domainsToMatchWithWwwPrefix.add(_domain.substr(4));
      } else {
        nonWwwDomains.push(_domain);
      }
    }

    // Group the domains by subdomain count. Necessary since requestDomains
    // rule conditions also include all subdomains by default, but that isn't
    // desired here. Each rule has only domains with the same number of
    // subdomains, and a regexFilter is added to prevent matching request
    // domains with a different number of subdomains.
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  for (var _i = 0, _nonWwwDomains = nonWwwDomains; _i < _nonWwwDomains.length; _i++) {
    var domain = _nonWwwDomains[_i];
    if (domainsToMatchWithWwwPrefix.has(domain)) {
      domainsToMatchWithWwwPrefix["delete"](domain);
      storeInLookup(domainsWithOptionalWwwBySubdomainCount, domain.split('.').length, [domain]);
    } else {
      storeInLookup(domainsBySubdomainCount, domain.split('.').length, [domain]);
    }
  }

  // Add any remaining domains with the www. prefix that aren't also seen
  // without the prefix.
  // Note: Arguably these should be matched with or without the www subdomain
  //       too, but that behavior wouldn't be consistent with the
  //       Smarter Encryption feature on other platforms. Doing that
  //       carelessly would also cause problems for edge-cases such as for
  //       the domain "www.pl" - matching the entire "pl" TLD would be a
  //       mistake!
  var _iterator2 = _createForOfIteratorHelper(domainsToMatchWithWwwPrefix),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _domain2 = _step2.value;
      storeInLookup(domainsBySubdomainCount, _domain2.split('.').length + 1, ['www.' + _domain2]);
    }

    // Generate the rules.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var id = startingRuleId;
  var rules = [];
  var _iterator3 = _createForOfIteratorHelper(domainsBySubdomainCount),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
        subdomainCount = _step3$value[0],
        domainGroup = _step3$value[1];
      if (domainGroup.length < 1) {
        continue;
      }
      rules.push(generateRule(id++, subdomainCount, domainGroup, false));
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var _iterator4 = _createForOfIteratorHelper(domainsWithOptionalWwwBySubdomainCount),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _subdomainCount = _step4$value[0],
        _domainGroup = _step4$value[1];
      if (_domainGroup.length < 1) {
        continue;
      }
      rules.push(generateRule(id++, _subdomainCount, _domainGroup, true));
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return rules;
}

/**
 * Create a rule to disable or enable automatic HTTPS upgrades for a set of domains.
 *  - if type is 'allow' this will be an exception rule, preventing upgrades for the given domains.
 *  - if type is 'upgrade' this will be an upgradeScheme rule, causing requests for that domain to be upgraded to HTTPs.
 * @param {string[]} domains
 * @param {'allow' | 'upgrade'} type 'allow' to create an allowlist rule, 'upgrade' to create an upgrade rule
 * @param {number} [id] (optional) rule ID
 * @returns {{
 *  rule: import('./utils.js').DNRRule;
 *  matchDetails: {
 *      type: string;
 *      possibleTrackerDomains?: string[];
 *  };
 *  }}
 */
function createSmarterEncryptionTemporaryRule(domains) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'allow';
  var id = arguments.length > 2 ? arguments[2] : undefined;
  if (['allow', 'upgrade'].indexOf(type) === -1) {
    // invalid type
    throw new Error("createSmarterEncryptionTemporaryRule type ".concat(type, " is not valid"));
  }
  var actionType = type === 'allow' ? 'allow' : 'upgradeScheme';
  var detailsType = type === 'allow' ? 'httpsAllowlist' : 'sessionUpgrades';
  return {
    rule: {
      id: id,
      priority: SMARTER_ENCRYPTION_PRIORITY,
      action: {
        type: actionType
      },
      condition: {
        requestDomains: domains,
        resourceTypes: ['main_frame', 'sub_frame', 'stylesheet', 'script', 'image', 'font', 'object', 'xmlhttprequest', 'ping', 'csp_report', 'media', 'websocket', 'webtransport', 'webbundle', 'other']
      }
    },
    matchDetails: {
      type: detailsType,
      possibleTrackerDomains: domains
    }
  };
}
exports.SMARTER_ENCRYPTION_PRIORITY = SMARTER_ENCRYPTION_PRIORITY;
exports.generateSmarterEncryptionRuleset = generateSmarterEncryptionRuleset;
exports.createSmarterEncryptionTemporaryRule = createSmarterEncryptionTemporaryRule;

},{"./utils":33}],29:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/** @module tds */

var _require = require('./utils'),
  generateDNRRule = _require.generateDNRRule,
  getTrackerEntryDomain = _require.getTrackerEntryDomain,
  storeInLookup = _require.storeInLookup,
  processRegexTrackerRule = _require.processRegexTrackerRule,
  resourceTypes = _require.resourceTypes,
  generateRequestDomainsByTrackerDomain = _require.generateRequestDomainsByTrackerDomain;

// Tracker entry rules with an action starting with this prefix relate to the
// "Click to Load" feature. The feature blocks third-party embedded content, but
// provides the user an option to load the content again. To facilitate that,
// both the blocking/redirecting declarativeNetRequest rules and inverse
// allowing declarativeNetRequest rules are generated.
var clickToLoadActionPrefix = 'block-ctl-';

// Priority that the Tracker Blocking declarativeNetRequest rules start from.
var BASELINE_PRIORITY = 10000;

// Highest possible priority Tracker Blocking declarativeNetRequest rules can
// have. Necessary to ensure that the relative priority between the extension's
// declarativeNetRequest rules can be assured.
var CEILING_PRIORITY = 19999;

// Each time a more specific tracker domain is found, the priority for
// corresponding declarativeNetRequest rules are incremented to ensure that
// longer matching tracker domains match first.
var SUBDOMAIN_PRIORITY_INCREMENT = 100;

// Tracker entry's rules are matched in order, to achieve that the corresponding
// declarativeNetRequest rules are given a descending priority.
var TRACKER_RULE_PRIORITY_INCREMENT = 1;

// Limit the number of tracker entries there can be for a domain, to avoid the
// ceiling priority from being exceeded.
var MAXIMUM_SUBDOMAIN_PRIORITY = CEILING_PRIORITY - CEILING_PRIORITY % SUBDOMAIN_PRIORITY_INCREMENT;

// Limit the additional priority a tracker entry's rules can have, to avoid the
// subdomain priority increment from being exceeded by the tracker rule priority
// increment.
var MAXIMUM_TRACKER_RULE_PRIORITY_INCREMENT = SUBDOMAIN_PRIORITY_INCREMENT - TRACKER_RULE_PRIORITY_INCREMENT;

// The declarativeNetRequest API limits the number of regular expression rules
// that can be added. At the time of writing the limit is 1000. Since some
// further regular expression declarativeNetRequest rules may be required for
// other aspects of the extension, set an arbitrary limit of 900 for
// Tracker Blocking.
// See https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#property-MAX_NUMBER_OF_REGEX_RULES
var MAXIMUM_REGEX_RULES = 900;

// During ruleset generation, the trackerDomain is stored with each
// declarativeNetRequest rule to aid the creation of the trackerDomainByRuleId
// lookup.
var trackerDomainSymbol = Symbol('trackerDomain');

// The special "Click to Load" action for a tracker entry rule is stored with
// each blocking/redirection declarativeNetRequest rule generated for the
// "Click to Load" feature. That way, an inverse allowing rule can be created
// and stored for that action.
var clickToLoadActionSymbol = Symbol('clickToLoadActionSymbol');
function normalizeTypesCondition(types) {
  if (!types || types.length === 0) {
    return [];
  }
  var normalizedTypes = new Set();
  var _iterator = _createForOfIteratorHelper(types),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var type = _step.value;
      switch (type) {
        case 'main_frame':
          // Main frame requests are never blocked as trackers. They are also
          // not blocked by the declarativeNetRequest API by default.
          continue;
        case 'imageset':
          normalizedTypes.add('image');
          break;
        default:
          if (resourceTypes.has(type)) {
            normalizedTypes.add(type);
          } else {
            normalizedTypes.add('other');
          }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return Array.from(normalizedTypes);
}
function normalizeAction(action, defaultAction) {
  if (action === 'ignore') {
    return 'allow';
  }
  if (!action && defaultAction) {
    return defaultAction;
  }
  return action;
}
function normalizeTrackerRule(trackerRule) {
  if (trackerRule instanceof RegExp) {
    return trackerRule.source;
  }
  return trackerRule;
}
function calculateTrackerEntryPriorities(tds) {
  var priorityByTrackerEntryDomain = new Map();
  for (var _i = 0, _Object$keys = Object.keys(tds.trackers); _i < _Object$keys.length; _i++) {
    var domain = _Object$keys[_i];
    // Avoid recalculating the priority for domains.
    if (priorityByTrackerEntryDomain.has(domain)) {
      continue;
    }

    // Search for all the matching tracker entries for this domain.
    var basePriority = BASELINE_PRIORITY;
    var trackerEntryDomains = [domain];
    while (true) {
      var i = domain.indexOf('.');
      if (i === -1) {
        break;
      }
      domain = domain.substr(i + 1);

      // If the priority is already calculated for this match, then start
      // from that. Otherwise, add it to the list and keep checking for
      // more matches.
      if (tds.trackers[domain]) {
        if (priorityByTrackerEntryDomain.has(domain)) {
          basePriority = priorityByTrackerEntryDomain.get(domain) + SUBDOMAIN_PRIORITY_INCREMENT;
          break;
        }
        trackerEntryDomains.push(domain);
      }
    }

    // Assign all the matched tracker domains a priority based on their
    // length, starting from the first previously calculated priority
    // (if any).
    for (var _i2 = trackerEntryDomains.length - 1; _i2 >= 0; _i2--) {
      priorityByTrackerEntryDomain.set(trackerEntryDomains[_i2], basePriority);
      basePriority += SUBDOMAIN_PRIORITY_INCREMENT;
    }
  }
  return priorityByTrackerEntryDomain;
}
function removeRedundantDNRRules(dnrRules) {
  if (!dnrRules || dnrRules.length === 0) {
    return [];
  }
  var _dnrRules$ = dnrRules[0],
    defaultPriority = _dnrRules$.priority,
    defaultAction = _dnrRules$.action.type;
  var rulesToRemoveStartIndex = 1;
  var rulesToRemoveCount = 0;

  // No need to keep declarativeNetRequest rules for the default allow action
  // of tracker entries. Well, assuming that this tracker entry isn't taking
  // priority over another tracker entry.
  if (defaultPriority === BASELINE_PRIORITY && defaultAction === 'allow') {
    rulesToRemoveStartIndex = 0;
    rulesToRemoveCount = 1;
  }

  // No need to keep consecutive declarativeNetRequest rules with the default
  // action.
  for (var i = 1; i < dnrRules.length; i++) {
    if (dnrRules[i].action.type === defaultAction) {
      rulesToRemoveCount++;
    } else {
      break;
    }
  }
  if (rulesToRemoveCount > 0) {
    dnrRules.splice(rulesToRemoveStartIndex, rulesToRemoveCount);
  }
  return dnrRules;
}
function generateDNRRulesForTrackerEntry(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
  return _generateDNRRulesForTrackerEntry.apply(this, arguments);
}
function _generateDNRRulesForTrackerEntry() {
  _generateDNRRulesForTrackerEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(trackerDomain, trackerEntry, requestDomains, excludedInitiatorDomains, priority, isRegexSupported, surrogatePathPrefix, supportedSurrogateScripts) {
    var dnrRules, defaultAction, trackerEntryRules, matchCnames, i, _trackerEntryRules$i, ruleAction, trackerRule, ruleExceptions, ruleOptions, surrogate, clickToLoadAction, _processRegexTrackerR, fallbackUrlFilter, urlFilter, regexFilter, matchCase, _yield$isRegexSupport, isSupported, redirectAction, ruleResourceTypes, initiatorDomains, newRule;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            dnrRules = [];
            if (!(priority > MAXIMUM_SUBDOMAIN_PRIORITY)) {
              _context.next = 3;
              break;
            }
            throw new Error('Too many tracker entries for domain: ' + trackerDomain);
          case 3:
            defaultAction = normalizeAction(trackerEntry["default"]); // Default action is required and must be either 'block' or
            // 'allow' (aka 'ignore').
            if (!(defaultAction !== 'block' && defaultAction !== 'allow')) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", dnrRules);
          case 6:
            trackerEntryRules = trackerEntry.rules || []; // Create the declarativeNetRequest rule for the tracker entry's default
            // action.
            dnrRules.push(generateDNRRule({
              priority: priority,
              actionType: defaultAction,
              requestDomains: requestDomains,
              excludedInitiatorDomains: excludedInitiatorDomains
            }));
            matchCnames = requestDomains.length > 1;
            if (!(trackerEntryRules.length * TRACKER_RULE_PRIORITY_INCREMENT > MAXIMUM_TRACKER_RULE_PRIORITY_INCREMENT)) {
              _context.next = 11;
              break;
            }
            throw new Error('Too many rules for tracker domain:' + trackerDomain);
          case 11:
            i = trackerEntryRules.length - 1;
          case 12:
            if (!(i >= 0)) {
              _context.next = 46;
              break;
            }
            _trackerEntryRules$i = trackerEntryRules[i], ruleAction = _trackerEntryRules$i.action, trackerRule = _trackerEntryRules$i.rule, ruleExceptions = _trackerEntryRules$i.exceptions, ruleOptions = _trackerEntryRules$i.options, surrogate = _trackerEntryRules$i.surrogate;
            ruleAction = normalizeAction(ruleAction, 'block');

            // Handle the special "Click to Load" tracker entry rule actions. They
            // act like other tracker entry rules with the 'block' action, except
            // that their inverse allowing declarativeNetRequest rule is also
            // generated.
            clickToLoadAction = null;
            if (ruleAction.startsWith(clickToLoadActionPrefix)) {
              clickToLoadAction = ruleAction;
              ruleAction = 'block';
            }

            // Only 'block', 'allow' (aka 'ignore') and "Click to Load" tracker
            // entry rule actions are supported.
            if (!(ruleAction !== 'block' && ruleAction !== 'allow')) {
              _context.next = 19;
              break;
            }
            return _context.abrupt("continue", 43);
          case 19:
            trackerRule = normalizeTrackerRule(trackerRule);
            _processRegexTrackerR = processRegexTrackerRule(trackerDomain, trackerRule, matchCnames), fallbackUrlFilter = _processRegexTrackerR.fallbackUrlFilter, urlFilter = _processRegexTrackerR.urlFilter, regexFilter = _processRegexTrackerR.regexFilter, matchCase = _processRegexTrackerR.matchCase; // If the required regular expression is too complex, then go with the
            // fallback urlFilter (if any). If there is no fallback, skip this rule.
            if (!regexFilter) {
              _context.next = 33;
              break;
            }
            _context.next = 24;
            return isRegexSupported({
              regex: regexFilter,
              isCaseSensitive: matchCase
            });
          case 24:
            _yield$isRegexSupport = _context.sent;
            isSupported = _yield$isRegexSupport.isSupported;
            if (isSupported) {
              _context.next = 33;
              break;
            }
            if (!fallbackUrlFilter) {
              _context.next = 32;
              break;
            }
            regexFilter = undefined;
            urlFilter = fallbackUrlFilter;
            _context.next = 33;
            break;
          case 32:
            return _context.abrupt("continue", 43);
          case 33:
            // Handle "surrogate script" redirections.
            redirectAction = null;
            /** @type {import('./utils.js').ResourceType[]|null} */
            ruleResourceTypes = null;
            if (surrogate) {
              ruleResourceTypes = ['script'];
              if (!supportedSurrogateScripts.has(surrogate)) {
                // Block requests if an unsupported surrogate script rule
                // matches.
                ruleAction = 'block';
              } else {
                ruleAction = 'redirect';
                redirectAction = {
                  extensionPath: surrogatePathPrefix + surrogate
                };
              }
            }
            priority += TRACKER_RULE_PRIORITY_INCREMENT;

            // Handle tracker entry rules with 'options'. These rules turn blocking on
            // only for listed domains and types.
            initiatorDomains = null;
            if (ruleOptions && (ruleAction === 'block' || ruleAction === 'redirect')) {
              ruleResourceTypes = normalizeTypesCondition(ruleOptions.types);
              initiatorDomains = ruleOptions.domains;
            }
            newRule = generateDNRRule({
              priority: priority,
              actionType: ruleAction,
              redirect: redirectAction,
              urlFilter: urlFilter,
              regexFilter: regexFilter,
              matchCase: matchCase,
              requestDomains: requestDomains,
              excludedInitiatorDomains: excludedInitiatorDomains,
              initiatorDomains: initiatorDomains,
              resourceTypes: ruleResourceTypes
            });
            if (clickToLoadAction) {
              newRule[clickToLoadActionSymbol] = clickToLoadAction;
            }
            dnrRules.push(newRule);
            if (ruleExceptions && (ruleAction === 'block' || ruleAction === 'redirect')) {
              // Incrementing this priority is not necessary since
              // declarativeNetRequest rules with an 'allow' action trump
              // declarativeNetRequest rules with a 'block'/'redirect' action of
              // the same priority.
              // See https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#matching-algorithm
              dnrRules.push(generateDNRRule({
                priority: priority,
                actionType: 'allow',
                urlFilter: urlFilter,
                regexFilter: regexFilter,
                matchCase: matchCase,
                resourceTypes: normalizeTypesCondition(ruleExceptions.types),
                requestDomains: requestDomains,
                initiatorDomains: ruleExceptions.domains
              }));
            }
          case 43:
            i--;
            _context.next = 12;
            break;
          case 46:
            return _context.abrupt("return", removeRedundantDNRRules(dnrRules));
          case 47:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _generateDNRRulesForTrackerEntry.apply(this, arguments);
}
function finalizeDNRRulesAndLookup(startingRuleId, dnrRules) {
  var ruleIdByByStringifiedDNRRule = new Map();
  var requestDomainsByRuleId = new Map();
  var trackerDomainsByRuleId = new Map();
  /** @type {import('./utils').MatchDetailsByRuleId} */
  var matchDetailsByRuleId = {};
  var allowingRulesByClickToLoadAction = {};

  // Combine similar rules and create the ruleset.
  var ruleset = [];
  var nextRuleId = startingRuleId;
  var _iterator2 = _createForOfIteratorHelper(dnrRules),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var rule = _step2.value;
      // Take note of the rule's trackerDomain.
      var trackerDomain = rule[trackerDomainSymbol];
      delete rule[trackerDomainSymbol];

      // If this is a "Click to Load" blocking/redirecting rule, take note of
      // its inverse allowing rule and "Click to Load" action.
      var clickToLoadAction = rule[clickToLoadActionSymbol];
      delete rule[clickToLoadActionSymbol];
      if (clickToLoadAction) {
        // Create the inverse allowing rule. Note that domainType and
        // excludedInitiatorDomains conditions can be stripped since
        // first-party requests are never blocked anyway.
        var inverseAllowingRule = JSON.parse(JSON.stringify(rule));
        inverseAllowingRule.action.type = 'allow';
        delete inverseAllowingRule.action.redirect;
        delete inverseAllowingRule.condition.domainType;
        delete inverseAllowingRule.condition.excludedInitiatorDomains;
        storeInLookup(allowingRulesByClickToLoadAction, clickToLoadAction, [inverseAllowingRule]);
      }

      // Rules without a requestDomains condition definitely can't be
      // combined. Rules other than basic default allow/block almost never
      // will be in practice. Surrogate script redirection rules and "Click to
      // Load" rules can't be combined since the match details type is
      // different. For those cases just add the rule to the ruleset and match
      // details to the lookup now.
      if (!rule.condition.requestDomains || rule.priority !== BASELINE_PRIORITY || rule.action === 'redirect' || clickToLoadAction) {
        var ruleId = nextRuleId++;
        rule.id = ruleId;
        ruleset.push(rule);
        var matchType = 'trackerBlocking';
        if (clickToLoadAction) {
          matchType = 'clickToLoad';
        } else if (rule.action.type === 'redirect') {
          matchType = 'surrogateScript';
        }
        matchDetailsByRuleId[ruleId] = {
          type: matchType,
          possibleTrackerDomains: [trackerDomain]
        };
        continue;
      }

      // Keep track of rules that (minus requestDomains conditions) have been
      // seen before.
      // Note: This is a simplistic way to generate a key for a
      //       declarativeNetRequest rule, but it works for now.
      var requestDomains = rule.condition.requestDomains;
      delete rule.condition.requestDomains;
      var key = JSON.stringify(rule);
      if (ruleIdByByStringifiedDNRRule.has(key)) {
        // Duplicate rule, note the extra domains.
        var _ruleId = ruleIdByByStringifiedDNRRule.get(key);
        storeInLookup(trackerDomainsByRuleId, _ruleId, [trackerDomain]);
        storeInLookup(requestDomainsByRuleId, _ruleId, requestDomains);
      } else {
        // New rule, add it to the ruleset.
        var _ruleId2 = nextRuleId++;
        rule.id = _ruleId2;

        // Set the rule's request domains. Take care to use a fresh array,
        // so that any mutations don't apply to other rules by accident.
        requestDomains = requestDomains.slice();
        rule.condition.requestDomains = requestDomains;
        ruleset.push(rule);

        // Also update the lookups.
        ruleIdByByStringifiedDNRRule.set(key, _ruleId2);
        storeInLookup(trackerDomainsByRuleId, _ruleId2, [trackerDomain]);
        // Note: Using storeInLookup would create a new array instead of
        //       storing a reference to the existing array. That won't work
        //       since the existing array needs to be mutated to add the
        //       request domains for any duplicate rules.
        requestDomainsByRuleId.set(_ruleId2, requestDomains);
      }
    }

    // Create the ruleId -> matchDetails lookup.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  for (var i = startingRuleId; i < startingRuleId + ruleset.length; i++) {
    // Entry previously added for uncombinable rule.
    if (!trackerDomainsByRuleId.has(i)) {
      continue;
    }
    matchDetailsByRuleId[i] = {
      type: 'trackerBlocking',
      possibleTrackerDomains: trackerDomainsByRuleId.get(i)
    };
  }
  return {
    ruleset: ruleset,
    matchDetailsByRuleId: matchDetailsByRuleId,
    allowingRulesByClickToLoadAction: allowingRulesByClickToLoadAction
  };
}

/**
 * @typedef {object} generateTdsRulesetResult
 * @property {import('./utils.js').DNRRule[]} ruleset
 *   The generated Tracker Blocking declarativeNetRequest ruleset.
 * @property {object} matchDetailsByRuleId
 *   Rule ID -> match details.
 * @property {object} allowingRulesByClickToLoadAction
 *   Inverse allowing declarativeNetRequest rules by "Click to Load" action.
 */

/**
 * Converts a Tracker Blocking configuration into a declarativeNetRequest
 * ruleset that blocks/redirects requests to known trackers.
 * @param {object} tds
 *   The Tracker Blocking configuration.
 * @param {Set<string>} supportedSurrogateScripts
 *   Known surrogate script filenames.
 *   Note: Should not include any path part, only the filename.
 * @param {string} surrogatePathPrefix
 *   The path prefix for surrogate scripts, e.g. '/web_accessible_resources/'.
 * @param {function} isRegexSupported
 *   A function compatible with chrome.declarativeNetRequest.isRegexSupported.
 *   See https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#method-isRegexSupported
 * @param {number} [startingRuleId = 1]
 *   Rule ID for the generated declarativeNetRequest rules to start from. Rule
 *   IDs are incremented sequentially from the starting point.
 * @return {Promise<generateTdsRulesetResult>}
 */
function generateTdsRuleset(_x9, _x10, _x11, _x12) {
  return _generateTdsRuleset.apply(this, arguments);
}
function _generateTdsRuleset() {
  _generateTdsRuleset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tds, supportedSurrogateScripts, surrogatePathPrefix, isRegexSupported) {
    var startingRuleId,
      requestDomainsByTrackerDomain,
      priorityByTrackerDomain,
      regexRuleCount,
      dnrRules,
      _i3,
      _Object$entries,
      _Object$entries$_i,
      trackerDomain,
      trackerEntry,
      requestDomains,
      excludedInitiatorDomains,
      priority,
      trackerRules,
      _iterator3,
      _step3,
      rule,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            startingRuleId = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : 1;
            if (!(_typeof(tds) !== 'object' || _typeof(tds.cnames) !== 'object' || _typeof(tds.domains) !== 'object' || _typeof(tds.entities) !== 'object' || _typeof(tds.trackers) !== 'object')) {
              _context2.next = 3;
              break;
            }
            throw new Error('Invalid block list.');
          case 3:
            if (!(typeof isRegexSupported !== 'function')) {
              _context2.next = 5;
              break;
            }
            throw new Error('Missing isRegexSupported function.');
          case 5:
            requestDomainsByTrackerDomain = generateRequestDomainsByTrackerDomain(tds); // Ensure that tracker entries for more specific (longer) domains are
            // matched first, by giving the corresponding declarativeNetRequest rules
            // for longer domains a higher priority.
            priorityByTrackerDomain = calculateTrackerEntryPriorities(tds); // Generate the declarativeNetRequest rules for the tracker entries.
            regexRuleCount = 0;
            dnrRules = [];
            _i3 = 0, _Object$entries = Object.entries(tds.trackers);
          case 10:
            if (!(_i3 < _Object$entries.length)) {
              _context2.next = 42;
              break;
            }
            _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), trackerDomain = _Object$entries$_i[0], trackerEntry = _Object$entries$_i[1];
            requestDomains = requestDomainsByTrackerDomain.get(trackerDomain);
            if (!(typeof tds.entities[trackerEntry.owner.name] === 'undefined')) {
              _context2.next = 15;
              break;
            }
            return _context2.abrupt("continue", 39);
          case 15:
            excludedInitiatorDomains = tds.entities[trackerEntry.owner.name].domains;
            priority = priorityByTrackerDomain.get(trackerDomain);
            _context2.next = 19;
            return generateDNRRulesForTrackerEntry(trackerDomain, trackerEntry, requestDomains, excludedInitiatorDomains, priority, isRegexSupported, surrogatePathPrefix, supportedSurrogateScripts);
          case 19:
            trackerRules = _context2.sent;
            _iterator3 = _createForOfIteratorHelper(trackerRules);
            _context2.prev = 21;
            _iterator3.s();
          case 23:
            if ((_step3 = _iterator3.n()).done) {
              _context2.next = 31;
              break;
            }
            rule = _step3.value;
            if (!(rule.condition.regexFilter && ++regexRuleCount > MAXIMUM_REGEX_RULES)) {
              _context2.next = 27;
              break;
            }
            throw new Error('Maximum number of regular expression rules exceeded!');
          case 27:
            rule[trackerDomainSymbol] = trackerDomain;
            dnrRules.push(rule);
          case 29:
            _context2.next = 23;
            break;
          case 31:
            _context2.next = 36;
            break;
          case 33:
            _context2.prev = 33;
            _context2.t0 = _context2["catch"](21);
            _iterator3.e(_context2.t0);
          case 36:
            _context2.prev = 36;
            _iterator3.f();
            return _context2.finish(36);
          case 39:
            _i3++;
            _context2.next = 10;
            break;
          case 42:
            return _context2.abrupt("return", finalizeDNRRulesAndLookup(startingRuleId, dnrRules));
          case 43:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[21, 33, 36, 39]]);
  }));
  return _generateTdsRuleset.apply(this, arguments);
}
exports.BASELINE_PRIORITY = BASELINE_PRIORITY;
exports.CEILING_PRIORITY = CEILING_PRIORITY;
exports.SUBDOMAIN_PRIORITY_INCREMENT = SUBDOMAIN_PRIORITY_INCREMENT;
exports.TRACKER_RULE_PRIORITY_INCREMENT = TRACKER_RULE_PRIORITY_INCREMENT;
exports.MAXIMUM_SUBDOMAIN_PRIORITY = MAXIMUM_SUBDOMAIN_PRIORITY;
exports.MAXIMUM_TRACKER_RULE_PRIORITY_INCREMENT = MAXIMUM_TRACKER_RULE_PRIORITY_INCREMENT;
exports.MAXIMUM_REGEX_RULES = MAXIMUM_REGEX_RULES;
exports.getTrackerEntryDomain = getTrackerEntryDomain;
exports.generateDNRRule = generateDNRRule;
exports.generateTdsRuleset = generateTdsRuleset;

},{"./utils":33}],30:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/** @module temporaryAllowlist */

// The contentBlocking allowlist only disables tracker blocking for a website.
var CONTENT_BLOCKING_ALLOWLIST_PRIORITY = 30000;
// The unprotectedTemporary allowlist disables all protections for a website.
var UNPROTECTED_TEMPORARY_ALLOWLIST_PRIORITY = 1000000;
var _require = require('./utils'),
  generateDNRRule = _require.generateDNRRule;

/**
 * @typedef generateTemporaryAllowlistRulesResult
 * @property {import('./utils').DNRRule} rule
 * @property {object} matchDetails
 */

/**
 * Generator to produce the declarativeNetRequest rules and corresponding match
 * details for the unprotectedTemporary and contentBlocking sections of the
 * extension configuration.
 * @param {object} extensionConfiguration
 *   The extension configuration.
 * @return {Generator<generateTemporaryAllowlistRulesResult>}
 */
function generateTemporaryAllowlistRules(_ref, denylistedDomains) {
  var contentBlocking = _ref.features.contentBlocking,
    unprotectedTemporary = _ref.unprotectedTemporary;
  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var denylistedDomainsSet, configs, _i, _configs, _configs$_i, type, priority, entries, _iterator, _step, _step$value, domain, reason, matchDetails, rule;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            denylistedDomainsSet = new Set(denylistedDomains);
            configs = [{
              type: 'unprotectedTemporary',
              priority: UNPROTECTED_TEMPORARY_ALLOWLIST_PRIORITY,
              entries: unprotectedTemporary || []
            }];
            if (contentBlocking && contentBlocking.state === 'enabled') {
              configs.push({
                type: 'contentBlocking',
                priority: CONTENT_BLOCKING_ALLOWLIST_PRIORITY,
                entries: contentBlocking.exceptions || []
              });
            }
            _i = 0, _configs = configs;
          case 4:
            if (!(_i < _configs.length)) {
              _context.next = 30;
              break;
            }
            _configs$_i = _configs[_i], type = _configs$_i.type, priority = _configs$_i.priority, entries = _configs$_i.entries;
            _iterator = _createForOfIteratorHelper(entries);
            _context.prev = 7;
            _iterator.s();
          case 9:
            if ((_step = _iterator.n()).done) {
              _context.next = 19;
              break;
            }
            _step$value = _step.value, domain = _step$value.domain, reason = _step$value.reason;
            if (!denylistedDomainsSet.has(domain)) {
              _context.next = 13;
              break;
            }
            return _context.abrupt("continue", 17);
          case 13:
            matchDetails = {
              type: type,
              domain: domain,
              reason: reason
            };
            rule = generateDNRRule({
              priority: priority,
              actionType: 'allowAllRequests',
              requestDomains: [domain],
              resourceTypes: ['main_frame']
            });
            _context.next = 17;
            return {
              rule: rule,
              matchDetails: matchDetails
            };
          case 17:
            _context.next = 9;
            break;
          case 19:
            _context.next = 24;
            break;
          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](7);
            _iterator.e(_context.t0);
          case 24:
            _context.prev = 24;
            _iterator.f();
            return _context.finish(24);
          case 27:
            _i++;
            _context.next = 4;
            break;
          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 21, 24, 27]]);
  })();
}
exports.CONTENT_BLOCKING_ALLOWLIST_PRIORITY = CONTENT_BLOCKING_ALLOWLIST_PRIORITY;
exports.UNPROTECTED_TEMPORARY_ALLOWLIST_PRIORITY = UNPROTECTED_TEMPORARY_ALLOWLIST_PRIORITY;
exports.generateTemporaryAllowlistRules = generateTemporaryAllowlistRules;

},{"./utils":33}],31:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/** @module trackerAllowlist */

var _require = require('./utils'),
  processPlaintextTrackerRule = _require.processPlaintextTrackerRule,
  storeInLookup = _require.storeInLookup,
  generateDNRRule = _require.generateDNRRule,
  getTrackerEntryDomain = _require.getTrackerEntryDomain;

// Priority that the Tracker Blocking Allowlist declarativeNetRequest rules
// start from.
var BASELINE_PRIORITY = 20000;
var PRIORITY_INCREMENT = 1;

// Highest possible priority Tracker Blocking Allowlist declarativeNetRequest
// rules can have.
// Note: Limited to 100 in order to be consistent with Tracker Blocking.
var CEILING_PRIORITY = 20100;
var MAXIMUM_RULES_PER_TRACKER_ENTRY = (CEILING_PRIORITY - BASELINE_PRIORITY) / PRIORITY_INCREMENT;

/**
 * @typedef generateTrackerAllowlistRulesResult
 * @property {import('./utils').DNRRule} rule
 * @property {object} matchDetails
 */

/**
 * Generator to produce the declarativeNetRequest rules and corresponding match
 * details for the given trackerAllowlist configuration.
 * @param {object} extensionConfiguration
 *   The extension configuration.
 * @return {Generator<generateTrackerAllowlistRulesResult>}
 */
function generateTrackerAllowlistRules(_ref) {
  var trackerAllowlist = _ref.features.trackerAllowlist;
  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var allowlistedTrackers, excludedRequestDomainsByTrackerEntry, _i, _Object$keys, trackerDomain, currentTrackerDomain, _i2, _Object$entries, _Object$entries$_i, _trackerDomain, trackerEntry, trackerEntryRules, requestDomains, excludedRequestDomains, priority, i, _trackerEntryRules$i, trackerRule, initiatorDomains, allowlistReason, _processPlaintextTrac, urlFilter, matchCase, rule, matchDetails;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(!trackerAllowlist || trackerAllowlist.state !== 'enabled' || !trackerAllowlist.settings || !trackerAllowlist.settings.allowlistedTrackers || trackerAllowlist.settings.allowlistedTrackers.length === 0)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            allowlistedTrackers = trackerAllowlist.settings.allowlistedTrackers; // Tracker Blocking Allowlist entries have no default action. If no rules
            // match for a matching entry, then no allowlist entries should apply. Avoid
            // an allowlist entry for a less-specific domain from applying in that
            // situation.
            excludedRequestDomainsByTrackerEntry = new Map();
            for (_i = 0, _Object$keys = Object.keys(allowlistedTrackers); _i < _Object$keys.length; _i++) {
              trackerDomain = _Object$keys[_i];
              /** @type {string|null} */
              currentTrackerDomain = trackerDomain;
              while (currentTrackerDomain) {
                currentTrackerDomain = getTrackerEntryDomain(allowlistedTrackers, currentTrackerDomain, 1);
                if (currentTrackerDomain) {
                  storeInLookup(excludedRequestDomainsByTrackerEntry, currentTrackerDomain, [trackerDomain]);
                }
              }
            }
            _i2 = 0, _Object$entries = Object.entries(allowlistedTrackers);
          case 6:
            if (!(_i2 < _Object$entries.length)) {
              _context.next = 32;
              break;
            }
            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), _trackerDomain = _Object$entries$_i[0], trackerEntry = _Object$entries$_i[1];
            trackerEntryRules = trackerEntry.rules;
            if (!(!trackerEntryRules || trackerEntryRules.length === 0)) {
              _context.next = 11;
              break;
            }
            return _context.abrupt("continue", 29);
          case 11:
            if (!(trackerEntryRules.length > MAXIMUM_RULES_PER_TRACKER_ENTRY)) {
              _context.next = 13;
              break;
            }
            throw new Error('Too many allowlist rules for tracker domain: ' + _trackerDomain);
          case 13:
            requestDomains = [_trackerDomain];
            excludedRequestDomains = excludedRequestDomainsByTrackerEntry.get(_trackerDomain); // Iterate through the tracker entry's rules backwards, since rules for
            // a tracker entry are matched in order and therefore the corresponding
            // declarativeNetRequest rules should have descending priority.
            priority = BASELINE_PRIORITY;
            i = trackerEntryRules.length - 1;
          case 17:
            if (!(i >= 0)) {
              _context.next = 29;
              break;
            }
            _trackerEntryRules$i = trackerEntryRules[i], trackerRule = _trackerEntryRules$i.rule, initiatorDomains = _trackerEntryRules$i.domains, allowlistReason = _trackerEntryRules$i.reason; // Tracker Blocking Allowlist entries always have an initiator
            // domains condition, but if it's `['<all>']` it must be ignored.
            if (initiatorDomains.length === 0 || initiatorDomains[0] === '<all>') {
              initiatorDomains = null;
            }
            _processPlaintextTrac = processPlaintextTrackerRule(_trackerDomain, trackerRule), urlFilter = _processPlaintextTrac.urlFilter, matchCase = _processPlaintextTrac.matchCase;
            rule = generateDNRRule({
              priority: priority,
              actionType: 'allow',
              urlFilter: urlFilter,
              matchCase: matchCase,
              requestDomains: requestDomains,
              excludedRequestDomains: excludedRequestDomains,
              initiatorDomains: initiatorDomains
            });
            matchDetails = {
              type: 'trackerAllowlist',
              domain: _trackerDomain,
              reason: allowlistReason
            };
            _context.next = 25;
            return {
              rule: rule,
              matchDetails: matchDetails
            };
          case 25:
            priority += PRIORITY_INCREMENT;
          case 26:
            i--;
            _context.next = 17;
            break;
          case 29:
            _i2++;
            _context.next = 6;
            break;
          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })();
}
exports.BASELINE_PRIORITY = BASELINE_PRIORITY;
exports.PRIORITY_INCREMENT = PRIORITY_INCREMENT;
exports.CEILING_PRIORITY = CEILING_PRIORITY;
exports.MAXIMUM_RULES_PER_TRACKER_ENTRY = MAXIMUM_RULES_PER_TRACKER_ENTRY;
exports.generateTrackerAllowlistRules = generateTrackerAllowlistRules;

},{"./utils":33}],32:[function(require,module,exports){
"use strict";

/** @module trackingParams */
var _require = require('./utils'),
  generateDNRRule = _require.generateDNRRule;
var TRACKING_PARAM_PRIORITY = 40000;
function generateTrackingParameterRules(config) {
  var _config$features, _config$features$trac, _config$features$trac2, _config$features$trac3, _config$features$trac4;
  if (((_config$features = config.features) === null || _config$features === void 0 ? void 0 : (_config$features$trac = _config$features.trackingParameters) === null || _config$features$trac === void 0 ? void 0 : _config$features$trac.state) !== 'enabled') {
    return [];
  }
  var allowedDomains = (_config$features$trac2 = config.features.trackingParameters.exceptions) === null || _config$features$trac2 === void 0 ? void 0 : _config$features$trac2.map(function (e) {
    return e.domain;
  });

  // Skip any wildcard or regex parameters, we can't support these in MV3
  var trackingParams = (_config$features$trac3 = config.features.trackingParameters.settings) === null || _config$features$trac3 === void 0 ? void 0 : (_config$features$trac4 = _config$features$trac3.parameters) === null || _config$features$trac4 === void 0 ? void 0 : _config$features$trac4.filter(function (param) {
    return !param.match(/[*+?{}[\]]/, 'g');
  });
  if (!trackingParams) {
    return [];
  }
  var rule = generateDNRRule({
    priority: TRACKING_PARAM_PRIORITY,
    actionType: 'redirect',
    redirect: {
      transform: {
        queryTransform: {
          removeParams: trackingParams
        }
      }
    },
    resourceTypes: ['main_frame'],
    excludedRequestDomains: allowedDomains
  });
  return [{
    matchDetails: {
      type: 'trackingParams'
    },
    rule: rule
  }];
}
exports.TRACKING_PARAM_PRIORITY = TRACKING_PARAM_PRIORITY;
exports.generateTrackingParameterRules = generateTrackingParameterRules;

},{"./utils":33}],33:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/** @module utils */

/**
 * @typedef {import('@duckduckgo/privacy-grade/src/classes/trackers.js').TrackerObj} TrackerObj
 * @typedef {{
 *  domains: string[];
 *  prevalence: number;
 *  displayName: string;
 * }} Entity
 * @typedef {{
 *  trackers: Record<string, TrackerObj>;
 *  entities: Record<string, Entity>;
 *  cnames: Record<string, string>;
 * }} TDS
 */

/**
 * @typedef {{
 *   domain: string;
 *   reason: string
 * }} PrivacyConfigDomainEntry
 */
/**
 * @typedef {object} PrivacyConfigFeature
 * @property {string} state
 * @property {string | undefined} minSupportedVersion
 * @property {string} hash
 * @property {S} settings
 * @property {PrivacyConfigDomainEntry[]} exceptions
 * @template S
 */
/**
 * @typedef {object} PrivacyConfiguration
 * @property {PrivacyConfigDomainEntry[]} unprotectedTemporary
 * @property {{
 *  cookie?: PrivacyConfigFeature<{
 *      trackerCookie: string;
 *      nonTrackerCookie: string;
 *      excludedCookieDomains: PrivacyConfigDomainEntry[];
 *  }>
 * }} features
 */
/**
 * @typedef {{[ruleId: number]: {
 *   type: string;
 *   possibleTrackerDomains?: string[];
 *   domain?: string;
 *   reason?: string;
 * }}} MatchDetailsByRuleId
*/
/**
 * @typedef RulesetResult
 * @property {import('./utils.js').DNRRule[]} ruleset
 *   The generated Tracker Blocking declarativeNetRequest ruleset.
 * @property {MatchDetailsByRuleId} matchDetailsByRuleId
 *   Rule ID -> match details.
 */

/**
 * Unfortunately it's a little tricky to interact with TypeScript Enum types
 * from JavaScript code, assigning the literal value (even if valid) results in
 * a type coercion error. As a workaround, use the backtick syntax to get the
 * possible enum values and then use those values to declare new types.
 * Hopefully, interacting with Enums will get easier in the future and this can
 * be removed.
 * @typedef {`${chrome.declarativeNetRequest.DomainType}`} DomainType
 * @typedef {`${chrome.declarativeNetRequest.RequestMethod}`} RequestMethod
 * @typedef {`${chrome.declarativeNetRequest.ResourceType}` |
 *           'webbundle' | 'webtransport'} ResourceType
 * @typedef {`${chrome.declarativeNetRequest.RuleActionType}`} DNRRuleActionType
 * @typedef {Omit<chrome.declarativeNetRequest.RuleAction,
 *                'type' | 'redirect' | 'requestHeaders' | 'responseHeaders'> &
 *           {type: DNRRuleActionType, redirect?: object,
 *            requestHeaders?: object, responseHeaders?: object}} DNRRuleAction
 * @typedef {Omit<chrome.declarativeNetRequest.RuleCondition,
 *               'domainType' | 'excludedRequestMethods' |
 *               'excludedResourceTypes' | 'requestMethods' |
 *               'resourceTypes'> &
 *           {domainType?: DomainType, excludedRequestMethods?: RequestMethod[],
 *            excludedResourceTypes?: ResourceType[],
 *            requestMethods?: RequestMethod[],
 *            resourceTypes?: ResourceType[]}} DNRRuleCondition
 * @typedef {Omit<chrome.declarativeNetRequest.Rule,
 *                'id' | 'action' | 'condition'> &
 *           {id?: number, action: DNRRuleAction,
 *            condition: DNRRuleCondition}} DNRRule
 */

// Tracker entries that 1. match cnames and 2. have rules that are anchored to
// the tracker domain, will not match correctly using a urlFilter. As a
// workaround, it is sometimes possible to instead use a regexFilter (in
// combination with the requestDomains condition) that matches any domain, while
// still anchoring the rest of the rule to the domain correctly.
var cnameDomainAnchor = '[a-z]+://[^/?]*';
var cnameDomainAnchorCompatibleRuleSuffix = /^(:[0-9]+)?[/?]/;

// Characters that indicate a tracker rule needs to be treated as a regular
// expression (rather than a URL filter).
// Note: This is not perfect, but good enough for now to avoid using regexFilter
//       unless needed. In the future improvements could be made (e.g. by
//       ignoring a closing ']' unless an opening '[' was already seen).
var regularExpressionChars = new Set(['.', '*', '+', '?', '{', '}', '[', ']', '{', '}']);
function storeInMapLookup(lookup, key, values) {
  var storedValues = lookup.get(key);
  if (!storedValues) {
    storedValues = [];
    lookup.set(key, storedValues);
  }
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      storedValues.push(value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function storeInObjectLookup(lookup, key, values) {
  var storedValues = lookup[key];
  if (!storedValues) {
    storedValues = [];
    lookup[key] = storedValues;
  }
  var _iterator2 = _createForOfIteratorHelper(values),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var value = _step2.value;
      storedValues.push(value);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}

/**
 * Stores the given values in the given lookup for the given key. Takes care to
 * create the values array for the key if it doesn't already exist. Handles both
 * Maps and raw Objects.
 * Note: If lookup is a raw Object, the key will be treated as a string. Provide
 *       a string for such keys, or a value that can be sensibly converted to
 *       one.
 * @param {Map|Object} lookup
 * @param {any} key
 * @param {any[]} values
 */
function storeInLookup(lookup, key, values) {
  if (lookup instanceof Map) {
    storeInMapLookup(lookup, key, values);
  } else {
    storeInObjectLookup(lookup, key, values);
  }
}

/**
 * @typedef {object} generateDNRRuleDetails
 * @property {number} [id]
 * @property {number} priority
 * @property {DNRRuleActionType} actionType
 * @property {object} [redirect]
 * @property {object[]} [requestHeaders]
 * @property {object[]} [responseHeaders]
 * @property {string} [urlFilter]
 * @property {string} [regexFilter]
 * @property {ResourceType[] | null} [resourceTypes]
 * @property {ResourceType[] | null} [excludedResourceTypes]
 * @property {string[]} [requestDomains]
 * @property {string[]} [excludedRequestDomains]
 * @property {string[]} [initiatorDomains]
 * @property {string[]} [excludedInitiatorDomains]
 * @property {boolean} [matchCase]
 * @property {number[]} [tabIds]
 * @property {number[]} [excludedTabIds]
 * @property {RequestMethod[]} [requestMethods]
 * @property {RequestMethod[]} [excludedRequestMethods]
 */

/**
 * Generates a declarativeNetRequest rule with the given details.
 * @param {generateDNRRuleDetails} ruleDetails
 * @return {DNRRule}
 */
function generateDNRRule(_ref) {
  var id = _ref.id,
    priority = _ref.priority,
    actionType = _ref.actionType,
    redirect = _ref.redirect,
    requestHeaders = _ref.requestHeaders,
    responseHeaders = _ref.responseHeaders,
    urlFilter = _ref.urlFilter,
    regexFilter = _ref.regexFilter,
    resourceTypes = _ref.resourceTypes,
    excludedResourceTypes = _ref.excludedResourceTypes,
    requestDomains = _ref.requestDomains,
    excludedRequestDomains = _ref.excludedRequestDomains,
    initiatorDomains = _ref.initiatorDomains,
    excludedInitiatorDomains = _ref.excludedInitiatorDomains,
    _ref$matchCase = _ref.matchCase,
    matchCase = _ref$matchCase === void 0 ? false : _ref$matchCase,
    tabIds = _ref.tabIds,
    excludedTabIds = _ref.excludedTabIds,
    requestMethods = _ref.requestMethods,
    excludedRequestMethods = _ref.excludedRequestMethods;
  /** @type {DNRRule} */
  var dnrRule = {
    priority: priority,
    action: {
      type: actionType
    },
    condition: {}
  };
  if (typeof id === 'number') {
    dnrRule.id = id;
  }
  if (requestDomains && requestDomains.length > 0) {
    dnrRule.condition.requestDomains = requestDomains;
  }
  if (actionType === 'redirect' && redirect) {
    dnrRule.action.redirect = redirect;
  }
  if (actionType === 'modifyHeaders') {
    if (requestHeaders && requestHeaders.length > 0) {
      dnrRule.action.requestHeaders = requestHeaders;
    }
    if (responseHeaders && responseHeaders.length > 0) {
      dnrRule.action.responseHeaders = responseHeaders;
    }
  }
  if (urlFilter) {
    dnrRule.condition.urlFilter = urlFilter;

    // If the URL filter is anchored to a domain anyway, then additional
    // (included) request domain conditions don't serve a purpose.
    // Note: This is only a safe assumption since (so far) requestDomains
    //       never contain a subdomain of the domain in the URL filter. That
    //       is since:
    //         1. the domain in the URL filter is always the tracker entry's
    //            domain
    //         2. cname entries never map to a subdomain of the same tracker
    if (urlFilter[0] === '|' && urlFilter[1] === '|') {
      delete dnrRule.condition.requestDomains;
    }
    if (!matchCase) {
      dnrRule.condition.isUrlFilterCaseSensitive = false;
    }
  } else if (regexFilter) {
    dnrRule.condition.regexFilter = regexFilter;
    if (!matchCase) {
      dnrRule.condition.isUrlFilterCaseSensitive = false;
    }
  }
  if (resourceTypes && resourceTypes.length > 0) {
    dnrRule.condition.resourceTypes = resourceTypes;
  }
  if (excludedResourceTypes && excludedResourceTypes.length > 0) {
    dnrRule.condition.excludedResourceTypes = excludedResourceTypes;
  }
  if (initiatorDomains && initiatorDomains.length > 0) {
    dnrRule.condition.initiatorDomains = initiatorDomains;
  }
  if (excludedRequestDomains && excludedRequestDomains.length > 0) {
    dnrRule.condition.excludedRequestDomains = excludedRequestDomains;
  }

  // Note: It's not necessary to exclude initiator domains for allowing rules
  //       since first-party requests will be allowed anyway.
  if (excludedInitiatorDomains && excludedInitiatorDomains.length > 0 && actionType !== 'allow') {
    if (excludedInitiatorDomains.length === 1 && requestDomains && requestDomains.length === 1) {
      // Assume that if only one initiator domain is excluded (and there
      // is only one request domain), that the excluded initiator domain
      // is the same as the request domain.
      dnrRule.condition.domainType = 'thirdParty';
    } else {
      dnrRule.condition.excludedInitiatorDomains = excludedInitiatorDomains;
    }
  }
  if (tabIds && tabIds.length > 0) {
    dnrRule.condition.tabIds = tabIds;
  }
  if (excludedTabIds && excludedTabIds.length > 0) {
    dnrRule.condition.excludedTabIds = excludedTabIds;
  }
  if (requestMethods && requestMethods.length > 0) {
    dnrRule.condition.requestMethods = requestMethods;
  }
  if (excludedRequestMethods && excludedRequestMethods.length > 0) {
    dnrRule.condition.excludedRequestMethods = excludedRequestMethods;
  }
  return dnrRule;
}
function alphaChar(charCode) {
  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
}
function parseRegexTrackerRule(domain, trackerRule) {
  var requiresRegexFilter = false;
  var urlFilter = '';
  var afterDomainRuleIndex = -1;
  var lastAlphaIndex = -1;
  var escaped = false;
  var previousCharWasPeriod = false;
  for (var i = 0; i < trackerRule.length; i++) {
    var _char = trackerRule[i];
    var charCode = _char.charCodeAt(0);
    if (domain && urlFilter.length === domain.length && afterDomainRuleIndex === -1) {
      // Store the index in the trackerRule that corresponds to the first
      // character after the domain part. That is assuming the rule is
      // prefixed with the domain part... that is verified later.
      afterDomainRuleIndex = i;
    }
    if (escaped) {
      // Matching (only) a '*' literal in a urlFilter does not seem to be
      // possible. (Tested as of Chromium M101.)
      if (_char === '*') {
        requiresRegexFilter = true;
        continue;
      }
      if (alphaChar(charCode)) {
        lastAlphaIndex = i;
      }
      escaped = false;
      urlFilter += _char;
      continue;
    }
    if (_char === '\\') {
      escaped = true;
      continue;
    }
    if (_char === '.') {
      previousCharWasPeriod = true;
      continue;
    }
    if (_char === '*' && previousCharWasPeriod) {
      urlFilter += '*';
      previousCharWasPeriod = false;
      continue;
    }
    if (regularExpressionChars.has(_char) || previousCharWasPeriod) {
      requiresRegexFilter = true;
      continue;
    }
    if (alphaChar(charCode)) {
      lastAlphaIndex = i;
    }
    urlFilter += _char;
  }
  if (previousCharWasPeriod) {
    requiresRegexFilter = true;
  }
  return {
    requiresRegexFilter: requiresRegexFilter,
    urlFilter: urlFilter,
    afterDomainRuleIndex: afterDomainRuleIndex,
    lastAlphaIndex: lastAlphaIndex
  };
}

/**
 * @typedef processRegexTrackerRuleResult
 * @property {string} [urlFilter]
 *   declarativeNetRequest urlFilter condition necessary to match this rule.
 * @property {string} [regexFilter]
 *   declarativeNetRequest regexFilter condition necessary to match this rule.
 * @property {string} [fallbackUrlFilter]
 *   A suboptimal urlFilter condition that can be used as a fallback if the
 *   provided regexFilter is not supported by the declarativeNetRequest API.
 * @property {boolean} [matchCase]
 *   False if case insensitive matching is required for this rule.
 */

/**
 * Figure out the declarativeNetRequest urlFilter or regexFilter (if any)
 * necessary for matching the given regular expression tracker rule.
 * @param {string|null} domain
 *   The tracker entry's domain, or null if unknown.
 * @param {string} trackerRule
 *   The tracker entry's rule (regular expression string).
 * @param {boolean} matchCnames
 *   If cname matching is necessary for this rule.
 * @return {processRegexTrackerRuleResult}
 */
function processRegexTrackerRule(domain, trackerRule, matchCnames) {
  // If the tracker rule is empty, then neither urlFilter nor regexFilter are
  // necessary.
  if (!trackerRule) {
    return {};
  }
  var _parseRegexTrackerRul = parseRegexTrackerRule(domain, trackerRule),
    requiresRegexFilter = _parseRegexTrackerRul.requiresRegexFilter,
    urlFilter = _parseRegexTrackerRul.urlFilter,
    afterDomainRuleIndex = _parseRegexTrackerRul.afterDomainRuleIndex,
    lastAlphaIndex = _parseRegexTrackerRul.lastAlphaIndex;
  var regexFilter = trackerRule;
  var matchCase = false;
  var usedRegexForWorkaround = false;
  if (domain && urlFilter.startsWith(domain)) {
    // If the the urlFilter is the same length as the domain, then the
    // strings are equal (since the urlFilter starts with the domain).
    // Neither urlFilter nor regexFilter are necessary.
    if (urlFilter.length === domain.length) {
      return {};
    }

    // Ignore the domain when considering if the rule needs to be matched
    // case sensitively.
    matchCase = lastAlphaIndex < afterDomainRuleIndex;
    if (urlFilter[domain.length] === '*') {
      // If the urlFilter is longer than the domain, but the next
      // character after the domain is a wildcard, the domain part +
      // wildcard can be safely removed. That is since the domain part of
      // a urlFilter only serves to anchor the filter against the start of
      // the URL's path (thanks to requestDomains conditions).
      // Note: Remove an extra character from the regexFilter, since the
      //       wild-card for a regular expression is '.*' rather than just
      //       '*'.
      regexFilter = regexFilter.substr(afterDomainRuleIndex + 2);
      urlFilter = urlFilter.substr(domain.length + 1);
    } else {
      // If the pattern needs to be anchored to the domain, and cname
      // matching is required, then a regexFilter is necessary to anchor
      // the rest of the filter to the request domain.
      // Note: This workaround only works if there is a '/' or '?'
      //       character directly after the domain (or port) part of the
      //       rule.
      if (matchCnames && afterDomainRuleIndex > -1 && cnameDomainAnchorCompatibleRuleSuffix.test(urlFilter.substr(domain.length))) {
        usedRegexForWorkaround = true;
        regexFilter = cnameDomainAnchor + trackerRule.substr(afterDomainRuleIndex);
      }

      // Prepend the '||' urlFilter domain anchor to improve matching
      // performance.
      urlFilter = '||' + urlFilter;
    }
  } else {
    // If there isn't a (known) domain part, then case sensitive matching
    // can only happen if there were no alpha characters.
    matchCase = lastAlphaIndex === -1;
  }
  if (requiresRegexFilter) {
    return {
      regexFilter: regexFilter,
      matchCase: matchCase
    };
  }

  // The regular expression will sometimes be too complex (long) for a
  // declarativeNetRequest rule. Provide the urlFilter as a fallback, but note
  // that cnames will not be matched correctly by the urlFilter.
  if (usedRegexForWorkaround) {
    return {
      regexFilter: regexFilter,
      matchCase: matchCase,
      fallbackUrlFilter: urlFilter
    };
  }
  return {
    urlFilter: urlFilter,
    matchCase: matchCase
  };
}

/**
 * @typedef processPlaintextTrackerRuleResult
 * @property {string} urlFilter
 *   declarativeNetRequest urlFilter condition necessary to match this rule.
 * @property {boolean} matchCase
 *   False if case insensitive matching is required for this rule.
 */

/**
 * Figure out the declarativeNetRequest urlFilter necessary for matching the
 * given plain-text tracker rule.
 * @param {string|null} domain
 *   The tracker entry's domain, or null if unknown.
 * @param {string} trackerRule
 *   The tracker entry's rule (literal string to match).
 * @return {processPlaintextTrackerRuleResult}
 */
function processPlaintextTrackerRule(domain, trackerRule) {
  var urlFilter = trackerRule;
  if (domain && urlFilter.startsWith(domain)) {
    urlFilter = '||' + urlFilter;
  }

  // Note: In the future it would be nice to avoid case-insensitive matching
  //       unless necessary. The logic to do that could potentially be shared
  //       with processRegexTrackerRule.
  var matchCase = false;
  return {
    urlFilter: urlFilter,
    matchCase: matchCase
  };
}

/**
 * Finds the closest matching tracker entry for the given domain. Returns the
 * tracking domain if one is found, null otherwise.
 * @param {Record<string, import('./utils.js').TrackerObj>} trackerEntries
 *   The trackers section of the Tracker Blocking configuration.
 * @param {string} domain
 *   The domain to search for. Subdomains will be stripped away until a matching
 *   tracker domain is found, or there are no more subdomains left.
 *   Note: Can optionally contain the "." prefix that is sometimes given for
 *         cname domain entries in the configuration.
 * @param {number} [skipSubdomains = 0]
 *   The number of subdomains to skip. Useful when checking if the given domain
 *   has further less-specific tracking entries that would have matched.
 * @return {string|null}
 *   The closest-matching (skipped subdomains allowing) tracking domain, or null
 *   if none are found.
 */
function getTrackerEntryDomain(trackerEntries, domain) {
  var skipSubdomains = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  // Strip leading '.' in cname entries, nothing otherwise.
  var i = domain[0] === '.' ? 0 : -1;
  do {
    domain = domain.substr(i + 1);
    i = domain.indexOf('.');
    if (skipSubdomains > 0) {
      skipSubdomains -= 1;
      continue;
    }
    var trackerEntry = trackerEntries[domain];
    if (trackerEntry) {
      return domain;
    }
  } while (i > -1);
  return null;
}

/**
 * Generate a mapping from tracker domain to a list of related aliases (via CNAME) as well as itself
 * @param {TDS} tds Tracker blocklist
 * @returns {Map<string, string[]>} domain mapping
 */
function generateRequestDomainsByTrackerDomain(tds) {
  var requestDomainsByTrackerDomain = new Map();
  // Create a lookup of each tracker entry's domain, that matching cname
  // entries will be added to.
  for (var _i = 0, _Object$keys = Object.keys(tds.trackers); _i < _Object$keys.length; _i++) {
    var trackerDomain = _Object$keys[_i];
    storeInLookup(requestDomainsByTrackerDomain, trackerDomain, [trackerDomain]);
  }
  for (var _i2 = 0, _Object$entries = Object.entries(tds.cnames); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
      domain = _Object$entries$_i[0],
      cname = _Object$entries$_i[1];
    // Find the appropriate tracker entry that the cname entry should apply
    // to.
    var trackerEntryDomain = getTrackerEntryDomain(tds.trackers, cname);
    if (trackerEntryDomain) {
      // There are some difficult edge-cases when the subdomain of a cname
      // entry has its own tracker entry. Requests are first checked
      // against the tracker entry, before the cname entry. Worse still,
      // if a rule matches the tracker entry and has the action of block,
      // the request will still be allowed (due to being first-party) even
      // if there's also a cname entry rule to block the request.
      // Therefore, for now skip cname mapping if there is a parent
      // tracker entry.
      // See https://github.com/duckduckgo/privacy-grade/blob/4d28937/src/classes/trackers.js#L111-L125
      if (getTrackerEntryDomain(tds.trackers, domain, 1)) {
        continue;
      }

      // Strictly speaking, the domain should also be added to the
      // excluded initiator domains for the corresponding tracker entry's
      // entity. In practice however, this makes no difference and adds
      // significantly to the ruleset size.

      // Ensure that the cname is added to included request domains for
      // the matching tracker entry.
      storeInLookup(requestDomainsByTrackerDomain, trackerEntryDomain, [domain]);
    }
  }
  return requestDomainsByTrackerDomain;
}

/** @type Set<ResourceType> */
var resourceTypes = new Set(['main_frame', 'sub_frame', 'stylesheet', 'script', 'image', 'font', 'object', 'xmlhttprequest', 'ping', 'csp_report', 'media', 'websocket', 'webtransport', 'webbundle', 'other']);
exports.resourceTypes = resourceTypes;
exports.storeInLookup = storeInLookup;
exports.generateDNRRule = generateDNRRule;
exports.processRegexTrackerRule = processRegexTrackerRule;
exports.processPlaintextTrackerRule = processPlaintextTrackerRule;
exports.getTrackerEntryDomain = getTrackerEntryDomain;
exports.generateRequestDomainsByTrackerDomain = generateRequestDomainsByTrackerDomain;

},{}],34:[function(require,module,exports){
"use strict";

module.exports = {
  Grade: require('./src/classes/grade'),
  Trackers: require('./src/classes/trackers')
};

},{"./src/classes/grade":35,"./src/classes/trackers":36}],35:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var UNKNOWN_PRIVACY_SCORE = 2;

/**
 * Range map data structures:
 *
 * Maps a numeric input to an arbitrary output based on provided ranges
 *
 * `steps` defines the range of inputs for each output,
 * `max` defines what happens if the input is above the given ranges
 * `zero` is a special case for when the input is 0 or falsy
 *
 * For example:
 *
 * zero: 'foo',
 * max: 'qux',
 * steps: [
 *     [1, 'bar'],
 *     [2, 'baz']
 * ]
 *
 * means:
 *
 * input === 0      maps to 'foo'
 * 0 < input < 1    maps to 'bar'
 * 1 <= input < 2   maps to 'baz'
 * input >= 2       maps to 'qux'
 */

var TRACKER_RANGE_MAP = {
  zero: 0,
  max: 10,
  steps: [[0.1, 1], [1, 2], [5, 3], [10, 4], [15, 5], [20, 6], [30, 7], [45, 8], [66, 9]]
};
var GRADE_RANGE_MAP = {
  zero: 'A',
  max: 'D-',
  steps: [[2, 'A'], [4, 'B+'], [10, 'B'], [14, 'C+'], [20, 'C'], [30, 'D']]
};
var Grade = /*#__PURE__*/function () {
  function Grade(attrs) {
    var _this = this;
    _classCallCheck(this, Grade);
    // defaults
    this.https = false;
    this.httpsAutoUpgrade = false;
    this.privacyScore = UNKNOWN_PRIVACY_SCORE; // unknown

    this.entitiesBlocked = {};
    this.entitiesNotBlocked = {};
    this.scores = null;

    // set any values that were passed in
    attrs = attrs || {};
    if (attrs.https) {
      this.setHttps(attrs.https, attrs.httpsAutoUpgrade);
    }
    if (typeof attrs.privacyScore !== 'undefined') {
      this.setPrivacyScore(attrs.privacyScore);
    }
    if (attrs.parentEntity) {
      this.setParentEntity(attrs.parentEntity, attrs.prevalence);
    }
    if (attrs.trackersBlocked) {
      Object.keys(attrs.trackersBlocked).forEach(function (entityName) {
        _this.addEntityBlocked(entityName, attrs.trackersBlocked[entityName].prevalence);
      });
    }
    if (attrs.trackersNotBlocked) {
      Object.keys(attrs.trackersNotBlocked).forEach(function (entityName) {
        _this.addEntityNotBlocked(entityName, attrs.trackersNotBlocked[entityName].prevalence);
      });
    }
  }
  _createClass(Grade, [{
    key: "setHttps",
    value: function setHttps(https, httpsAutoUpgrade) {
      this.scores = null;
      this.https = https;
      this.httpsAutoUpgrade = httpsAutoUpgrade;
    }
  }, {
    key: "setPrivacyScore",
    value: function setPrivacyScore(score) {
      this.scores = null;
      this.privacyScore = typeof score === 'number' ? score : UNKNOWN_PRIVACY_SCORE;
    }
  }, {
    key: "addEntityBlocked",
    value: function addEntityBlocked(name, prevalence) {
      if (!name) return;
      this.scores = null;
      this.entitiesBlocked[name] = prevalence;
    }
  }, {
    key: "addEntityNotBlocked",
    value: function addEntityNotBlocked(name, prevalence) {
      if (!name) return;
      this.scores = null;
      this.entitiesNotBlocked[name] = prevalence;
    }
  }, {
    key: "setParentEntity",
    value: function setParentEntity(name, prevalence) {
      this.scores = null;
      this.addEntityNotBlocked(name, prevalence);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      // HTTPS
      var siteHttpsScore, enhancedHttpsScore;
      if (this.httpsAutoUpgrade) {
        siteHttpsScore = 0;
        enhancedHttpsScore = 0;
      } else if (this.https) {
        siteHttpsScore = 3;
        enhancedHttpsScore = 0;
      } else {
        siteHttpsScore = 10;
        enhancedHttpsScore = 10;
      }

      // PRIVACY
      // clamp to 10
      var privacyScore = Math.min(this.privacyScore, 10);

      // TRACKERS
      var siteTrackerScore = 0;
      var enhancedTrackerScore = 0;
      for (var entity in this.entitiesBlocked) {
        siteTrackerScore += this._normalizeTrackerScore(this.entitiesBlocked[entity]);
      }
      for (var _entity in this.entitiesNotBlocked) {
        siteTrackerScore += this._normalizeTrackerScore(this.entitiesNotBlocked[_entity]);
        enhancedTrackerScore += this._normalizeTrackerScore(this.entitiesNotBlocked[_entity]);
      }
      var siteTotalScore = siteHttpsScore + siteTrackerScore + privacyScore;
      var enhancedTotalScore = enhancedHttpsScore + enhancedTrackerScore + privacyScore;
      this.scores = {
        site: {
          grade: this._scoreToGrade(siteTotalScore),
          score: siteTotalScore,
          trackerScore: siteTrackerScore,
          httpsScore: siteHttpsScore,
          privacyScore: privacyScore
        },
        enhanced: {
          grade: this._scoreToGrade(enhancedTotalScore),
          score: enhancedTotalScore,
          trackerScore: enhancedTrackerScore,
          httpsScore: enhancedHttpsScore,
          privacyScore: privacyScore
        }
      };
    }
  }, {
    key: "get",
    value: function get() {
      if (!this.scores) this.calculate();
      return this.scores;
    }
  }, {
    key: "_getValueFromRangeMap",
    value: function _getValueFromRangeMap(value, rangeMapData) {
      var steps = rangeMapData.steps;
      if (!value || value <= 0) {
        return rangeMapData.zero;
      }
      if (value >= steps[steps.length - 1][0]) {
        return rangeMapData.max;
      }
      for (var i = 0; i < steps.length; i++) {
        if (value < steps[i][0]) {
          return steps[i][1];
        }
      }
    }
  }, {
    key: "_normalizeTrackerScore",
    value: function _normalizeTrackerScore(pct) {
      return this._getValueFromRangeMap(pct, TRACKER_RANGE_MAP);
    }
  }, {
    key: "_scoreToGrade",
    value: function _scoreToGrade(score) {
      return this._getValueFromRangeMap(score, GRADE_RANGE_MAP);
    }
  }]);
  return Grade;
}();
module.exports = Grade;

},{}],36:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @typedef TrackerData
 * @property {ActionName} action
 * @property {string} reason
 * @property {boolean} sameEntity
 * @property {boolean} sameBaseDomain
 * @property {string | false} redirectUrl
 * @property {TrackerRule | null} matchedRule
 * @property {boolean} matchedRuleException
 * @property {TrackerObj} [tracker]
 * @property {string} fullTrackerDomain
 * @property {string} [fromCname]
 */
/**
 * @typedef TrackerRule
 * @property {string | RegExp} rule
 * @property {string} [action]
 * @property {number} fingerprinting
 * @property {number} cookies
 * @property {RuleDefinition} [exceptions]
 * @property {RuleDefinition} [options]
 * @property {string} [surrogate]
 * @property {boolean} [strictRedirect]
 */
/**
 * @typedef RuleDefinition
 * @property {string[]} [domains]
 * @property {string[]} [types]
 */
/**
 * @typedef OwnerData
 * @property {string} name
 * @property {string} displayName
 * @property {string} [ownedBy]
 */
/**
 * @typedef TrackerObj
 * @property {string} domain
 * @property {OwnerData} owner
 * @property {number} prevalence
 * @property {number} fingerprinting
 * @property {number} cookies
 * @property {string[]} categories
 * @property {ActionName} default
 * @property {TrackerRule[]} rules
 */
/**
 * @typedef RequestData
 * @property {string} siteUrl
 * @property {RequestExpression} request
 * @property {boolean} sameBaseDomain
 * @property {string} siteDomain
 * @property {string[]} siteUrlSplit
 * @property {string} urlToCheck
 * @property {string} urlToCheckDomain
 * @property {string[]} urlToCheckSplit
 */
/**
 * @typedef RequestExpression
 * @property {string} type
 */
/**
 * @typedef {'ignore' | 'block' | 'redirect' | 'none' | 'ad-attribution' | 'ignore-user'} ActionName
 */
/**
 * @typedef EntityData
 * @property {number} prevalence
 * @property {string} displayName
 * @property {string[]} domains
 */
var Trackers = /*#__PURE__*/function () {
  /**
   * @param {{
   *    tldts: import('tldts'),
   *    tldjs: import('tldts'),
   *    utils: *,
   * }} ops
   */
  function Trackers(ops) {
    _classCallCheck(this, Trackers);
    this.tldts = ops.tldts || ops.tldjs;
    this.utils = ops.utils;
  }

  /**
   * @param {{data: *, name: string}[]} lists
   */
  _createClass(Trackers, [{
    key: "setLists",
    value: function setLists(lists) {
      var _this = this;
      lists.forEach(function (list) {
        if (list.name === 'tds') {
          _this.entityList = _this.processEntityList(list.data.entities);
          _this.trackerList = _this.processTrackerList(list.data.trackers);
          _this.domains = list.data.domains;
          _this.cnames = list.data.cnames;
        } else if (list.name === 'surrogates') {
          _this.surrogateList = _this.processSurrogateList(list.data);
        }
      });
    }

    /**
     * @param {Record<string, TrackerObj>} data
     * @returns {*}
     */
  }, {
    key: "processTrackerList",
    value: function processTrackerList(data) {
      for (var name in data) {
        if (data[name].rules) {
          for (var i in data[name].rules) {
            data[name].rules[i].rule = new RegExp(data[name].rules[i].rule, 'ig');
          }
        }
      }
      return data;
    }

    /**
     * @param {Record<string, EntityData>} data
     * @returns {Record<string, string>}
     */
  }, {
    key: "processEntityList",
    value: function processEntityList(data) {
      /** @type {Record<string, string>} */
      var processed = {};
      var _loop = function _loop(entity) {
        data[entity].domains.forEach(function (domain) {
          processed[domain] = entity;
        });
      };
      for (var entity in data) {
        _loop(entity);
      }
      return processed;
    }

    /**
     * @param {string} text
     * @returns {Record<string, string>}
     */
  }, {
    key: "processSurrogateList",
    value: function processSurrogateList(text) {
      var b64dataheader = 'data:application/javascript;base64,';
      /** @type {Record<string, string>} */
      var surrogateList = {};
      var splitSurrogateList = text.trim().split('\n\n');
      splitSurrogateList.forEach(function (sur) {
        // remove comment lines
        var lines = sur.split('\n').filter(function (line) {
          return !/^#.*/.test(line);
        });

        // remove first line, store it
        var firstLine = lines.shift();
        if (!firstLine) {
          return;
        }

        // take identifier from first line
        var pattern = firstLine.split(' ')[0].split('/')[1];
        var b64surrogate = btoa(lines.join('\n').toString());
        surrogateList[pattern] = b64dataheader + b64surrogate;
      });
      return surrogateList;
    }

    /**
     * @param {string} url
     * @returns {{fromCname: string | undefined, finalURL: string}}
     */
  }, {
    key: "resolveCname",
    value: function resolveCname(url) {
      var parsed = this.tldts.parse(url, {
        allowPrivateDomains: true
      });
      var finalURL = url;
      var fromCname;
      if (parsed && this.cnames && parsed.domain) {
        var domain = parsed.domain;
        if (parsed.subdomain) {
          domain = parsed.subdomain + '.' + domain;
        }
        var finalDomain = this.cnames[domain] || domain;
        finalURL = finalURL.replace(domain, finalDomain);
        if (finalDomain !== domain) {
          fromCname = domain;
        }
      }
      return {
        fromCname: fromCname,
        finalURL: finalURL
      };
    }

    /**
     * Copied from extension (FIX)
     * @param {string} urlString
     **/
  }, {
    key: "getBaseDomain",
    value: function getBaseDomain(urlString) {
      var parsedUrl = this.tldts.parse(urlString, {
        allowPrivateDomains: true
      });
      return parsedUrl.domain || parsedUrl.hostname;
    }

    /**
     * single object with all of our request and site data split and
     * processed into the correct format for the tracker set/get functions.
     * This avoids repeat calls to split and util functions.
     * @param {string} urlToCheck
     * @param {string} siteUrl
     * @param {RequestExpression} request
     * @returns {RequestData | null}
     */
  }, {
    key: "getRequestData",
    value: function getRequestData(urlToCheck, siteUrl, request) {
      var siteDomain = this.getBaseDomain(siteUrl);
      var urlToCheckDomain = this.getBaseDomain(urlToCheck);
      if (!siteDomain || !urlToCheckDomain) {
        return null;
      }
      return {
        siteUrl: siteUrl,
        request: request,
        sameBaseDomain: siteDomain === urlToCheckDomain,
        siteDomain: siteDomain,
        siteUrlSplit: this.utils.extractHostFromURL(siteUrl).split('.'),
        urlToCheck: urlToCheck,
        urlToCheckDomain: urlToCheckDomain,
        urlToCheckSplit: this.utils.extractHostFromURL(urlToCheck).split('.')
      };
    }

    /**
     * @param {string} url
     * @returns {boolean}
     */
  }, {
    key: "isSpecialURL",
    value: function isSpecialURL(url) {
      var urlObj;
      try {
        urlObj = new URL(url);
      } catch (_unused) {
        // This really shouldn't happen but if it does, we'll just assume it's a special URL
        return true;
      }
      var specialProtocols = [
      // Browser specific internal protocols
      'chrome-extension:', 'chrome-devtools:', 'chrome-search:', 'chrome:', 'edge:', 'opera:', 'about:', 'moz-extension:',
      // Special web protocols
      'file:', 'javascript:', 'data:', 'blob:', 'view-source:', 'vbscript:',
      // Safelisted protocol handler schemes (https://html.spec.whatwg.org/#safelisted-scheme)
      'bitcoin:', 'ftp:', 'ftps:', 'geo:', 'im:', 'irc:', 'ircs:', 'magnet:', 'mailto:', 'matrix:', 'mms:', 'news:', 'nntp:', 'openpgp4fpr:', 'sftp:', 'sip:', 'sms:', 'smsto:', 'ssh:', 'tel:', 'urn:', 'webcal:', 'wtai:', 'xmpp:'];
      if (urlObj) {
        if (specialProtocols.includes(urlObj.protocol) ||
        // https://html.spec.whatwg.org/#web+-scheme-prefix
        urlObj.protocol.startsWith('web+') || urlObj.hostname === 'localhost') {
          return true;
        }
      }
      return false;
    }

    /**
     * @param {string} urlToCheck
     * @param {string} siteUrl
     * @param {RequestExpression} request
     * @param {Set<string>} [supportedCustomRuleActions]
     *   Optional set containing supported "custom" (aka non-standard) rule
     *   actions.
     *   Note: Standard block/ignore rule actions are always supported, and do
     *         not need to be included here. Custom rule actions are only
     *         necessary for features like Click to Load that have their own
     *         special rule actions.
     *         @see {Trackers.prototype.standardRuleActions}.
     * @returns {TrackerData | null}
     */
  }, {
    key: "getTrackerData",
    value: function getTrackerData(urlToCheck, siteUrl, request, supportedCustomRuleActions) {
      if (!this.entityList || !this.trackerList) {
        throw new Error('tried to detect trackers before rules were loaded');
      }
      if (this.isSpecialURL(urlToCheck) || this.isSpecialURL(siteUrl)) {
        return null;
      }
      var fromCname;
      var requestData = this.getRequestData(urlToCheck, siteUrl, request);
      if (!requestData) {
        return null;
      }
      // We don't want to use CNAME check for this caluclation as we would avoid showing in the panel.
      // So we're calcuating this before the CNAME check.
      var sameBaseDomain = requestData.sameBaseDomain;

      // finds a tracker definition by iterating over the whole trackerList and finding the matching tracker.
      var tracker = this.findTracker(requestData);
      if (!tracker) {
        // if request doesn't have any rules associated with it, we should check if it's a CNAMEed tracker
        var cnameResolution = this.resolveCname(urlToCheck);
        var cnameRequestData = this.getRequestData(cnameResolution.finalURL, siteUrl, request);
        if (cnameResolution.fromCname && cnameRequestData) {
          tracker = this.findTracker(cnameRequestData);
          if (tracker) {
            fromCname = cnameResolution.fromCname;
            requestData = cnameRequestData;
          }
        }
      }
      var fullTrackerDomain = requestData.urlToCheckSplit.join('.');
      var requestOwner = this.findTrackerOwner(requestData.urlToCheckDomain);
      var websiteOwner = this.findWebsiteOwner(requestData);
      var sameEntity = requestOwner && websiteOwner ? requestOwner === websiteOwner : requestData.siteDomain === requestData.urlToCheckDomain;
      if (!tracker) {
        if (sameEntity) {
          return null;
        }
        var owner = {
          name: requestOwner || requestData.urlToCheckDomain || 'unknown',
          displayName: requestOwner || requestData.urlToCheckDomain || 'Unknown'
        };
        /** @type {TrackerObj} */
        var trackerObj = {
          domain: fullTrackerDomain,
          owner: owner,
          prevalence: 0,
          fingerprinting: 0,
          cookies: 0,
          categories: [],
          "default": 'none',
          rules: []
        };
        return {
          action: trackerObj["default"],
          reason: '',
          sameEntity: sameEntity,
          sameBaseDomain: sameBaseDomain,
          redirectUrl: '',
          matchedRule: null,
          matchedRuleException: false,
          tracker: tracker,
          fullTrackerDomain: fullTrackerDomain,
          fromCname: fromCname
        };
      }
      // finds a matching rule by iterating over the rules in tracker.data and sets redirectUrl.
      var matchedRule = this.findRule(tracker, requestData, supportedCustomRuleActions);

      // @ts-ignore
      var redirectUrl = matchedRule && matchedRule.surrogate ? this.surrogateList[matchedRule.surrogate] : false;

      // sets tracker.exception by looking at tracker.rule exceptions (if any)
      var matchedRuleException = matchedRule ? this.matchesRuleDefinition(matchedRule, 'exceptions', requestData) : false;
      var _this$getAction = this.getAction({
          sameEntity: sameEntity,
          matchedRule: matchedRule,
          matchedRuleException: matchedRuleException,
          defaultAction: tracker["default"],
          redirectUrl: redirectUrl
        }),
        action = _this$getAction.action,
        reason = _this$getAction.reason;
      return {
        action: action,
        reason: reason,
        sameEntity: sameEntity,
        sameBaseDomain: sameBaseDomain,
        redirectUrl: redirectUrl,
        matchedRule: matchedRule,
        matchedRuleException: matchedRuleException,
        tracker: tracker,
        fullTrackerDomain: fullTrackerDomain,
        fromCname: fromCname
      };
    }

    /**
     * Pull subdomains off of the request rule and look for a matching tracker object in our data
     * @param {{urlToCheckSplit: string[]}} urlToCheckObject
     * @returns {undefined | TrackerObj}
     */
  }, {
    key: "findTracker",
    value: function findTracker(urlToCheckObject) {
      if (!this.trackerList) {
        throw new Error('tried to detect trackers before rules were loaded');
      }
      var urlList = Array.from(urlToCheckObject.urlToCheckSplit);
      while (urlList.length > 1) {
        var trackerDomain = urlList.join('.');
        urlList.shift();
        var matchedTracker = this.trackerList[trackerDomain];
        if (matchedTracker) {
          return matchedTracker;
        }
      }
    }

    /**
     * @param {string} trackerDomain
     * @returns {string | undefined}
     */
  }, {
    key: "findTrackerOwner",
    value: function findTrackerOwner(trackerDomain) {
      // @ts-ignore
      return this.entityList[trackerDomain];
    }

    /**
     * Set parent and first party values on tracker
     * @param {{siteUrlSplit: string[]}} siteUrlSplitObject
     * @returns {string | undefined}
     */
  }, {
    key: "findWebsiteOwner",
    value: function findWebsiteOwner(siteUrlSplitObject) {
      // find the site owner
      var siteUrlList = Array.from(siteUrlSplitObject.siteUrlSplit);
      while (siteUrlList.length > 1) {
        var siteToCheck = siteUrlList.join('.');
        siteUrlList.shift();

        // @ts-ignore
        if (this.entityList[siteToCheck]) {
          // @ts-ignore
          return this.entityList[siteToCheck];
        }
      }
    }

    /**
     * Returns false if the given rule has an unsupported rule action, true
     * otherwise.
     * @param {TrackerRule} ruleObj
     * @param {Set<string>} [supportedCustomRuleActions]
     * @returns {boolean}
     */
  }, {
    key: "ruleActionSupported",
    value: function ruleActionSupported(_ref, supportedCustomRuleActions) {
      var action = _ref.action;
      return (
        // Rule action generally defaults to 'block' if omitted.
        !action ||
        // Standard rule actions are always supported.
        Trackers.standardRuleActions.has(action) ||
        // Provided custom rule actions (if any) are also supported.
        !!supportedCustomRuleActions && supportedCustomRuleActions.has(action)
      );
    }

    /**
     * Iterate through a tracker rule list and return the first matching rule, if any.
     * @param {TrackerObj} tracker
     * @param {RequestData} requestData
     * @param {Set<string>} [supportedCustomRuleActions]
     * @returns {TrackerRule | null}
     */
  }, {
    key: "findRule",
    value: function findRule(tracker, requestData, supportedCustomRuleActions) {
      var _this2 = this;
      var matchedRule = null;
      // Find a matching rule from this tracker
      if (tracker.rules && tracker.rules.length) {
        tracker.rules.some(function (ruleObj) {
          if (_this2.requestMatchesRule(requestData, ruleObj) && _this2.ruleActionSupported(ruleObj, supportedCustomRuleActions)) {
            matchedRule = ruleObj;
            return true;
          }
          return false;
        });
      }
      return matchedRule;
    }

    /**
     * @param {RequestData} requestData
     * @param {TrackerRule} ruleObj
     * @returns {boolean}
     */
  }, {
    key: "requestMatchesRule",
    value: function requestMatchesRule(requestData, ruleObj) {
      if (requestData.urlToCheck.match(ruleObj.rule)) {
        if (ruleObj.options) {
          return this.matchesRuleDefinition(ruleObj, 'options', requestData);
        } else {
          return true;
        }
      } else {
        return false;
      }
    }

    /**
     * Check the matched rule options against the request data
     * @param {TrackerRule} rule
     * @param {'exceptions' | 'options'} type
     * @param {RequestData} requestData
     * @returns {boolean} true if all options matched
     */
  }, {
    key: "matchesRuleDefinition",
    value: function matchesRuleDefinition(rule, type, requestData) {
      var ruleDefinition = rule[type];
      if (!ruleDefinition) {
        return false;
      }
      var matchTypes = ruleDefinition.types && ruleDefinition.types.length ? ruleDefinition.types.includes(requestData.request.type) : true;
      var matchDomains = ruleDefinition.domains && ruleDefinition.domains.length ? ruleDefinition.domains.some(function (domain) {
        return domain.match(requestData.siteDomain);
      }) : true;
      return matchTypes && matchDomains;
    }

    /**
     * @param {{
     *     sameEntity: boolean,
     *     matchedRule: TrackerRule | null,
     *     matchedRuleException: boolean,
     *     defaultAction: ActionName | undefined,
     *     redirectUrl: string | boolean
     * }} tracker
     * @returns {{ action: ActionName, reason: string }}
     */
  }, {
    key: "getAction",
    value: function getAction(tracker) {
      // Determine the blocking decision and reason.
      /** @type {ActionName | undefined} */
      var action = 'ignore';
      var reason = 'unknown fallback';
      if (tracker.sameEntity) {
        action = 'ignore';
        reason = 'first party';
      } else if (tracker.matchedRuleException) {
        action = 'ignore';
        reason = 'matched rule - exception';
      } else if (!tracker.matchedRule && tracker.defaultAction === 'ignore') {
        action = 'ignore';
        reason = 'default ignore';
      } else if (tracker.matchedRule && tracker.matchedRule.action === 'ignore') {
        action = 'ignore';
        reason = 'matched rule - ignore';
      } else if (!tracker.matchedRule && tracker.defaultAction === 'block') {
        action = 'block';
        reason = 'default block';
      } else if (tracker.matchedRule) {
        if (tracker.redirectUrl) {
          action = 'redirect';
          reason = 'matched rule - surrogate';
        } else {
          action = 'block';
          reason = 'matched rule - block';
        }
      }
      return {
        action: action,
        reason: reason
      };
    }
  }]);
  return Trackers;
}();
_defineProperty(Trackers, "standardRuleActions", new Set(['block', 'ignore']));
module.exports = Trackers;

},{}],37:[function(require,module,exports){
module.exports={
    "readme": "https://github.com/duckduckgo/privacy-configuration",
    "version": 1679992058904,
    "features": {
        "adClickAttribution": {
            "readme": "https://help.duckduckgo.com/duckduckgo-help-pages/privacy/web-tracking-protections/#3rd-party-tracker-loading-protection",
            "state": "enabled",
            "exceptions": [],
            "settings": {
                "linkFormats": [
                    {
                        "url": "duckduckgo.com/y.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "SERP Ads"
                    },
                    {
                        "url": "www.search-company.site/y.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "Test Domain"
                    },
                    {
                        "url": "www.search-company.example/y.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "Test Domain"
                    },
                    {
                        "url": "links.duckduckgo.com/m.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "Shopping Ads"
                    },
                    {
                        "url": "www.search-company.site/m.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "Test Domain"
                    },
                    {
                        "url": "www.search-company.example/m.js",
                        "adDomainParameterName": "ad_domain",
                        "desc": "Test Domain"
                    }
                ],
                "allowlist": [
                    {
                        "blocklistEntry": "bing.com",
                        "host": "bat.bing.com"
                    },
                    {
                        "blocklistEntry": "ad-company.site",
                        "host": "convert.ad-company.site"
                    },
                    {
                        "blocklistEntry": "ad-company.example",
                        "host": "convert.ad-company.example"
                    }
                ],
                "navigationExpiration": 1800,
                "totalExpiration": 604800,
                "heuristicDetection": "enabled",
                "domainDetection": "enabled"
            },
            "hash": "b813ade8472a097ffbd43a3331116fe1"
        },
        "ampLinks": {
            "exceptions": [
                {
                    "domain": "freecodecamp.org",
                    "reason": "Clicking 'get started' reloads the page and does not progress to the login page."
                },
                {
                    "domain": "www.audiosciencereview.com",
                    "reason": "Pages on the site end up in redirect loops in Firefox."
                }
            ],
            "settings": {
                "deepExtractionEnabled": true,
                "deepExtractionTimeout": 1500,
                "linkFormats": [
                    "^https?:\\/\\/(?:w{3}\\.)?google\\.\\S{2,}\\/amp\\/s\\/(\\S+)$",
                    "^https?:\\/\\/\\S+ampproject\\.org\\/\\S\\/s\\/(\\S+)$"
                ],
                "keywords": [
                    "=amp",
                    "amp=",
                    "&amp",
                    "amp&",
                    "/amp",
                    "amp/",
                    ".amp",
                    "amp.",
                    "%amp",
                    "amp%",
                    "_amp",
                    "amp_",
                    "?amp"
                ]
            },
            "state": "enabled",
            "hash": "8668c1396cf49ac18e2e057c48dac1a7"
        },
        "autoconsent": {
            "exceptions": [
                {
                    "domain": "zeitraum-moebel.de",
                    "reason": "After the cookie popup is managed and disappears, a semi-transparent overlay remains on the page which prevents further interaction with the site."
                },
                {
                    "domain": "mathebibel.de",
                    "reason": "Page renders but one cannot scroll (and no CMP is shown) for a few seconds."
                },
                {
                    "domain": "focus.de",
                    "reason": "Page renders but one cannot scroll (and no CMP is shown) for a few seconds."
                },
                {
                    "domain": "computerbild.de",
                    "reason": "Page renders but one cannot scroll (and no CMP is shown) for a few seconds."
                },
                {
                    "domain": "techtarget.com",
                    "reason": "Page renders but one cannot scroll (and no CMP is shown) for a few seconds."
                },
                {
                    "domain": "n-tv.de",
                    "reason": "Page renders but one cannot scroll (and no CMP is shown) for a few seconds."
                },
                {
                    "domain": "spiegel.de",
                    "reason": "CMP gets incorrectly handled, gets stuck in preferences dialogue."
                },
                {
                    "domain": "derstandard.at",
                    "reason": "CMP gets incorrectly handled / detected."
                },
                {
                    "domain": "concursolutions.com",
                    "reason": "Page renders blank for several seconds before cookie management can complete."
                },
                {
                    "domain": "asus.com",
                    "reason": "Opt out is broken on the US version of the site"
                },
                {
                    "domain": "swm.de",
                    "reason": "infinite reload"
                },
                {
                    "domain": "heise.de",
                    "reason": "infinite reload"
                },
                {
                    "domain": "voici.fr",
                    "reason": "https://github.com/duckduckgo/autoconsent/issues/66"
                },
                {
                    "domain": "tfl.gov.uk",
                    "reason": "https://github.com/duckduckgo/autoconsent/issues/68"
                },
                {
                    "domain": "corporatefinanceinstitute.com",
                    "reason": "CMP gets incorrectly handled / repeatedly opens tabs"
                },
                {
                    "domain": "kicker.de",
                    "reason": "https://github.com/duckduckgo/autoconsent/issues/66"
                },
                {
                    "domain": "epojisteni.cz",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/326"
                },
                {
                    "domain": "nhm.ac.uk",
                    "reason": "https://github.com/duckduckgo/autoconsent/issues/113"
                }
            ],
            "settings": {
                "disabledCMPs": [
                    "Sourcepoint-top"
                ]
            },
            "state": "disabled",
            "hash": "90db6caedebe315a0737ca1f746d5f52"
        },
        "autofill": {
            "exceptions": [
                {
                    "domain": "containerstore.com",
                    "reason": "Generally poor UX - no username saved on signup, prompts for Duck address on 'forgot password'."
                },
                {
                    "domain": "roll20.net",
                    "reason": "Performance issue for too many fields."
                }
            ],
            "state": "enabled",
            "hash": "59c4bd9b8cee343c81da98bfe5d77928"
        },
        "clickToLoad": {
            "exceptions": [],
            "settings": {
                "Facebook, Inc.": {
                    "ruleActions": [
                        "block-ctl-fb"
                    ],
                    "state": "enabled"
                },
                "Youtube": {
                    "ruleActions": [
                        "block-ctl-yt"
                    ],
                    "state": "disabled"
                }
            },
            "state": "enabled",
            "hash": "13f0b3ad67d6e300e17c52191ed4b963"
        },
        "clickToPlay": {
            "exceptions": [],
            "settings": {
                "Facebook": {
                    "clicksBeforeSimpleVersion": 3,
                    "ruleActions": [
                        "block-ctl-fb"
                    ],
                    "state": "enabled"
                }
            },
            "state": "enabled",
            "hash": "2f0917addece756bfb107fc3fba535e9"
        },
        "contentBlocking": {
            "state": "enabled",
            "exceptions": [
                {
                    "domain": "welt.de",
                    "reason": "Video pauses at about 13-15 seconds in. Playing the video again results in a single frame rendering without progressing to the next frame."
                }
            ],
            "hash": "ee4fc0c8e6acc9ef2629ae96156a76a5"
        },
        "cookie": {
            "exceptions": [
                {
                    "domain": "nespresso.com",
                    "reason": "Clicking 'Continue' after filling out details for account creation yields an error."
                }
            ],
            "state": "enabled",
            "minSupportedVersion": "2022.6.1",
            "settings": {
                "trackerCookie": "enabled",
                "nonTrackerCookie": "disabled",
                "excludedCookieDomains": [
                    {
                        "domain": "accounts.google.com",
                        "reason": "On some Google sign-in flows, there is an error after entering username and proceeding: 'Your browser has cookies disabled. Make sure that your cookies are enabled and try again.'"
                    },
                    {
                        "domain": "pay.google.com",
                        "reason": "After sign-in for Google Pay flows, there is repeated flickering and a loading spinner, preventing the flow from proceeding."
                    },
                    {
                        "domain": "payments.google.com",
                        "reason": "After sign-in for Google Pay flows (after flickering is resolved), blocking this causes the loading spinner to spin indefinitely, and the payment flow cannot proceed."
                    }
                ],
                "firstPartyTrackerCookiePolicy": {
                    "readme": "This policy is deprecated. We are expanding this protection to all first party cookies set by scripts and using firstPartyCookiePolicy policy instead.",
                    "threshold": 86400,
                    "maxAge": 86400
                },
                "firstPartyCookiePolicy": {
                    "threshold": 604800,
                    "maxAge": 604800
                }
            },
            "hash": "a86050a6a0612aee10f70fd8ca9b6d0c"
        },
        "customUserAgent": {
            "settings": {
                "omitApplicationSites": [
                    {
                        "domain": "thingiverse.com",
                        "reason": "Site loads blank and does not proceed."
                    },
                    {
                        "domain": "qubushotel.com",
                        "reason": "Homepage UI elements appear squashed together, preventing interaction with the site."
                    },
                    {
                        "domain": "digid.nl",
                        "reason": "https://github.com/duckduckgo/privacy-configuration/issues/602"
                    },
                    {
                        "domain": "sme.sk",
                        "reason": "https://github.com/duckduckgo/privacy-configuration/issues/667"
                    },
                    {
                        "domain": "tiktok.com",
                        "reason": "https://github.com/duckduckgo/privacy-configuration/issues/667"
                    }
                ],
                "omitVersionSites": []
            },
            "exceptions": [],
            "state": "disabled",
            "hash": "b1a30e9afcf663d1ad99590c14a5b5be"
        },
        "duckPlayer": {
            "exceptions": [],
            "state": "disabled",
            "hash": "728493ef7a1488e4781656d3f9db84aa"
        },
        "elementHiding": {
            "exceptions": [
                {
                    "domain": "politico.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                },
                {
                    "domain": "bild.de",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/589"
                },
                {
                    "domain": "kbb.com",
                    "reason": "Adblocker wall"
                },
                {
                    "domain": "medium.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                },
                {
                    "domain": "speedtest.net",
                    "reason": "main content hidden"
                },
                {
                    "domain": "tvlistings.zap2it.com",
                    "reason": "main content hidden"
                },
                {
                    "domain": "manhwascan.net",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                },
                {
                    "domain": "wiwo.de",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                },
                {
                    "domain": "metro.co.uk",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                },
                {
                    "domain": "blick.ch",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/592"
                }
            ],
            "settings": {
                "useStrictHideStyleTag": false,
                "rules": [
                    {
                        "selector": "[id*='gpt-']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='gpt-']",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[class*='dfp-']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[id*='dfp-']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[id*='dfp_']",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[id*='google_ads_iframe']",
                        "type": "hide"
                    },
                    {
                        "selector": "#google_ads",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".adsbygoogle",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[id*='taboola-']",
                        "type": "hide"
                    },
                    {
                        "selector": ".taboolaHeight",
                        "type": "hide"
                    },
                    {
                        "selector": ".taboola-placeholder",
                        "type": "hide"
                    },
                    {
                        "selector": ".adHolder",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".adplaceholder",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad-placeholder",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='ad_unit']",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".column-ad",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".wide-ad",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".AD",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='ad-content']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='ad-slot_']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='_ad-slot']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad-block",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".adBox",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class^='adunit']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".apexAd",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad-leaderboard",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".leaderboard",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "#leaderboard",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".leaderboard_wrapper",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".banner-leaderboard",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad-banner-container",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='bannerAd']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".banner-placeholder",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".header-ads",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".header-ad-slot",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "#credential_picker_container",
                        "type": "hide"
                    },
                    {
                        "selector": "#credential_picker_iframe",
                        "type": "hide"
                    },
                    {
                        "selector": "#google-one-tap-iframe",
                        "type": "hide"
                    },
                    {
                        "selector": ".google-one-tap-modal-div",
                        "type": "hide"
                    },
                    {
                        "selector": ".google-one-tap",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ad_container",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[class^='ad-container']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[class*='-ad-container']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".adcontainer",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ad-current",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".advertisement",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[class*='advert-']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[id*='advert-']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".ads__inline",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ads__native",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ad-slot",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ad-wrap",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ad-wrapper",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".ads-wrapper",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[class^='adWrapper']",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[class*='ad-zone']",
                        "type": "hide-empty"
                    },
                    {
                        "selector": "[data-adunitpath]",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[data-targeting]",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[data-ad-placeholder]",
                        "type": "closest-empty"
                    },
                    {
                        "selector": "[data-ad]",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".arc-ad-wrapper",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".bordeaux-slot",
                        "type": "closest-empty"
                    },
                    {
                        "selector": ".bordeaux-anchored-container",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".rightAd",
                        "type": "hide-empty"
                    },
                    {
                        "selector": ".sponsored-slot",
                        "type": "hide-empty"
                    }
                ],
                "styleTagExceptions": [],
                "mediaAndFormSelectors": "video,canvas,embed,object,audio,map,form,input,textarea,select,option,button",
                "adLabelStrings": [
                    "advertisement",
                    "advertisment",
                    "advertisementclose",
                    "advertisementcontinue reading the main story",
                    "advertisement\ncontinue reading the main story",
                    "advertisement\n\ncontinue reading the main story",
                    "advertisement - scroll to continue",
                    "advertisement  scroll to continue",
                    "advertising",
                    "advertising\nskip ad",
                    "advertising\nskip ad\nskip ad\nskip ad",
                    "ad feedback",
                    "anzeige",
                    "close this ad",
                    "sponsored",
                    "sponsoris",
                    "story continues below advertisement",
                    "publicit",
                    "publicidade",
                    "reklama",
                    "skip ad",
                    "continue reading the main story"
                ],
                "domains": [
                    {
                        "domain": "abc.es",
                        "rules": [
                            {
                                "selector": ".voc-advertising",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "apnews.com",
                        "rules": [
                            {
                                "selector": ".proper-dynamic-insertion",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "bbc.com",
                        "rules": [
                            {
                                "selector": ".dotcom-ad",
                                "type": "closest-empty"
                            },
                            {
                                "selector": ".leaderboard-ad-placeholder",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "bleacherreport.com",
                        "rules": [
                            {
                                "selector": ".br-ad-wrapper",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "bloomberg.com",
                        "rules": [
                            {
                                "selector": ".unsupported-browser-notification-container",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "bostonglobe.com",
                        "rules": [
                            {
                                "selector": ".arc_ad",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "carandclassic.com",
                        "rules": [
                            {
                                "selector": "[id*='advert-']",
                                "type": "override"
                            }
                        ]
                    },
                    {
                        "domain": "cbc.ca",
                        "rules": [
                            {
                                "selector": ".ad-risingstar-container",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".bigBoxContainer",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".stickyRailAd",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "cbssports.com",
                        "rules": [
                            {
                                "selector": ".leaderboard-wrap",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".skybox-top-wrapper",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "coingecko.com",
                        "rules": [
                            {
                                "selector": "[data-target='ads.banner']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "cyclingtips.com",
                        "rules": [
                            {
                                "selector": "[data-block-name='ads']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "dallasnews.com",
                        "rules": [
                            {
                                "selector": "[data-targeting]",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "ebay.com",
                        "rules": [
                            {
                                "selector": "#g-yolo-overlay-holder",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "ebay-kleinanzeigen.de",
                        "rules": [
                            {
                                "selector": "[data-liberty-position-name]",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "eonline.com",
                        "rules": [
                            {
                                "selector": "[class*='mps-']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "essentiallysports.com",
                        "rules": [
                            {
                                "selector": ".es-ad-space-container",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "express.co.uk",
                        "rules": [
                            {
                                "selector": ".superbanner",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#ad-vip-article",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "fandom.com",
                        "rules": [
                            {
                                "selector": ".top-ads-container",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "forbes.com",
                        "rules": [
                            {
                                "selector": "fbs-ad",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "fortune.com",
                        "rules": [
                            {
                                "selector": "[id*='Leaderboard']",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "[id*='RightRailFlex']",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "[id*='InStream']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "foxnews.com",
                        "rules": [
                            {
                                "selector": ".vendor-unit",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "ghacks.net",
                        "rules": [
                            {
                                "selector": ".box-banner",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[id^='ghacks_ad_code']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "hindustantimes.com",
                        "rules": [
                            {
                                "selector": ".desktopAd",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[class^='adHeight']",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[class^='adMinHeight']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "huffpost.com",
                        "rules": [
                            {
                                "selector": ".connatix-player",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "indiatimes.com",
                        "rules": [
                            {
                                "selector": ".ad-cls",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "._3JJMX",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".paisa-wrapper",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "indy100.com",
                        "rules": [
                            {
                                "selector": "[id*='thirdparty']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "leboncoin.fr",
                        "rules": [
                            {
                                "selector": "#lht-space-ad",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[class*='styles__ad']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "livemint.com",
                        "rules": [
                            {
                                "selector": "#adfreeDeskSpace",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#dekBudgetAd",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "macrumors.com",
                        "rules": [
                            {
                                "selector": ".tertiary",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[class*='sidebarblock']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "marketwatch.com",
                        "rules": [
                            {
                                "selector": ".j-ad",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "mirror.co.uk",
                        "rules": [
                            {
                                "selector": "#comments-standalone-mpu",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "nasdaq.com",
                        "rules": [
                            {
                                "selector": "[class^='ads__midpage']",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[class^='ads__right-rail']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "nbcsports.com",
                        "rules": [
                            {
                                "selector": ".block-mps",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#nbcsports-leaderboard",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "newsmax.com",
                        "rules": [
                            {
                                "selector": ".DFPad",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "nytimes.com",
                        "rules": [
                            {
                                "selector": "#top-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#bottom-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#mid1-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#mid2-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#mid3-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "#mktg-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".e1xxpj0j1",
                                "type": "hide-empty"
                            },
                            {
                                "selector": "[id*='story-ad']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "observador.pt",
                        "rules": [
                            {
                                "selector": ".obs-ad-placeholder",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "orange.fr",
                        "rules": [
                            {
                                "selector": ".tag-rm",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "psypost.com",
                        "rules": [
                            {
                                "selector": ".jeg_midbar",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "qz.com",
                        "rules": [
                            {
                                "selector": "#marquee-ad",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "reuters.com",
                        "rules": [
                            {
                                "selector": "[testid='ResponsiveAdSlot']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "rumble.com",
                        "rules": [
                            {
                                "selector": "[id^='rumble-ad']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "scmp.com",
                        "rules": [
                            {
                                "selector": "[class*='ad-slot-container']",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".top-ad",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".advertisement--mobile",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".bottom-ad",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".article-list__inline-ad",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".page-container__mobile-native-ad",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".ad-area",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "si.com",
                        "rules": [
                            {
                                "selector": ".m-ad",
                                "type": "closest-empty"
                            },
                            {
                                "selector": ".m-header-ad",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "skysports.com",
                        "rules": [
                            {
                                "selector": "[data-format='leaderboard']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "snopes.com",
                        "rules": [
                            {
                                "selector": ".proper-dynamic-insertion",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "target.com",
                        "rules": [
                            {
                                "selector": "[class^='styles__PubAdWrapper']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "thingiverse.com",
                        "rules": [
                            {
                                "selector": "[class*='AdCard__leaderboard']",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "tripadvisor.com",
                        "rules": [
                            {
                                "selector": "#tripGoogleOnetapContainer",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "uol.com.br",
                        "rules": [
                            {
                                "selector": ".model-base-bnr",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "wunderground.com",
                        "rules": [
                            {
                                "selector": ".pane-wu-fullscreenweather-ad-box-atf",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "vice.com",
                        "rules": [
                            {
                                "selector": ".adph",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".vice-ad__container",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".fixed-slot",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "washingtonpost.com",
                        "rules": [
                            {
                                "selector": "wp-ad",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "#leaderboard-wrapper",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".outbrain-wrapper",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "wsj.com",
                        "rules": [
                            {
                                "selector": "#cx-what-to-read-next",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "yahoo.com",
                        "rules": [
                            {
                                "selector": ".darla",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "gazeta.pl",
                        "rules": [
                            {
                                "selector": "[class*='DFP-']",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "[id*='banC']",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".indexPremium__adv",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "nfl.com",
                        "rules": [
                            {
                                "selector": "[class*='adv-block']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "usatoday.com",
                        "rules": [
                            {
                                "selector": "[aria-label='advertisement']",
                                "type": "closest-empty"
                            },
                            {
                                "selector": ".gnt_tb",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".gnt_flp",
                                "type": "hide-empty"
                            }
                        ]
                    },
                    {
                        "domain": "washingtontimes.com",
                        "rules": [
                            {
                                "selector": ".connatixcontainer",
                                "type": "hide"
                            },
                            {
                                "selector": "[id*='cxense-']",
                                "type": "closest-empty"
                            }
                        ]
                    },
                    {
                        "domain": "xfinity.com",
                        "rules": [
                            {
                                "selector": ".f-gpc-flyout",
                                "type": "hide"
                            },
                            {
                                "selector": ".f-gpc-banner",
                                "type": "hide"
                            }
                        ]
                    },
                    {
                        "domain": "first-party.site",
                        "rules": [
                            {
                                "selector": ".hide-test",
                                "type": "hide"
                            },
                            {
                                "selector": ".hide-empty-test",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".closest-empty-test",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "[class^='ad-container']",
                                "type": "override"
                            }
                        ]
                    },
                    {
                        "domain": "privacy-test-pages.glitch.me",
                        "rules": [
                            {
                                "selector": ".hide-test",
                                "type": "hide"
                            },
                            {
                                "selector": ".hide-empty-test",
                                "type": "hide-empty"
                            },
                            {
                                "selector": ".closest-empty-test",
                                "type": "closest-empty"
                            },
                            {
                                "selector": "[class^='ad-container']",
                                "type": "override"
                            }
                        ]
                    }
                ]
            },
            "state": "enabled",
            "hash": "c13b227c89c72e4d75065edf9e8849b4"
        },
        "fingerprintingAudio": {
            "state": "disabled",
            "exceptions": [],
            "hash": "c292bb627849854515cebbded288ef5a"
        },
        "fingerprintingBattery": {
            "exceptions": [],
            "state": "enabled",
            "hash": "52857469413a66e8b0c7b00de5589162"
        },
        "fingerprintingCanvas": {
            "settings": {
                "webGl": "enabled"
            },
            "exceptions": [
                {
                    "domain": "adidas.com",
                    "reason": "When adding an item to the cart, there is an error 'An unexpected problem occurred' and the item is not added to the cart."
                },
                {
                    "domain": "adidas.co.uk",
                    "reason": "When adding an item to the cart, there is an error 'An unexpected problem occurred' and the item is not added to the cart."
                },
                {
                    "domain": "amtrak.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/499"
                },
                {
                    "domain": "emirates.com",
                    "reason": "After filling out flight information and clicking 'Search flights', a blank page is shown for several seconds before the page redirects."
                },
                {
                    "domain": "hm.com",
                    "reason": "When adding an item to cart, there is an error 'something went wrong', and the item does not get added to the cart."
                },
                {
                    "domain": "ikea.com",
                    "reason": "When creating an account, after filling out details and going to e-mail confirmation, there is an error 'Something went wrong', and the e-mail may not be received. Clicking 'Send new code' appears successful, but after entering the code there is often another account creation error."
                },
                {
                    "domain": "manulife.ca",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/499"
                },
                {
                    "domain": "northernrailway.co.uk",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/350"
                },
                {
                    "domain": "spirit.com",
                    "reason": "When attempting to sign in, a semi-transparent overlay appears over the page which prevents further interaction with the site."
                },
                {
                    "domain": "thetrainline.com",
                    "reason": "After filling out travel info and clicking 'Get times & tickets', there is an error warning that 'Something went wrong', which prevents further interaction."
                },
                {
                    "domain": "walgreens.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/499"
                },
                {
                    "domain": "godaddy.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/499"
                }
            ],
            "state": "enabled",
            "hash": "06756b6634deaeb0f50c9cbbdb591b3c"
        },
        "fingerprintingHardware": {
            "settings": {
                "keyboard": {
                    "type": "undefined"
                },
                "hardwareConcurrency": {
                    "type": "number",
                    "value": 2
                },
                "deviceMemory": {
                    "type": "number",
                    "value": 8
                }
            },
            "exceptions": [
                {
                    "domain": "gamestop.com",
                    "reason": "Clicking 'add to cart' causes a spinner to load briefly, and the item doesn't get added to the cart."
                },
                {
                    "domain": "godaddy.com",
                    "reason": "After entering login details and clicking to log in, the site shows an adwall and prevents login."
                },
                {
                    "domain": "realestate.com.au",
                    "reason": "Site loads blank and does not proceed."
                },
                {
                    "domain": "secureserver.net",
                    "reason": "After entering login details and clicking to log in, the site shows an adwall and prevents login."
                },
                {
                    "domain": "hyatt.com",
                    "reason": "Site loads blank and does not proceed."
                }
            ],
            "state": "enabled",
            "hash": "a445e9d5b517efc11be4406673301d8a"
        },
        "fingerprintingScreenSize": {
            "settings": {
                "availTop": {
                    "type": "number",
                    "value": 0
                },
                "availLeft": {
                    "type": "number",
                    "value": 0
                },
                "colorDepth": {
                    "type": "number",
                    "value": 24
                },
                "pixelDepth": {
                    "type": "number",
                    "value": 24
                }
            },
            "exceptions": [
                {
                    "domain": "gamestop.com",
                    "reason": "Clicking 'add to cart' causes a spinner to load briefly, and the item doesn't get added to the cart."
                },
                {
                    "domain": "godaddy.com",
                    "reason": "After entering login details and clicking to log in, the site shows an adwall and prevents login."
                },
                {
                    "domain": "hyatt.com",
                    "reason": "Site loads blank and does not proceed."
                },
                {
                    "domain": "secureserver.net",
                    "reason": "After entering login details and clicking to log in, the site shows an adwall and prevents login."
                }
            ],
            "state": "enabled",
            "hash": "7d4ea2f0c3583b807e930b1397e82ba3"
        },
        "fingerprintingTemporaryStorage": {
            "exceptions": [],
            "state": "enabled",
            "hash": "52857469413a66e8b0c7b00de5589162"
        },
        "googleRejected": {
            "exceptions": [],
            "state": "enabled",
            "hash": "52857469413a66e8b0c7b00de5589162"
        },
        "gpc": {
            "state": "enabled",
            "exceptions": [
                {
                    "domain": "allegiantair.com",
                    "reason": "Example URL: https://www.allegiantair.com/seating-checking-boarding; Clicking the 'show details' button in the FAQ sections does nothing."
                },
                {
                    "domain": "costco.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/644"
                },
                {
                    "domain": "duluthtrading.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/700"
                },
                {
                    "domain": "web.whatsapp.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/620"
                }
            ],
            "settings": {
                "gpcHeaderEnabledSites": [
                    "global-privacy-control.glitch.me",
                    "globalprivacycontrol.org",
                    "washingtonpost.com",
                    "nytimes.com",
                    "privacy-test-pages.glitch.me"
                ]
            },
            "hash": "470c77b05c99b8f0986cc40422a59c91"
        },
        "https": {
            "state": "enabled",
            "exceptions": [],
            "hash": "697382e31649d84b01166f1dc6f790d6"
        },
        "incontextSignup": {
            "exceptions": [],
            "state": "disabled",
            "hash": "728493ef7a1488e4781656d3f9db84aa"
        },
        "navigatorInterface": {
            "exceptions": [],
            "state": "enabled",
            "hash": "52857469413a66e8b0c7b00de5589162"
        },
        "nonTracking3pCookies": {
            "settings": {
                "excludedCookieDomains": []
            },
            "exceptions": [],
            "state": "disabled",
            "hash": "d6bd423722e7888ee5372f871395f211"
        },
        "referrer": {
            "exceptions": [
                {
                    "domain": "canadapost-postescanada.ca",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/647"
                }
            ],
            "state": "enabled",
            "hash": "118f6c323fac42ad0ab7ac4c7ac8a93d"
        },
        "requestFilterer": {
            "state": "disabled",
            "exceptions": [],
            "settings": {
                "windowInMs": 0
            },
            "hash": "9439c856372a09f0cfdc9e2e0fd086fd"
        },
        "runtimeChecks": {
            "state": "enabled",
            "exceptions": [
                {
                    "domain": "stackoverflow.com",
                    "reason": "https://github.com/duckduckgo/duckduckgo-privacy-extension/issues/1819"
                },
                {
                    "domain": "stackexchange.com",
                    "reason": "https://github.com/duckduckgo/duckduckgo-privacy-extension/issues/1819"
                }
            ],
            "settings": {
                "taintCheck": "disabled",
                "matchAllDomains": "disabled",
                "matchAllStackDomains": "disabled",
                "overloadInstanceOf": "enabled",
                "elementRemovalTimeout": 1000,
                "domains": [
                    {
                        "domain": "bbc.co.uk"
                    },
                    {
                        "domain": "cnn.com"
                    },
                    {
                        "domain": "preactjs.com"
                    },
                    {
                        "domain": "reactjs.org"
                    },
                    {
                        "domain": "browserbench.org"
                    },
                    {
                        "domain": "xnxx.com"
                    },
                    {
                        "domain": "wikipedia.org"
                    },
                    {
                        "domain": "xvideos.com"
                    },
                    {
                        "domain": "pornhub.com"
                    },
                    {
                        "domain": "reddit.com"
                    },
                    {
                        "domain": "amazon.com"
                    },
                    {
                        "domain": "youtube.com"
                    },
                    {
                        "domain": "facebook.com"
                    },
                    {
                        "domain": "youtube.com"
                    },
                    {
                        "disabled_domain": "stackoverflow.com"
                    },
                    {
                        "domain": "xhamster.com"
                    }
                ],
                "stackDomains": [
                    {
                        "domain": "clean.gg"
                    },
                    {
                        "domain": "googlevideo.com"
                    },
                    {
                        "domain": "nexac.com"
                    },
                    {
                        "domain": "associates-amazon.com"
                    },
                    {
                        "domain": "redd.it"
                    },
                    {
                        "domain": "amazonbusiness.com"
                    },
                    {
                        "domain": "indeed.com"
                    },
                    {
                        "disabled_domain": "stackexchange.com"
                    },
                    {
                        "domain": "bangassets.com"
                    },
                    {
                        "domain": "fontawesome.com"
                    },
                    {
                        "domain": "live-video.net"
                    },
                    {
                        "domain": "behave.com"
                    },
                    {
                        "domain": "imasdk.googleapis.com"
                    },
                    {
                        "domain": "appcast.io"
                    },
                    {
                        "domain": "d3b16pg7hqg2cy.cloudfront.net"
                    },
                    {
                        "domain": "d7qzviu3xw2xc.cloudfront.net"
                    },
                    {
                        "domain": "brightspot.cloud"
                    },
                    {
                        "domain": "dogvlw4b46a0r.cloudfront.net"
                    },
                    {
                        "domain": "d1at2uq7yy5k1j.cloudfront.net"
                    },
                    {
                        "domain": "d2uap9jskdzp2.cloudfront.net"
                    },
                    {
                        "domain": "consumertrack.com"
                    },
                    {
                        "domain": "strpst.com"
                    },
                    {
                        "domain": "d9esmwyn3ffr1.cloudfront.net"
                    },
                    {
                        "domain": "mapbox.com"
                    },
                    {
                        "domain": "mobtrakk.com"
                    },
                    {
                        "domain": "d1qze0i78vhibv.cloudfront.net"
                    },
                    {
                        "domain": "trustarc.com"
                    },
                    {
                        "domain": "wikimedia.org"
                    },
                    {
                        "domain": "phncdn.com"
                    },
                    {
                        "domain": "vfthr.com"
                    },
                    {
                        "domain": "aws.dev"
                    },
                    {
                        "domain": "mediawiki.org"
                    },
                    {
                        "domain": "ds69ljjohz9sr.cloudfront.net"
                    },
                    {
                        "domain": "ad-delivery.net"
                    },
                    {
                        "domain": "wunderkind.co"
                    },
                    {
                        "domain": "d2in0p32vp1pij.cloudfront.net"
                    },
                    {
                        "domain": "trustx.org"
                    },
                    {
                        "domain": "bouncex.net"
                    },
                    {
                        "domain": "ngtv.io"
                    },
                    {
                        "domain": "ds6yc8t7pnx74.cloudfront.net"
                    },
                    {
                        "domain": "d3216uwaav9lg7.cloudfront.net"
                    },
                    {
                        "domain": "veryinterestvids.xyz"
                    },
                    {
                        "domain": "vfgte.com"
                    },
                    {
                        "domain": "schwab.com"
                    },
                    {
                        "domain": "imgur.com"
                    },
                    {
                        "domain": "persprovath.xyz"
                    },
                    {
                        "domain": "outbrainimg.com"
                    },
                    {
                        "domain": "ajax.googleapis.com"
                    },
                    {
                        "domain": "w.org"
                    },
                    {
                        "domain": "fonts.googleapis.com"
                    },
                    {
                        "domain": "turner.com"
                    },
                    {
                        "domain": "googleusercontent.com"
                    },
                    {
                        "domain": "d8aa01cdolqj7.cloudfront.net"
                    },
                    {
                        "domain": "navdmp.com"
                    },
                    {
                        "domain": "xhcdn.com"
                    },
                    {
                        "domain": "imglnke.com"
                    },
                    {
                        "domain": "usbrowserspeed.com"
                    },
                    {
                        "domain": "warnermediacdn.com"
                    },
                    {
                        "domain": "d1xfq2052q7thw.cloudfront.net"
                    },
                    {
                        "domain": "bangcreatives.com"
                    },
                    {
                        "domain": "hotjar.io"
                    },
                    {
                        "domain": "amazonaws.com"
                    },
                    {
                        "domain": "vercel-analytics.com"
                    },
                    {
                        "domain": "boomtrain.com"
                    },
                    {
                        "domain": "cdnbasket.net"
                    },
                    {
                        "domain": "awsstatic.com"
                    },
                    {
                        "domain": "fbcdn.net"
                    },
                    {
                        "domain": "dianomi.com"
                    },
                    {
                        "domain": "amazon.co.uk"
                    },
                    {
                        "domain": "dwrl96u0lgux5.cloudfront.net"
                    },
                    {
                        "domain": "d39dwei46hk6jd.cloudfront.net"
                    },
                    {
                        "domain": "bbci.co.uk"
                    },
                    {
                        "domain": "bbcimg.co.uk"
                    },
                    {
                        "domain": "edigitalsurvey.com"
                    },
                    {
                        "domain": "gscontxt.net"
                    },
                    {
                        "domain": "afcdn.net"
                    },
                    {
                        "domain": "iperceptions.com"
                    },
                    {
                        "disabled_domain": "cookielaw.org"
                    },
                    {
                        "domain": "vscdns.com"
                    },
                    {
                        "domain": "vs3.com"
                    },
                    {
                        "domain": "summerhamster.com"
                    },
                    {
                        "domain": "d1x2hu8k357bsh.cloudfront.net"
                    },
                    {
                        "domain": "d2ef20sk9hi1u3.cloudfront.net"
                    },
                    {
                        "domain": "ggpht.com"
                    },
                    {
                        "domain": "ds7igiccqury3.cloudfront.net"
                    },
                    {
                        "domain": "xvideos.com"
                    },
                    {
                        "domain": "redditmedia.com"
                    },
                    {
                        "domain": "adobe.com"
                    },
                    {
                        "domain": "jnn-pa.googleapis.com"
                    },
                    {
                        "domain": "zetaglobal.net"
                    },
                    {
                        "domain": "gobankingrates.com"
                    },
                    {
                        "domain": "chartbeat.net"
                    },
                    {
                        "domain": "amzndevresources.com"
                    },
                    {
                        "domain": "imdb.com"
                    },
                    {
                        "domain": "wikidata.org"
                    },
                    {
                        "domain": "etahub.com"
                    },
                    {
                        "domain": "revjet.com"
                    },
                    {
                        "domain": "ixiaa.com"
                    },
                    {
                        "domain": "trustedbanana.com"
                    },
                    {
                        "domain": "fanagentmu.pics"
                    },
                    {
                        "domain": "indeed.tech"
                    },
                    {
                        "domain": "outturner.com"
                    },
                    {
                        "domain": "trafficfactory.biz"
                    },
                    {
                        "domain": "d2beun48pmgqbs.cloudfront.net"
                    },
                    {
                        "domain": "wmcdp.io"
                    },
                    {
                        "domain": "bbc.com"
                    },
                    {
                        "domain": "d1uznvntk80v7s.cloudfront.net"
                    },
                    {
                        "domain": "ytimg.com"
                    },
                    {
                        "domain": "beemray.com"
                    },
                    {
                        "domain": "siege-amazon.com"
                    },
                    {
                        "domain": "trafficjunky.net"
                    },
                    {
                        "domain": "consensu.org"
                    },
                    {
                        "domain": "ugdturner.com"
                    },
                    {
                        "domain": "dr3fr5q4g2ul9.cloudfront.net"
                    },
                    {
                        "domain": "cnn.io"
                    },
                    {
                        "domain": "cams.gratis"
                    },
                    {
                        "domain": "d1t40axu4ik42k.cloudfront.net"
                    },
                    {
                        "domain": "optimizely.com"
                    },
                    {
                        "domain": "media-amazon.com"
                    },
                    {
                        "domain": "amazondelivers.jobs"
                    },
                    {
                        "domain": "keywee.co"
                    },
                    {
                        "domain": "zqtk.net"
                    },
                    {
                        "domain": "d23tl967axkois.cloudfront.net"
                    },
                    {
                        "domain": "d3h2kq7so8dggb.cloudfront.net"
                    },
                    {
                        "domain": "bangkazza.com"
                    },
                    {
                        "domain": "effectivemeasure.net"
                    },
                    {
                        "domain": "gravatar.com"
                    },
                    {
                        "domain": "sstatic.net"
                    },
                    {
                        "domain": "d2u4zldaqlyj2w.cloudfront.net"
                    },
                    {
                        "domain": "akamaihd.net"
                    },
                    {
                        "domain": "onaudience.com"
                    },
                    {
                        "domain": "xhpingcdn.com"
                    },
                    {
                        "domain": "eu-1-id5-sync.com"
                    },
                    {
                        "domain": "xvideos-cdn.com"
                    },
                    {
                        "domain": "wp.com"
                    },
                    {
                        "domain": "quantcount.com"
                    },
                    {
                        "domain": "vercel-insights.com"
                    },
                    {
                        "domain": "jobsatamazon.co.uk"
                    },
                    {
                        "domain": "flixcdn.com"
                    },
                    {
                        "domain": "d2h1qfxg5j5pfv.cloudfront.net"
                    },
                    {
                        "domain": "d20kffh39acpue.cloudfront.net"
                    },
                    {
                        "domain": "d9sq4cz0q8up0.cloudfront.net"
                    }
                ],
                "tagModifiers": {
                    "script": {
                        "filters": {
                            "property": [
                                "blocking",
                                "fetchPriority"
                            ],
                            "attribute": [
                                "blocking",
                                "fetchpriority"
                            ]
                        }
                    }
                }
            },
            "hash": "78b94babd0e961860a50106afca4f6b0"
        },
        "serviceworkerInitiatedRequests": {
            "exceptions": [],
            "state": "enabled",
            "hash": "52857469413a66e8b0c7b00de5589162"
        },
        "trackerAllowlist": {
            "state": "enabled",
            "settings": {
                "allowlistedTrackers": {
                    "3lift.com": {
                        "rules": [
                            {
                                "rule": "tlx.3lift.com/header/auction",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "4dex.io": {
                        "rules": [
                            {
                                "rule": "mp.4dex.io/prebid",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "a-mo.net": {
                        "rules": [
                            {
                                "rule": "prebid.a-mo.net/a/c",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "acsbapp.com": {
                        "rules": [
                            {
                                "rule": "acsbapp.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/629"
                            }
                        ]
                    },
                    "addthis.com": {
                        "rules": [
                            {
                                "rule": "s7.addthis.com/js/300/addthis_widget.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/427"
                            },
                            {
                                "rule": "s7.addthis.com/l10n/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/427"
                            },
                            {
                                "rule": "s7.addthis.com/static/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/427"
                            }
                        ]
                    },
                    "adform.net": {
                        "rules": [
                            {
                                "rule": "adx.adform.net/adx/openrtb",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            },
                            {
                                "rule": "c1.adform.net/serving/cookie/match",
                                "domains": [
                                    "dhl.de"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/340"
                            }
                        ]
                    },
                    "ads-twitter.com": {
                        "rules": [
                            {
                                "rule": "static.ads-twitter.com/uwt.js",
                                "domains": [
                                    "hentaihaven.xxx"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/452"
                            }
                        ]
                    },
                    "adsafeprotected.com": {
                        "rules": [
                            {
                                "rule": "static.adsafeprotected.com/favicon.ico",
                                "domains": [
                                    "tf1info.fr"
                                ],
                                "reason": "Adwall displays over video and prevents video from being played."
                            },
                            {
                                "rule": "static.adsafeprotected.com/iasPET.1.js",
                                "domains": [
                                    "corriere.it"
                                ],
                                "reason": "Example URL: https://www.corriere.it/video-articoli/2022/07/13/missione-wwf-liberare-mare-plastica/9abb64de-029d-11ed-a0cc-ad3c68cacbae.shtml;,Clicking on the video to play causes a still frame to show and the video does not continue."
                            },
                            {
                                "rule": "static.adsafeprotected.com/vans-adapter-google-ima.js",
                                "domains": [
                                    "nhl.com"
                                ],
                                "reason": "Videos show a spinner and never load."
                            }
                        ]
                    },
                    "ahacdn.me": {
                        "rules": [
                            {
                                "rule": "ahacdn.me",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/447"
                            }
                        ]
                    },
                    "akadns.net": {
                        "rules": [
                            {
                                "rule": "login.fidelity.com.febsec-fidelity.com.akadns.net",
                                "domains": [
                                    "fidelity.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/677"
                            }
                        ]
                    },
                    "aldi-digital.co.uk": {
                        "rules": [
                            {
                                "rule": "assets.aldi-digital.co.uk/assets/050b4966c22c430e5c9308903ebb87e1/dist/scripts/main.js",
                                "domains": [
                                    "aldi.co.uk"
                                ],
                                "reason": "Product lists don't render."
                            }
                        ]
                    },
                    "alicdn.com": {
                        "rules": [
                            {
                                "rule": "aeis.alicdn.com/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            },
                            {
                                "rule": "aeproductsourcesite.alicdn.com/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            },
                            {
                                "rule": "assets.alicdn.com/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            },
                            {
                                "rule": "is.alicdn.com/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            },
                            {
                                "rule": "alicdn.com",
                                "domains": [
                                    "aliexpress.us"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/460"
                            }
                        ]
                    },
                    "amazon-adsystem.com": {
                        "rules": [
                            {
                                "rule": "c.amazon-adsystem.com/aax2/apstag.js",
                                "domains": [
                                    "corriere.it",
                                    "eurogamer.net",
                                    "seattletimes.com"
                                ],
                                "reason": "corriere.it - ,Example URL: https://www.corriere.it/video-articoli/2022/07/13/missione-wwf-liberare-mare-plastica/9abb64de-029d-11ed-a0cc-ad3c68cacbae.shtml;,Clicking on the video to play causes a still frame to show and the video does not continue.,eurogamer.net, seattletimes.com - An unskippable adwall appears which prevents interaction with the page."
                            }
                        ]
                    },
                    "azure.net": {
                        "rules": [
                            {
                                "rule": "amp.azure.net/libs/amp/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/504"
                            }
                        ]
                    },
                    "azureedge.net": {
                        "rules": [
                            {
                                "rule": "orderweb-cdn-endpoint-centralus.azureedge.net/js/chunk-vendors.js",
                                "domains": [
                                    "chipotle.com"
                                ],
                                "reason": "Site loads blank and cannot be interacted with."
                            }
                        ]
                    },
                    "bc0a.com": {
                        "rules": [
                            {
                                "rule": "marvel-b1-cdn.bc0a.com/f00000000269380/www.beretta.com/assets/",
                                "domains": [
                                    "beretta.com"
                                ],
                                "reason": "Example URL1: https://www.beretta.com/en-us/womens-clothing/caps-and-hats/;,Example URL2: https://www.beretta.com/en-us/mens-clothing/caps-and-hats/lp-trucker-hat/;,Various product and product-related images do not render - e.g., main product images on product pages, product images in product listings, etc."
                            }
                        ]
                    },
                    "bing.com": {
                        "rules": [
                            {
                                "rule": "r.bing.com/rp/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "See https://github.com/duckduckgo/privacy-configuration/issues/321.,These requests are associated with map/location functionality on websites."
                            },
                            {
                                "rule": "th.bing.com/th",
                                "domains": [
                                    "drudgereport.com"
                                ],
                                "reason": "On the homepage (drudgereport.com), some images are fetched from bing.com.,When we block these requests, the images do not render, and the page appears to have blank boxes.,Note that requests can be of the form th.bing.com/th?id=... or th.bing.com/th/id/..., hence we unblock the common path here."
                            },
                            {
                                "rule": "www.bing.com/api/maps/mapcontrol",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "See https://github.com/duckduckgo/privacy-configuration/issues/321.,This request is associated with map/location functionality on websites."
                            },
                            {
                                "rule": "www.bing.com/api/v6/Places/AutoSuggest",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "See https://github.com/duckduckgo/privacy-configuration/issues/321.,This request is associated with map/location auto-suggest functionality on websites."
                            },
                            {
                                "rule": "www.bing.com/maps/sdk/mapcontrol",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/321"
                            },
                            {
                                "rule": "www.bing.com/maps/sdkrelease/mapcontrol",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "See https://github.com/duckduckgo/privacy-configuration/issues/321.,This request is associated with map/location functionality on websites."
                            },
                            {
                                "rule": "www.bing.com/rp/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "See https://github.com/duckduckgo/privacy-configuration/issues/321.,These requests are associated with map/location functionality on websites."
                            }
                        ]
                    },
                    "captcha-delivery.com": {
                        "rules": [
                            {
                                "rule": "captcha-delivery.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/501"
                            }
                        ]
                    },
                    "casalemedia.com": {
                        "rules": [
                            {
                                "rule": "htlb.casalemedia.com/cygnus",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "cloudflare.com": {
                        "rules": [
                            {
                                "rule": "cdnjs.cloudflare.com/ajax/libs/fingerprintjs2/1.8.6/fingerprint2.min.js",
                                "domains": [
                                    "winnipegfreepress.com"
                                ],
                                "reason": "Example URL: https://www.winnipegfreepress.com/local/city-will-try-to-fill-money-losing-ex-canada-post-office-576646662.html,Main text content on article does not load."
                            },
                            {
                                "rule": "cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js",
                                "domains": [
                                    "2000mules.com"
                                ],
                                "reason": "Loading percentage hits 100% and the site does not proceed to display usual content."
                            },
                            {
                                "rule": "challenges.cloudflare.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/641"
                            }
                        ]
                    },
                    "cloudfront.net": {
                        "rules": [
                            {
                                "rule": "d3oxtup47gylpj.cloudfront.net/theme/onlyfans/spa/chunk-vendors.js",
                                "domains": [
                                    "onlyfans.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/440"
                            },
                            {
                                "rule": "d3nn82uaxijpm6.cloudfront.net/",
                                "domains": [
                                    "strava.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/748"
                            },
                            {
                                "rule": "d9k0w0y3delq8.cloudfront.net",
                                "domains": [
                                    "hoyolab.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/754"
                            }
                        ]
                    },
                    "computerworld.com": {
                        "rules": [
                            {
                                "rule": "cmpv2.computerworld.com/",
                                "domains": [
                                    "computerworld.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/344"
                            }
                        ]
                    },
                    "connatix.com": {
                        "rules": [
                            {
                                "rule": "connatix.com",
                                "domains": [
                                    "accuweather.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/768"
                            }
                        ]
                    },
                    "cookiepro.com": {
                        "rules": [
                            {
                                "rule": "cookie-cdn.cookiepro.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/466"
                            }
                        ]
                    },
                    "cquotient.com": {
                        "rules": [
                            {
                                "rule": "cdn.cquotient.com/js/v2/gretel.min.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/486"
                            },
                            {
                                "rule": "e.cquotient.com/recs/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/486"
                            }
                        ]
                    },
                    "criteo.com": {
                        "rules": [
                            {
                                "rule": "bidder.criteo.com/cdb",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "criteo.net": {
                        "rules": [
                            {
                                "rule": "static.criteo.net/js/ld/publishertag.js",
                                "domains": [
                                    "wp.pl"
                                ],
                                "reason": "Adwall appears which reappears when dismissed. The adwall prevents interaction with the page."
                            },
                            {
                                "rule": "static.criteo.net/js/ld/publishertag.prebid.js",
                                "domains": [
                                    "wp.pl"
                                ],
                                "reason": "Adwall appears which reappears when dismissed. The adwall prevents interaction with the page."
                            }
                        ]
                    },
                    "cxense.com": {
                        "rules": [
                            {
                                "rule": "api.cxense.com/public/widget/data",
                                "domains": [
                                    "wsj.com"
                                ],
                                "reason": "Opinion section article elements do not render. Note that Firefox Enhanced Tracking Protection may prevent mitigation from succeeding on Firefox."
                            }
                        ]
                    },
                    "daumcdn.net": {
                        "rules": [
                            {
                                "rule": "daumcdn.net",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/444"
                            }
                        ]
                    },
                    "demdex.net": {
                        "rules": [
                            {
                                "rule": "dpm.demdex.net/id",
                                "domains": [
                                    "dhl.de",
                                    "homedepot.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/393"
                            }
                        ]
                    },
                    "derstandard.de": {
                        "rules": [
                            {
                                "rule": "spcmp.r53.derstandard.de/",
                                "domains": [
                                    "derstandard.de"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/344"
                            }
                        ]
                    },
                    "doubleclick.net": {
                        "rules": [
                            {
                                "rule": "securepubads.g.doubleclick.net/gampad/ads",
                                "domains": [
                                    "ah.nl"
                                ],
                                "reason": "'Bonus offer' elements do not render and are not clickable."
                            },
                            {
                                "rule": "pubads.g.doubleclick.net/gampad/ads",
                                "domains": [
                                    "nhl.com",
                                    "viki.com"
                                ],
                                "reason": "nhl.com - Videos show a spinner and never load.,viki.com - after a video has played for a few seconds an adwall pops up. Clicking 'I've turned off my adblocker' resets the video, then after a few seconds the adwall pops up again."
                            },
                            {
                                "rule": "pubads.g.doubleclick.net/ssai/event/",
                                "domains": [
                                    "cbssports.com"
                                ],
                                "reason": "Live videos do not load or render."
                            },
                            {
                                "rule": "securepubads.g.doubleclick.net/tag/js/gpt.js",
                                "domains": [
                                    "ah.nl",
                                    "wunderground.com",
                                    "youmath.it"
                                ],
                                "reason": "ah.nl - 'Bonus offer' elements do not render and are not clickable.,wunderground.com - Video element does not display.,youmath.it - Adwall displays which prevents page interaction and resets the page view when clicked."
                            },
                            {
                                "rule": "securepubads.g.doubleclick.net/gpt/pubads_impl_",
                                "domains": [
                                    "ah.nl",
                                    "wunderground.com"
                                ],
                                "reason": "ah.nl - 'Bonus offer' elements do not render and are not clickable.,wunderground.com - Video element does not display."
                            },
                            {
                                "rule": "securepubads.g.doubleclick.net/pagead/ppub_config",
                                "domains": [
                                    "weather.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/415"
                            }
                        ]
                    },
                    "dynamicyield.com": {
                        "rules": [
                            {
                                "rule": "cdn.dynamicyield.com/api/",
                                "domains": [
                                    "brooklinen.com",
                                    "carters.com",
                                    "seatosummit.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/535"
                            }
                        ]
                    },
                    "edgekey.net": {
                        "rules": [
                            {
                                "rule": "scene7.com.edgekey.net/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/356"
                            },
                            {
                                "rule": "alicdn.com.edgekey.net/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/570"
                            },
                            {
                                "rule": "nintendo.com.edgekey.net/account/js/common.js",
                                "domains": [
                                    "nintendo.com"
                                ],
                                "reason": "CNAME version of nintendo.com exception"
                            },
                            {
                                "rule": "cdn.agoda.net.edgekey.net/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/771"
                            }
                        ]
                    },
                    "edgesuite.net": {
                        "rules": [
                            {
                                "rule": "sky.com.edgesuite.net/assets/sky_common.js",
                                "domains": [
                                    "sky.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/342"
                            },
                            {
                                "rule": "a.espncdn.com.stls.edgesuite.net/",
                                "domains": [
                                    "espn.co.uk",
                                    "espn.com",
                                    "espn.com.au",
                                    "espn.com.br",
                                    "espn.com.mx",
                                    "espn.in",
                                    "espnfc.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/750"
                            }
                        ]
                    },
                    "ezoic.com": {
                        "rules": [
                            {
                                "rule": "videosvc.ezoic.com/play",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/468"
                            },
                            {
                                "rule": "video-streaming.ezoic.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/468"
                            }
                        ]
                    },
                    "ezoic.net": {
                        "rules": [
                            {
                                "rule": "g.ezoic.net",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/468"
                            }
                        ]
                    },
                    "ezoiccdn.com": {
                        "rules": [
                            {
                                "rule": "sf.ezoiccdn.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/468"
                            }
                        ]
                    },
                    "facebook.net": {
                        "rules": [
                            {
                                "rule": "connect.facebook.net/en_US/sdk.js",
                                "domains": [
                                    "bandsintown.com",
                                    "nextdoor.co.uk",
                                    "nextdoor.com"
                                ],
                                "reason": "bandsintown.com - Ticket page renders blank. With this exception the page redirects to ticketspice.com.,nextdoor.co.uk, nextdoor.com - Facebook login option appears greyed out and cannot be clicked."
                            },
                            {
                                "rule": "connect.facebook.net/en_US/fbevents.js",
                                "domains": [
                                    "wp.pl"
                                ],
                                "reason": "Adwall appears which reappears when dismissed. The adwall prevents interaction with the page."
                            }
                        ]
                    },
                    "fastly.net": {
                        "rules": [
                            {
                                "rule": "mslc-prod-herokuapp-com.global.ssl.fastly.net/main.8736233213226195.js",
                                "domains": [
                                    "masslottery.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/332"
                            },
                            {
                                "rule": "ticketmaster4.map.fastly.net/eps-d",
                                "domains": [
                                    "ticketmaster.ca",
                                    "ticketmaster.com",
                                    "ticketmaster.com.au",
                                    "ticketmaster.com.mx"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/575"
                            },
                            {
                                "rule": "target-opus.map.fastly.net/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/635"
                            }
                        ]
                    },
                    "fox.com": {
                        "rules": [
                            {
                                "rule": "fox.com",
                                "domains": [
                                    "adrise.tv",
                                    "fncstatic.com",
                                    "fox10phoenix.com",
                                    "fox13news.com",
                                    "fox26houston.com",
                                    "fox29.com",
                                    "fox2detroit.com",
                                    "fox32chicago.com",
                                    "fox35orlando.com",
                                    "fox46charlotte.com",
                                    "fox4news.com",
                                    "fox5atlanta.com",
                                    "fox5dc.com",
                                    "fox5ny.com",
                                    "fox7austin.com",
                                    "fox9.com",
                                    "foxbusiness.com",
                                    "foxla.com",
                                    "foxnews.com",
                                    "foxsports.com",
                                    "foxsportsasia.com",
                                    "foxsportsgo.com",
                                    "foxweather.com",
                                    "ktvu.com",
                                    "tubi.io",
                                    "tubi.tv",
                                    "tubi.video",
                                    "tubitv.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/460"
                            }
                        ]
                    },
                    "fwmrm.net": {
                        "rules": [
                            {
                                "rule": "2a7e9.v.fwmrm.net/ad/g/1",
                                "domains": [
                                    "channel4.com"
                                ],
                                "reason": "Unskippable adblock warning when trying to play a video."
                            }
                        ]
                    },
                    "geetest.com": {
                        "rules": [
                            {
                                "rule": "api.geetest.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/462"
                            },
                            {
                                "rule": "static.geetest.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/462"
                            }
                        ]
                    },
                    "gemius.pl": {
                        "rules": [
                            {
                                "rule": "gapl.hit.gemius.pl/gplayer.js",
                                "domains": [
                                    "tvp.pl"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/376"
                            },
                            {
                                "rule": "pro.hit.gemius.pl/gstream.js",
                                "domains": [
                                    "tvp.pl"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/376"
                            },
                            {
                                "rule": "wp.hit.gemius.pl/xgemius.js",
                                "domains": [
                                    "wp.pl"
                                ],
                                "reason": "Adwall appears which reappears when dismissed. The adwall prevents interaction with the page."
                            }
                        ]
                    },
                    "getshogun.com": {
                        "rules": [
                            {
                                "rule": "cdn.getshogun.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/450"
                            },
                            {
                                "rule": "lib.getshogun.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/450"
                            }
                        ]
                    },
                    "google-analytics.com": {
                        "rules": [
                            {
                                "rule": "google-analytics.com/analytics.js",
                                "domains": [
                                    "doterra.com",
                                    "easyjet.com"
                                ],
                                "reason": "doterra.com - For doterra.com/login/loading, the page shows a loading indicator and never redirects.,easyjet.com - Clicking 'Show Worldwide flights' after entering parameters for a worldwide flight in the flight viewing form does nothing."
                            },
                            {
                                "rule": "www.google-analytics.com/plugins/ua/ecommerce.js",
                                "domains": [
                                    "doterra.com"
                                ],
                                "reason": "For doterra.com/login/loading, the page shows a loading indicator and never redirects."
                            }
                        ]
                    },
                    "google.co.uk": {
                        "rules": [
                            {
                                "rule": "maps.google.co.uk/maps",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/472"
                            }
                        ]
                    },
                    "google.com": {
                        "rules": [
                            {
                                "rule": "accounts.google.com/o/oauth2/iframerpc",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/489"
                            },
                            {
                                "rule": "accounts.google.com/o/oauth2/iframe",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/489"
                            },
                            {
                                "rule": "apis.google.com/js/platform.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/489"
                            },
                            {
                                "rule": "apis.google.com/_/scs/abc-static/_/js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/489"
                            },
                            {
                                "rule": "cse.google.com/cse.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/475"
                            },
                            {
                                "rule": "cse.google.com/cse/element/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/475"
                            },
                            {
                                "rule": "google.com/cse/cse.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/475"
                            },
                            {
                                "rule": "www.google.com/cse/static/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/475"
                            },
                            {
                                "rule": "www.google.com/maps/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/472"
                            }
                        ]
                    },
                    "googlesyndication.com": {
                        "rules": [
                            {
                                "rule": "pagead2.googlesyndication.com/pagead/js/adsbygoogle.js",
                                "domains": [
                                    "duden.de",
                                    "magicgameworld.com",
                                    "youmath.it"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/388"
                            },
                            {
                                "rule": "tpc.googlesyndication.com/pagead/js/loader21.html",
                                "domains": [
                                    "laprensa.hn",
                                    "rumble.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/388"
                            }
                        ]
                    },
                    "googletagmanager.com": {
                        "rules": [
                            {
                                "rule": "googletagmanager.com/gtm.js",
                                "domains": [
                                    "ah.nl",
                                    "dailyherald.com",
                                    "emirates.com",
                                    "iltalehti.fi",
                                    "kingarthurbaking.com",
                                    "pickfu.com",
                                    "rbcroyalbank.com"
                                ],
                                "reason": "ah.nl - 'Bonus offer' elements do not render and are not clickable.,dailyherald.com - Article images render as grey boxes.,emirates.com - After filling out login details and clicking to proceed, a loading spinners shows on the proceed button and the login does not progress.,iltalehti.fi - Article video renders as a blank box.,kingarthurbaking.com - https://github.com/duckduckgo/privacy-configuration/issues/348,pickfu.com - https://github.com/duckduckgo/privacy-configuration/issues/346,rbcroyalbank.com - Investments page renders blank."
                            }
                        ]
                    },
                    "gstatic.com": {
                        "rules": [
                            {
                                "rule": "maps.gstatic.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/472"
                            },
                            {
                                "rule": "www.gstatic.com/_/mss/boq-identity/_/js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/489"
                            }
                        ]
                    },
                    "iesnare.com": {
                        "rules": [
                            {
                                "rule": "mpsnare.iesnare.com/snare.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/669"
                            }
                        ]
                    },
                    "iheart.com": {
                        "rules": [
                            {
                                "rule": "iheart.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/760"
                            }
                        ]
                    },
                    "inq.com": {
                        "rules": [
                            {
                                "rule": "inq.com/chatrouter",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            },
                            {
                                "rule": "inq.com/chatskins",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            },
                            {
                                "rule": "inq.com/tagserver/init",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            },
                            {
                                "rule": "inq.com/tagserver/launch",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            },
                            {
                                "rule": "inq.com/tagserver/postToServer",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            }
                        ]
                    },
                    "instagram.com": {
                        "rules": [
                            {
                                "rule": "platform.instagram.com/en_US/embeds.js",
                                "domains": [
                                    "livejournal.com"
                                ],
                                "reason": "Instagram embeds as main article content render as grey boxes."
                            },
                            {
                                "rule": "www.instagram.com/embed.js",
                                "domains": [
                                    "buzzfeed.com",
                                    "livejournal.com"
                                ],
                                "reason": "Instagram embeds as main article content render as grey boxes."
                            }
                        ]
                    },
                    "jimstatic.com": {
                        "rules": [
                            {
                                "rule": "assets.jimstatic.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/496"
                            }
                        ]
                    },
                    "klarnaservices.com": {
                        "rules": [
                            {
                                "rule": "na-library.klarnaservices.com/lib.js",
                                "domains": [
                                    "brooksrunning.com",
                                    "joann.com"
                                ],
                                "reason": "brooksrunning.com - When switching between product variants (e.g., different shoe colours) a loading spinner shows and the variant does not load.,joann.com - When switching between product variants (e.g., different shirt colours) the page shows an overlay and further interaction is prevented."
                            }
                        ]
                    },
                    "klaviyo.com": {
                        "rules": [
                            {
                                "rule": "www.klaviyo.com/media/js/public/klaviyo_subscribe.js",
                                "domains": [
                                    "fearofgod.com",
                                    "shopyalehome.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/362"
                            },
                            {
                                "rule": "klaviyo.com/",
                                "domains": [
                                    "kmail-lists.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/362"
                            }
                        ]
                    },
                    "listrakbi.com": {
                        "rules": [
                            {
                                "rule": "cdn.listrakbi.com/scripts/script.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/457"
                            }
                        ]
                    },
                    "liveperson.net": {
                        "rules": [
                            {
                                "rule": "liveperson.net",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "Chat button appears faded and cannot be interacted with."
                            }
                        ]
                    },
                    "loggly.com": {
                        "rules": [
                            {
                                "rule": "cloudfront.loggly.com/js/loggly.tracker-2.1.min.js",
                                "domains": [
                                    "rte.ie"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/681"
                            }
                        ]
                    },
                    "lpsnmedia.net": {
                        "rules": [
                            {
                                "rule": "lpsnmedia.net",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "Chat button appears faded and cannot be interacted with."
                            }
                        ]
                    },
                    "ltwebstatic.com": {
                        "rules": [
                            {
                                "rule": "sheinsz.ltwebstatic.com/she_dist/libs/geetest/fullpage.1.1.9.js",
                                "domains": [
                                    "shein.co.uk",
                                    "shein.com"
                                ],
                                "reason": "When attempting to create an account (after filling out registration form and clicking 'Register'), there is an 'access timed out' warning, and account creation does not proceed."
                            }
                        ]
                    },
                    "medicare.gov": {
                        "rules": [
                            {
                                "rule": "frontend.medicare.gov/static/js/2.6c6651b4.chunk.js",
                                "domains": [
                                    "medicare.gov"
                                ],
                                "reason": "Navigation bar at top of site does not display, preventing easy access to e.g., site login.,Note that this CNAMEs to iservprod.medicare.gov.edgekey.net at time of mitiagtion."
                            }
                        ]
                    },
                    "nextdoor.com": {
                        "rules": [
                            {
                                "rule": "nextdoor.com",
                                "domains": [
                                    "nextdoor.co.uk"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/460"
                            }
                        ]
                    },
                    "nintendo.com": {
                        "rules": [
                            {
                                "rule": "cdn.accounts.nintendo.com/account/js/common.js",
                                "domains": [
                                    "nintendo.com"
                                ],
                                "reason": "Accounts page renders blank. Download buttons show loading stars and never finish loading. Pricing information doesn't load. Note that cdn.accounts.nintendo.com CNAMEs to star.accounts.nintendo.com.edgekey.net at the time of mitigation.; CNAME ENTRY GENERATED FROM: nintendo.com.edgekey.net"
                            },
                            {
                                "rule": "api.ec.nintendo.com/account/js/common.js",
                                "domains": [
                                    "nintendo.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: nintendo.com.edgekey.net"
                            },
                            {
                                "rule": "cdn.my.nintendo.com/account/js/common.js",
                                "domains": [
                                    "nintendo.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: nintendo.com.edgekey.net"
                            }
                        ]
                    },
                    "nuance.com": {
                        "rules": [
                            {
                                "rule": "nuance.com/media/launch",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            },
                            {
                                "rule": "nuance.com/media/sites",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/479"
                            }
                        ]
                    },
                    "omnitagjs.com": {
                        "rules": [
                            {
                                "rule": "hb-api.omnitagjs.com/hb-api/prebid/v1",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "onlyfans.com": {
                        "rules": [
                            {
                                "rule": "static.onlyfans.com",
                                "domains": [
                                    "onlyfans.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/440"
                            }
                        ]
                    },
                    "openx.net": {
                        "rules": [
                            {
                                "rule": "venatusmedia-d.openx.net/w/1.0/arj",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "opta.net": {
                        "rules": [
                            {
                                "rule": "secure.widget.cloud.opta.net/v3/v3.opta-widgets.js",
                                "domains": [
                                    "abc.net.au",
                                    "emol.com"
                                ],
                                "reason": "abc.net.au - Error message displays in place of scoreboard (scoreboard does not show).,emol.com - Scoreboard does not render."
                            }
                        ]
                    },
                    "osano.com": {
                        "rules": [
                            {
                                "rule": "dsar.api.osano.com/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/529"
                            }
                        ]
                    },
                    "pardot.com": {
                        "rules": [
                            {
                                "rule": "go.pardot.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/625"
                            }
                        ]
                    },
                    "plotrabbit.com": {
                        "rules": [
                            {
                                "rule": "plotrabbit.com",
                                "domains": [
                                    "cbssports.com"
                                ],
                                "reason": "Live videos do not load or render."
                            }
                        ]
                    },
                    "primaryarms.com": {
                        "rules": [
                            {
                                "rule": "images.primaryarms.com/f00000000191638/www.primaryarms.com/SSP%20Applications/NetSuite%20Inc.%20-%20SCA%20Mont%20Blanc/Development/img/",
                                "domains": [
                                    "primaryarms.com"
                                ],
                                "reason": "Product images on the main page don't render.,Note that this CNAMEs to marvel-b4-cdn.bc0a.com at time of mitigation."
                            },
                            {
                                "rule": "images.primaryarms.com/f00000000191638/www.primaryarms.com/core/media/media.nl",
                                "domains": [
                                    "primaryarms.com"
                                ],
                                "reason": "Images in the large scrolling image banner on main page do not render.,Note that this CNAMEs to marvel-b4-cdn.bc0a.com at time of mitigation."
                            }
                        ]
                    },
                    "privacy-center.org": {
                        "rules": [
                            {
                                "rule": "sdk.privacy-center.org",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/339"
                            }
                        ]
                    },
                    "privacy-mgmt.com": {
                        "rules": [
                            {
                                "rule": "privacy-mgmt.com/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/344"
                            }
                        ]
                    },
                    "privacymanager.io": {
                        "rules": [
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/605.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/650.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/847.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/assets/icons/.*.svg",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/defaultTheme.css",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/index.html",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/main.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/polyfills.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/runtime.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "cmp-consent-tool.privacymanager.io/latest/vendor.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "gdpr.privacymanager.io/1/gdpr.bundle.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "gdpr.privacymanager.io/latest/gdpr.bundle.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "gdpr-wrapper.privacymanager.io/gdpr/.*/gdpr-liveramp.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "gdpr-wrapper.privacymanager.io/gdpr/.*/manager-logo.png",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            },
                            {
                                "rule": "vendors.privacymanager.io/vendor-list.json",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/334"
                            }
                        ]
                    },
                    "pubmatic.com": {
                        "rules": [
                            {
                                "rule": "ads.pubmatic.com/AdServer/",
                                "domains": [
                                    "hindustantimes.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/388"
                            },
                            {
                                "rule": "hbopenbid.pubmatic.com/translator",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "quantserve.com": {
                        "rules": [
                            {
                                "rule": "secure.quantserve.com/quant.js",
                                "domains": [
                                    "aternos.org"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/328"
                            }
                        ]
                    },
                    "rncdn7.com": {
                        "rules": [
                            {
                                "rule": "rncdn7.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/436"
                            }
                        ]
                    },
                    "rumble.com": {
                        "rules": [
                            {
                                "rule": "rumble.com/j/p/ui.r2.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/631"
                            }
                        ]
                    },
                    "scene7.com": {
                        "rules": [
                            {
                                "rule": "scene7.com/is/image/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/356"
                            },
                            {
                                "rule": "scene7.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/356"
                            }
                        ]
                    },
                    "searchspring.io": {
                        "rules": [
                            {
                                "rule": "searchspring.io",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/435"
                            }
                        ]
                    },
                    "segment.com": {
                        "rules": [
                            {
                                "rule": "cdn.segment.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/484"
                            }
                        ]
                    },
                    "shopeemobile.com": {
                        "rules": [
                            {
                                "rule": "deo.shopeemobile.com/shopee",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/442"
                            }
                        ]
                    },
                    "shortpixel.ai": {
                        "rules": [
                            {
                                "rule": "cdn.shortpixel.ai/assets/js/bundles/spai-lib-bg",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/712"
                            }
                        ]
                    },
                    "spiegel.de": {
                        "rules": [
                            {
                                "rule": "sp-spiegel-de.spiegel.de/",
                                "domains": [
                                    "spiegel.de"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/344"
                            }
                        ]
                    },
                    "spot.im": {
                        "rules": [
                            {
                                "rule": "spot.im/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/622"
                            }
                        ]
                    },
                    "strpst.com": {
                        "rules": [
                            {
                                "rule": "strpst.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/438"
                            }
                        ]
                    },
                    "theplatform.com": {
                        "rules": [
                            {
                                "rule": "link.theplatform.com/s/",
                                "domains": [
                                    "nbcsports.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/512"
                            },
                            {
                                "rule": "pdk.theplatform.com/pdk6/current/pdk/player.js",
                                "domains": [
                                    "eonline.com"
                                ],
                                "reason": "Videos don't play (blank box after clicking to play)."
                            },
                            {
                                "rule": "pdk.theplatform.com/pdk6/next/pdk/player.js",
                                "domains": [
                                    "nbcsports.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/512"
                            }
                        ]
                    },
                    "tiqcdn.com": {
                        "rules": [
                            {
                                "rule": "tags.tiqcdn.com/utag/lgi/vm-uk/prod/utag.77.js",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "Chat button appears faded and cannot be interacted with."
                            }
                        ]
                    },
                    "trustpilot.com": {
                        "rules": [
                            {
                                "rule": "widget.trustpilot.com/bootstrap/v5/tp.widget.bootstrap.min.js",
                                "domains": [
                                    "domesticandgeneral.com"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/466"
                            }
                        ]
                    },
                    "twitter.com": {
                        "rules": [
                            {
                                "rule": "platform.twitter.com/embed/embed",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/717"
                            },
                            {
                                "rule": "platform.twitter.com/widgets/tweet_button",
                                "domains": [
                                    "winnipegfreepress.com"
                                ],
                                "reason": "Tweet button does not render."
                            }
                        ]
                    },
                    "usabilla.com": {
                        "rules": [
                            {
                                "rule": "api.usabilla.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/482"
                            },
                            {
                                "rule": "w.usabilla.com",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/482"
                            }
                        ]
                    },
                    "usercentrics.eu": {
                        "rules": [
                            {
                                "rule": "api.usercentrics.eu/settings",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "api.usercentrics.eu/tcf",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "api.usercentrics.eu/translations",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "app.usercentrics.eu/browser",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "app.usercentrics.eu/session/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "graphql.usercentrics.eu/graphql",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "privacy-proxy.usercentrics.eu/latest/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            },
                            {
                                "rule": "aggregator.service.usercentrics.eu/aggregate",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/477"
                            }
                        ]
                    },
                    "viafoura.net": {
                        "rules": [
                            {
                                "rule": "cdn.viafoura.net",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/763"
                            }
                        ]
                    },
                    "yandex.ru": {
                        "rules": [
                            {
                                "rule": "frontend.vh.yandex.ru/player/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/366"
                            },
                            {
                                "rule": "strm.yandex.ru/get/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/366"
                            },
                            {
                                "rule": "strm.yandex.ru/vh-special-converted/vod-content/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/366"
                            }
                        ]
                    },
                    "yotpo.com": {
                        "rules": [
                            {
                                "rule": "api.yotpo.com/products/.*/.*/bottomline",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "api.yotpo.com/questions/send_confirmation_mail",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "api.yotpo.com/v1/widget/reviews",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "cdn-yotpo-images-production.yotpo.com/Product/.*/.*/square.jpg",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "staticw2.yotpo.com/.*/widget.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "staticw2.yotpo.com/.*/widget.css",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "staticw2.yotpo.com/assets/yotpo-widget-font.woff",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "staticw2.yotpo.com/batch/app_key/.*/domain_key/.*/widget/main_widget",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "staticw2.yotpo.com/batch/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            },
                            {
                                "rule": "api.yotpo.com/reviews/.*/vote",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/348"
                            }
                        ]
                    },
                    "yottaa.com": {
                        "rules": [
                            {
                                "rule": "cdn.yottaa.com/rapid.min.",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "https://github.com/duckduckgo/privacy-configuration/issues/492"
                            }
                        ]
                    },
                    "zeustechnology.com": {
                        "rules": [
                            {
                                "rule": "seattle-times.zeustechnology.com/main.js",
                                "domains": [
                                    "seattletimes.com"
                                ],
                                "reason": "An unskippable adwall appears which prevents interaction with the page."
                            }
                        ]
                    },
                    "fidelity.com": {
                        "rules": [
                            {
                                "rule": "login.fidelity.com",
                                "domains": [
                                    "fidelity.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: login.fidelity.com.febsec-fidelity.com.akadns.net"
                            }
                        ]
                    },
                    "hoyoverse.com": {
                        "rules": [
                            {
                                "rule": "webstatic.hoyoverse.com",
                                "domains": [
                                    "hoyolab.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: d9k0w0y3delq8.cloudfront.net"
                            }
                        ]
                    },
                    "marksandspencer.com": {
                        "rules": [
                            {
                                "rule": "asset1.marksandspencer.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "bareminerals.com": {
                        "rules": [
                            {
                                "rule": "assets.bareminerals.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "biglots.com": {
                        "rules": [
                            {
                                "rule": "assets.biglots.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "cox.com": {
                        "rules": [
                            {
                                "rule": "assets.cox.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "deloitte.com": {
                        "rules": [
                            {
                                "rule": "assets.deloitte.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "hpe.com": {
                        "rules": [
                            {
                                "rule": "assets.ext.hpe.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "hdsupplysolutions.com": {
                        "rules": [
                            {
                                "rule": "assets.hdsupplysolutions.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "langhamhotels.com": {
                        "rules": [
                            {
                                "rule": "assets.langhamhotels.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "lumen.com": {
                        "rules": [
                            {
                                "rule": "assets.lumen.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "spectrumenterprise.com": {
                        "rules": [
                            {
                                "rule": "assets.spectrumenterprise.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "microsoft.com": {
                        "rules": [
                            {
                                "rule": "cdn-dynmedia-1.microsoft.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "bajajfinserv.in": {
                        "rules": [
                            {
                                "rule": "cms-assets.bajajfinserv.in/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "hunterdouglas.com": {
                        "rules": [
                            {
                                "rule": "content.hunterdouglas.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "ihg.com": {
                        "rules": [
                            {
                                "rule": "digital.ihg.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "accenture.com": {
                        "rules": [
                            {
                                "rule": "dynamicmedia.accenture.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "assaabloy.com": {
                        "rules": [
                            {
                                "rule": "gw-assets.assaabloy.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "acer.com": {
                        "rules": [
                            {
                                "rule": "images.acer.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "altrarunning.com": {
                        "rules": [
                            {
                                "rule": "images.altrarunning.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "ansys.com": {
                        "rules": [
                            {
                                "rule": "images.ansys.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "asics.com": {
                        "rules": [
                            {
                                "rule": "images.asics.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "blackberry.com": {
                        "rules": [
                            {
                                "rule": "images.blackberry.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "blue-tomato.com": {
                        "rules": [
                            {
                                "rule": "images.blue-tomato.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "heb.com": {
                        "rules": [
                            {
                                "rule": "images.heb.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "hugoboss.com": {
                        "rules": [
                            {
                                "rule": "images.hugoboss.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "jansport.com": {
                        "rules": [
                            {
                                "rule": "images.jansport.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "keurig.com": {
                        "rules": [
                            {
                                "rule": "images.keurig.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "kirklands.com": {
                        "rules": [
                            {
                                "rule": "images.kirklands.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "kwikset.com": {
                        "rules": [
                            {
                                "rule": "images.kwikset.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "lee.com": {
                        "rules": [
                            {
                                "rule": "images.lee.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "lennoxpros.com": {
                        "rules": [
                            {
                                "rule": "images.lennoxpros.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "lululemon.com": {
                        "rules": [
                            {
                                "rule": "images.lululemon.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "pfisterfaucets.com": {
                        "rules": [
                            {
                                "rule": "images.pfisterfaucets.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "philips.com": {
                        "rules": [
                            {
                                "rule": "images.philips.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            },
                            {
                                "rule": "www.assets.lighting.philips.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "selfridges.com": {
                        "rules": [
                            {
                                "rule": "images.selfridges.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "shaneco.com": {
                        "rules": [
                            {
                                "rule": "images.shaneco.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "shophq.com": {
                        "rules": [
                            {
                                "rule": "images.shophq.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "tervis.com": {
                        "rules": [
                            {
                                "rule": "images.tervis.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "thenorthface.com": {
                        "rules": [
                            {
                                "rule": "images.thenorthface.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "timberland.com": {
                        "rules": [
                            {
                                "rule": "images.timberland.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "trex.com": {
                        "rules": [
                            {
                                "rule": "images.trex.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "vans.com": {
                        "rules": [
                            {
                                "rule": "images.vans.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "wacoal-america.com": {
                        "rules": [
                            {
                                "rule": "images.wacoal-america.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "wrangler.com": {
                        "rules": [
                            {
                                "rule": "images.wrangler.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            },
                            {
                                "rule": "imageseu.wrangler.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "uline.com": {
                        "rules": [
                            {
                                "rule": "img.uline.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "stryker.com": {
                        "rules": [
                            {
                                "rule": "media-assets.stryker.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "castorama.fr": {
                        "rules": [
                            {
                                "rule": "media.castorama.fr/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "chainreactioncycles.com": {
                        "rules": [
                            {
                                "rule": "media.chainreactioncycles.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "playstation.com": {
                        "rules": [
                            {
                                "rule": "media.direct.playstation.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "diy.com": {
                        "rules": [
                            {
                                "rule": "media.diy.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "guitarcenter.com": {
                        "rules": [
                            {
                                "rule": "media.guitarcenter.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "kohlsimg.com": {
                        "rules": [
                            {
                                "rule": "media.kohlsimg.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "schaefer-shop.de": {
                        "rules": [
                            {
                                "rule": "media.schaefer-shop.de/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "screwfix.com": {
                        "rules": [
                            {
                                "rule": "media.screwfix.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "screwfix.ie": {
                        "rules": [
                            {
                                "rule": "media.screwfix.ie/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "sunbeltrentals.com": {
                        "rules": [
                            {
                                "rule": "media.sunbeltrentals.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "bakerdist.com": {
                        "rules": [
                            {
                                "rule": "resource.bakerdist.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "gemaire.com": {
                        "rules": [
                            {
                                "rule": "resource.gemaire.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "armstrongceilings.com": {
                        "rules": [
                            {
                                "rule": "s7-images.armstrongceilings.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "bluegreenvacations.com": {
                        "rules": [
                            {
                                "rule": "s7.bluegreenvacations.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "italia.it": {
                        "rules": [
                            {
                                "rule": "tourismmedia.italia.it/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "signify.com": {
                        "rules": [
                            {
                                "rule": "www.assets.signify.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "hitachienergy.com": {
                        "rules": [
                            {
                                "rule": "dynamic-assets.hitachienergy.com/s7viewersdk/3.11/MixedMediaViewer/js/s7sdk/utils/Utils.js",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: scene7.com.edgekey.net"
                            }
                        ]
                    },
                    "aliexpress.com": {
                        "rules": [
                            {
                                "rule": "login.aliexpress.com/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            }
                        ]
                    },
                    "aliexpress.us": {
                        "rules": [
                            {
                                "rule": "login.aliexpress.us/",
                                "domains": [
                                    "aliexpress.com",
                                    "aliexpress.us"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: alicdn.com.edgekey.net"
                            }
                        ]
                    },
                    "agoda.net": {
                        "rules": [
                            {
                                "rule": "cdn0.agoda.net/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: cdn.agoda.net.edgekey.net"
                            },
                            {
                                "rule": "cdn6.agoda.net/",
                                "domains": [
                                    "<all>"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: cdn.agoda.net.edgekey.net"
                            }
                        ]
                    },
                    "sky.com": {
                        "rules": [
                            {
                                "rule": "accounts.sky.com/assets/sky_common.js",
                                "domains": [
                                    "sky.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: sky.com.edgesuite.net"
                            }
                        ]
                    },
                    "espncdn.com": {
                        "rules": [
                            {
                                "rule": "a.espncdn.com/",
                                "domains": [
                                    "espn.co.uk",
                                    "espn.com",
                                    "espn.com.au",
                                    "espn.com.br",
                                    "espn.com.mx",
                                    "espn.in",
                                    "espnfc.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: a.espncdn.com.stls.edgesuite.net"
                            }
                        ]
                    },
                    "ticketmaster.ca": {
                        "rules": [
                            {
                                "rule": "epsf.ticketmaster.ca/eps-d",
                                "domains": [
                                    "ticketmaster.ca",
                                    "ticketmaster.com",
                                    "ticketmaster.com.au",
                                    "ticketmaster.com.mx"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: ticketmaster4.map.fastly.net"
                            }
                        ]
                    },
                    "ticketmaster.com": {
                        "rules": [
                            {
                                "rule": "epsf.ticketmaster.com/eps-d",
                                "domains": [
                                    "ticketmaster.ca",
                                    "ticketmaster.com",
                                    "ticketmaster.com.au",
                                    "ticketmaster.com.mx"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: ticketmaster4.map.fastly.net"
                            }
                        ]
                    },
                    "target.com": {
                        "rules": [
                            {
                                "rule": "api.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "carts.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "gsp.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "redoak.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "redsky.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "sapphire-api.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            },
                            {
                                "rule": "taglocker.target.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            }
                        ]
                    },
                    "targetimg1.com": {
                        "rules": [
                            {
                                "rule": "assets.targetimg1.com/",
                                "domains": [
                                    "target.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: target-opus.map.fastly.net"
                            }
                        ]
                    },
                    "optus.com.au": {
                        "rules": [
                            {
                                "rule": "lp-07.messaging.optus.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: liveperson.net"
                            },
                            {
                                "rule": "lptag.messaging.optus.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: liveperson.net"
                            },
                            {
                                "rule": "lpcdn.messaging.optus.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "mbna.ca": {
                        "rules": [
                            {
                                "rule": "chat.mbna.ca",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "singtel.com": {
                        "rules": [
                            {
                                "rule": "chat.singtel.com",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "navyfederal.org": {
                        "rules": [
                            {
                                "rule": "liveengage.navyfederal.org",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "bupa.com.au": {
                        "rules": [
                            {
                                "rule": "lp-01.customermessaging.bupa.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            },
                            {
                                "rule": "lpcdn.customermessaging.bupa.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "citi.com": {
                        "rules": [
                            {
                                "rule": "lpcdn.chat.online.citi.com",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "telstra.com.au": {
                        "rules": [
                            {
                                "rule": "lpcdn.messaging.telstra.com.au",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "americanexpress.com": {
                        "rules": [
                            {
                                "rule": "lpchat.americanexpress.com",
                                "domains": [
                                    "virginmedia.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: lpsnmedia.net"
                            }
                        ]
                    },
                    "joindeleteme.com": {
                        "rules": [
                            {
                                "rule": "b2b.joindeleteme.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "usgbc.org": {
                        "rules": [
                            {
                                "rule": "build.usgbc.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "claris.com": {
                        "rules": [
                            {
                                "rule": "content.claris.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "president.jp": {
                        "rules": [
                            {
                                "rule": "corp.president.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "ap.org": {
                        "rules": [
                            {
                                "rule": "discover.ap.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "selinc.com": {
                        "rules": [
                            {
                                "rule": "discover.selinc.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "discovery.org": {
                        "rules": [
                            {
                                "rule": "dot.discovery.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "medbridgeeducation.com": {
                        "rules": [
                            {
                                "rule": "enterprise.medbridgeeducation.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "baesystems.com": {
                        "rules": [
                            {
                                "rule": "events.baesystems.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "acton.org": {
                        "rules": [
                            {
                                "rule": "go.acton.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "adflegal.org": {
                        "rules": [
                            {
                                "rule": "go.adflegal.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "adspipe.com": {
                        "rules": [
                            {
                                "rule": "go.adspipe.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "adventure-life.com": {
                        "rules": [
                            {
                                "rule": "go.adventure-life.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "brennancenter.org": {
                        "rules": [
                            {
                                "rule": "go.brennancenter.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "cdata.com": {
                        "rules": [
                            {
                                "rule": "go.cdata.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "concernusa.org": {
                        "rules": [
                            {
                                "rule": "go.concernusa.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "herzing.edu": {
                        "rules": [
                            {
                                "rule": "go.connect.herzing.edu/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "costar.com": {
                        "rules": [
                            {
                                "rule": "go.costar.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "esri.com": {
                        "rules": [
                            {
                                "rule": "go.esri.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "estes-express.com": {
                        "rules": [
                            {
                                "rule": "go.estes-express.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "hustlerturf.com": {
                        "rules": [
                            {
                                "rule": "go.hustlerturf.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "icontainers.com": {
                        "rules": [
                            {
                                "rule": "go.icontainers.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "iocdf.org": {
                        "rules": [
                            {
                                "rule": "go.iocdf.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "jinjibu.jp": {
                        "rules": [
                            {
                                "rule": "go.jinjibu.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "lifefitness.com": {
                        "rules": [
                            {
                                "rule": "go.lifefitness.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "mobilityworks.com": {
                        "rules": [
                            {
                                "rule": "go.mobilityworks.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "neilpatel.com": {
                        "rules": [
                            {
                                "rule": "go.neilpatel.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "oru.edu": {
                        "rules": [
                            {
                                "rule": "go.oru.edu/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "panasonic.biz": {
                        "rules": [
                            {
                                "rule": "go.panasonic.biz/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "ripple.com": {
                        "rules": [
                            {
                                "rule": "go.ripple.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "strongtie.com": {
                        "rules": [
                            {
                                "rule": "go.strongtie.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "thirdspacelearning.com": {
                        "rules": [
                            {
                                "rule": "go.thirdspacelearning.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "iata.org": {
                        "rules": [
                            {
                                "rule": "go.updates.iata.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "uslawshield.com": {
                        "rules": [
                            {
                                "rule": "go.uslawshield.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "lumbermenonline.com": {
                        "rules": [
                            {
                                "rule": "go1.lumbermenonline.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "signalboosters.com": {
                        "rules": [
                            {
                                "rule": "go2.signalboosters.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "panasonic.jp": {
                        "rules": [
                            {
                                "rule": "gohs.panasonic.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "rescue.org": {
                        "rules": [
                            {
                                "rule": "gorm.rescue.org/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "affirm.com": {
                        "rules": [
                            {
                                "rule": "info.affirm.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "bldr.com": {
                        "rules": [
                            {
                                "rule": "info.bldr.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "ckeditor.com": {
                        "rules": [
                            {
                                "rule": "info.ckeditor.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "factsmgt.com": {
                        "rules": [
                            {
                                "rule": "info.factsmgt.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "gci.com": {
                        "rules": [
                            {
                                "rule": "info.gci.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "msci.com": {
                        "rules": [
                            {
                                "rule": "info.msci.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "viewsonic.com": {
                        "rules": [
                            {
                                "rule": "info.viewsonic.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "woolmark.com": {
                        "rules": [
                            {
                                "rule": "info.woolmark.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "renasantbank.com": {
                        "rules": [
                            {
                                "rule": "insights.renasantbank.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "caring.com": {
                        "rules": [
                            {
                                "rule": "launch.caring.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "amazonappservices.com": {
                        "rules": [
                            {
                                "rule": "m.amazonappservices.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "epson.com.au": {
                        "rules": [
                            {
                                "rule": "marketing-sf.epson.com.au/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "groupon.com": {
                        "rules": [
                            {
                                "rule": "marketing.groupon.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "globalsign.com": {
                        "rules": [
                            {
                                "rule": "media.globalsign.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "tatlerasia.com": {
                        "rules": [
                            {
                                "rule": "media2.tatlerasia.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "schrott24.de": {
                        "rules": [
                            {
                                "rule": "metal.schrott24.de/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "fujitsu.com": {
                        "rules": [
                            {
                                "rule": "mkt-europe.global.fujitsu.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "tokyoweekender.com": {
                        "rules": [
                            {
                                "rule": "mkt.tokyoweekender.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "northside.com": {
                        "rules": [
                            {
                                "rule": "onechartmail.northside.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "epson.jp": {
                        "rules": [
                            {
                                "rule": "pd.epson.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "11880.com": {
                        "rules": [
                            {
                                "rule": "pdt.11880.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "redlightguide.com": {
                        "rules": [
                            {
                                "rule": "pdt.redlightguide.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "werkenntdenbesten.de": {
                        "rules": [
                            {
                                "rule": "pdt.werkenntdenbesten.de/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "illumina.com": {
                        "rules": [
                            {
                                "rule": "prdt.illumina.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "xserver.ne.jp": {
                        "rules": [
                            {
                                "rule": "prm.xserver.ne.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "brother.ca": {
                        "rules": [
                            {
                                "rule": "resellersales.brother.ca/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "chemie.de": {
                        "rules": [
                            {
                                "rule": "t.chemie.de/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "vonage.com": {
                        "rules": [
                            {
                                "rule": "ww3.business.vonage.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "ntt.com": {
                        "rules": [
                            {
                                "rule": "www.bizsol.ntt.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "shredit.com": {
                        "rules": [
                            {
                                "rule": "www.email.shredit.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "ergotron.com": {
                        "rules": [
                            {
                                "rule": "www2.ergotron.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "aruhi-corp.co.jp": {
                        "rules": [
                            {
                                "rule": "www2.go.aruhi-corp.co.jp/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "sharecare.com": {
                        "rules": [
                            {
                                "rule": "www2.sharecare.com/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    },
                    "sma.de": {
                        "rules": [
                            {
                                "rule": "www3.sma.de/",
                                "domains": [
                                    "klove.com"
                                ],
                                "reason": "CNAME ENTRY GENERATED FROM: go.pardot.com"
                            }
                        ]
                    }
                }
            },
            "exceptions": [],
            "hash": "4de0531b3d89d4e97d654b1e93ea963a"
        },
        "trackingCookies1p": {
            "settings": {
                "firstPartyTrackerCookiePolicy": {
                    "threshold": 86400,
                    "maxAge": 86400
                }
            },
            "exceptions": [],
            "state": "enabled",
            "hash": "66159bbb387e48b7d6295068e642fc99"
        },
        "trackingCookies3p": {
            "settings": {
                "excludedCookieDomains": []
            },
            "exceptions": [],
            "state": "enabled",
            "hash": "6859f9cb854d6be96600b5757600ee5b"
        },
        "trackingParameters": {
            "exceptions": [],
            "settings": {
                "parameters": [
                    "utm_source",
                    "utm_medium",
                    "utm_campaign",
                    "utm_term",
                    "utm_content",
                    "gclid",
                    "fbclid",
                    "fb_action_ids",
                    "fb_action_types",
                    "fb_source",
                    "fb_ref",
                    "ga_source",
                    "ga_medium",
                    "ga_term",
                    "ga_content",
                    "ga_campaign",
                    "ga_place",
                    "action_object_map",
                    "action_type_map",
                    "action_ref_map",
                    "gs_l",
                    "mkt_tok",
                    "hmb_campaign",
                    "hmb_source",
                    "hmb_medium"
                ]
            },
            "state": "enabled",
            "hash": "4eb7caeea36d5a0d96fe06386d403d54"
        },
        "userAgentRotation": {
            "settings": {
                "agentExcludePatterns": []
            },
            "exceptions": [],
            "state": "disabled",
            "hash": "5d33a7d6a3f780d2e07076e209a5bccb"
        },
        "webCompat": {
            "exceptions": [
                {
                    "domain": "portal.azure.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/526"
                },
                {
                    "domain": "lastpass.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/533"
                },
                {
                    "domain": "forums.swift.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "twittercommunity.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.asana.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.developer.atlassian.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "meta.discourse.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.smartthings.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.figma.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "bbs.boingboing.net",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "devforum.zoom.us",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.uipath.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "discuss.elastic.co",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.envato.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "discuss.newrelic.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.wd.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.wyzecam.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.anker.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "www.trainerroad.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "www.sitepoint.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "comunidade.nubank.com.br",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.monzo.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.wirexapp.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.freetrade.io",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.unrealengine.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.funcom.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.infiniteflight.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.eveonline.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.metamask.io",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.algorand.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.cardano.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.solana.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "developers.chia.net",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.cartalk.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "www.thefantasyfootballers.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "www.twit.community",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "commons.commondreams.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "boards.straightdope.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.gitlab.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "discuss.rubyonrails.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.docker.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.brave.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "discuss.emberjs.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.glamour.de",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.cfl.ca",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "soaps.sheknows.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.mssociety.org.uk",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.schizophrenia.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.octopus.energy",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.level1techs.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.zwift.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forums.plex.tv",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.arduino.cc",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.restic.net",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.openwrt.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "www.horlogeforum.nl",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.infinityfree.net",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.manjaro.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.projectpanoptes.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "forum.obsidian.md",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "us.forums.blizzard.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.home-assistant.io",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.openfl.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.sonarsource.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "ubuntu-mate.community",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.letsencrypt.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.naimaudio.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.ipfire.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.squirrelsquadron.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.signalusers.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.haxe.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.grafana.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.octoprint.org",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                },
                {
                    "domain": "community.bitwarden.com",
                    "reason": "https://github.com/duckduckgo/privacy-configuration/issues/519"
                }
            ],
            "state": "disabled",
            "hash": "b90668dd2aa466abc5eb36578c53ba7f"
        },
        "windowsPermissionUsage": {
            "exceptions": [],
            "state": "disabled",
            "hash": "728493ef7a1488e4781656d3f9db84aa"
        },
        "windowsWaitlist": {
            "exceptions": [],
            "state": "disabled",
            "hash": "728493ef7a1488e4781656d3f9db84aa"
        }
    },
    "unprotectedTemporary": []
}
},{}],38:[function(require,module,exports){
"use strict";

var parseUserAgentString = require('../js/shared-utils/parse-user-agent-string');
var browserInfo = parseUserAgentString();
function getConfigFileName() {
  var _browserInfo$browser;
  var browserName = (browserInfo === null || browserInfo === void 0 ? void 0 : (_browserInfo$browser = browserInfo.browser) === null || _browserInfo$browser === void 0 ? void 0 : _browserInfo$browser.toLowerCase()) || '';

  // clamp to known browsers
  if (!['chrome', 'firefox', 'brave', 'edg'].includes(browserName)) {
    browserName = '';
  } else {
    var _chrome;
    browserName = '-' + browserName + (((_chrome = chrome) === null || _chrome === void 0 ? void 0 : _chrome.runtime.getManifest().manifest_version) === 3 ? 'mv3' : '');
  }
  return "https://staticcdn.duckduckgo.com/trackerblocking/config/v2/extension".concat(browserName, "-config.json");
}
module.exports = {
  displayCategories: ['Analytics', 'Advertising', 'Social Network', 'Content Delivery', 'Embedded Content'],
  feedbackUrl: 'https://duckduckgo.com/feedback.js?type=extension-feedback',
  tosdrMessages: {
    A: 'Good',
    B: 'Mixed',
    C: 'Poor',
    D: 'Poor',
    E: 'Poor',
    good: 'Good',
    bad: 'Poor',
    unknown: 'Unknown',
    mixed: 'Mixed'
  },
  httpsService: 'https://duckduckgo.com/smarter_encryption.js',
  duckDuckGoSerpHostname: 'duckduckgo.com',
  httpsMessages: {
    secure: 'Encrypted Connection',
    upgraded: 'Forced Encryption',
    none: 'Unencrypted Connection'
  },
  /**
   * Major tracking networks data:
   * percent of the top 1 million sites a tracking network has been seen on.
   * see: https://webtransparency.cs.princeton.edu/webcensus/
   */
  majorTrackingNetworks: {
    google: 84,
    facebook: 36,
    twitter: 16,
    amazon: 14,
    appnexus: 10,
    oracle: 10,
    mediamath: 9,
    oath: 9,
    maxcdn: 7,
    automattic: 7
  },
  /*
   * Mapping entity names to CSS class name for popup icons
   */
  entityIconMapping: {
    'Google LLC': 'google',
    'Facebook, Inc.': 'facebook',
    'Twitter, Inc.': 'twitter',
    'Amazon Technologies, Inc.': 'amazon',
    'AppNexus, Inc.': 'appnexus',
    'MediaMath, Inc.': 'mediamath',
    'StackPath, LLC': 'maxcdn',
    'Automattic, Inc.': 'automattic',
    'Adobe Inc.': 'adobe',
    'Quantcast Corporation': 'quantcast',
    'The Nielsen Company': 'nielsen'
  },
  httpsDBName: 'https',
  httpsLists: [{
    type: 'upgrade bloom filter',
    name: 'httpsUpgradeBloomFilter',
    url: 'https://staticcdn.duckduckgo.com/https/https-bloom.json'
  }, {
    type: "don't upgrade bloom filter",
    name: 'httpsDontUpgradeBloomFilters',
    url: 'https://staticcdn.duckduckgo.com/https/negative-https-bloom.json'
  }, {
    type: 'upgrade safelist',
    name: 'httpsUpgradeList',
    url: 'https://staticcdn.duckduckgo.com/https/negative-https-allowlist.json'
  }, {
    type: "don't upgrade safelist",
    name: 'httpsDontUpgradeList',
    url: 'https://staticcdn.duckduckgo.com/https/https-allowlist.json'
  }],
  tdsLists: [{
    name: 'surrogates',
    url: '/data/surrogates.txt',
    format: 'text',
    source: 'local'
  }, {
    name: 'tds',
    url: 'https://staticcdn.duckduckgo.com/trackerblocking/v4/tds.json',
    format: 'json',
    source: 'external',
    channels: {
      live: 'https://staticcdn.duckduckgo.com/trackerblocking/v4/tds.json',
      next: 'https://staticcdn.duckduckgo.com/trackerblocking/v4/tds-next.json',
      beta: 'https://staticcdn.duckduckgo.com/trackerblocking/beta/tds.json'
    }
  }, {
    name: 'config',
    url: getConfigFileName(),
    format: 'json',
    source: 'external'
  }],
  httpsErrorCodes: {
    'net::ERR_CONNECTION_REFUSED': 1,
    'net::ERR_ABORTED': 2,
    'net::ERR_SSL_PROTOCOL_ERROR': 3,
    'net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH': 4,
    'net::ERR_NAME_NOT_RESOLVED': 5,
    NS_ERROR_CONNECTION_REFUSED: 6,
    NS_ERROR_UNKNOWN_HOST: 7,
    'An additional policy constraint failed when validating this certificate.': 8,
    'Unable to communicate securely with peer: requested domain name does not match the servers certificate.': 9,
    'Cannot communicate securely with peer: no common encryption algorithm(s).': 10,
    'SSL received a record that exceeded the maximum permissible length.': 11,
    'The certificate is not trusted because it is self-signed.': 12,
    downgrade_redirect_loop: 13
  },
  iconPaths: /** @type {const} */{
    regular: '/img/icon_browser_action.png',
    withSpecialState: '/img/icon_browser_action_special.png'
  },
  platform: {
    name: 'extension'
  },
  supportedLocales: ['cimode', 'en'],
  // cimode is for testing
  trackerStats: /** @type {const} */{
    allowedOrigin: 'https://duckduckgo.com',
    allowedPathname: 'ntp-tracker-stats.html',
    redirectTarget: 'html/tracker-stats.html',
    clientPortName: 'newtab-tracker-stats',
    /** @type {ReadonlyArray<string>} */
    excludedCompanies: ['ExoClick'],
    events: {
      incoming: {
        newTabPage_heartbeat: 'newTabPage_heartbeat'
      },
      outgoing: {
        newTabPage_data: 'newTabPage_data',
        newTabPage_disconnect: 'newTabPage_disconnect'
      }
    }
  }
};

},{"../js/shared-utils/parse-user-agent-string":100}],39:[function(require,module,exports){
"use strict";

module.exports = {
  httpsEverywhereEnabled: true,
  embeddedTweetsEnabled: false,
  GPC: true,
  youtubePreviewsEnabled: false,
  atb: null,
  set_atb: null,
  'config-etag': null,
  'httpsUpgradeBloomFilter-etag': null,
  'httpsDontUpgradeBloomFilters-etag': null,
  'httpsUpgradeList-etag': null,
  'httpsDontUpgradeList-etag': null,
  hasSeenPostInstall: false,
  extiSent: false,
  'tds-etag': null,
  lastTdsUpdate: 0
};

},{}],40:[function(require,module,exports){
module.exports={"config-etag":"W/\"908619556a78f118d1c2190d7d45433b\""}
},{}],41:[function(require,module,exports){
"use strict";

module.exports = {
  _: {},
  l: {
    name: 'full tracker list',
    description: 'Testing full Tracker Radar list',
    active: false,
    atbExperiments: {
      m: {
        description: 'Full list experiment group',
        settings: {
          experimentData: {
            listName: 'tds',
            url: 'https://staticcdn.duckduckgo.com/trackerblocking/lm/tds.json'
          }
        }
      }
    }
  },
  o: {
    name: '1st and 3rd party cookie experiment',
    description: 'Testing 3rd party cookie blocking and 1st party cookie expiry',
    active: true,
    atbExperiments: {
      c: {
        description: '3rd party experiment group',
        settings: {
          experimentData: {
            blockingActivated: true
          }
        }
      }
    }
  }
};

},{}],42:[function(require,module,exports){
module.exports={
    "zoosk.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "youtube.com": {
        "score": 0,
        "all": {
            "bad": [
                "broader than necessary",
                "reduction of legal period for cause of action",
                "user needs to check tosback.org",
                "device fingerprinting"
            ],
            "good": [
                "help you deal with take-down notices"
            ]
        },
        "match": {
            "bad": [
                "broader than necessary",
                "reduction of legal period for cause of action",
                "user needs to check tosback.org",
                "device fingerprinting"
            ],
            "good": [
                "help you deal with take-down notices"
            ]
        },
        "class": "D"
    },
    "yahoo.com": {
        "score": 0,
        "all": {
            "bad": [
                "pseudonym not allowed (not because of user-to-user trust)",
                "user needs to check tosback.org",
                "device fingerprinting"
            ],
            "good": [
                "limited for purpose of same service",
                "limited for purpose of same service"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "xing.com": {
        "score": 0,
        "all": {
            "bad": [
                "pseudonym not allowed (not because of user-to-user trust)"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "xfire.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "worldofwarcraft.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "wordpress.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org",
                "device fingerprinting"
            ],
            "good": [
                "limited for purpose of same service"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "wordfeud.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "wikipedia.org": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "only temporary session cookies",
                "user feedback is invited",
                "suspension will be fair and proportionate",
                "you publish under a free license, not a bilateral one"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "whatsapp.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "videobb.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "vbulletin.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "twitter.com": {
        "score": 0,
        "all": {
            "bad": [
                "little involvement",
                "very broad",
                "your content stays licensed",
                "sets third-party cookies and/or ads"
            ],
            "good": [
                "archives provided",
                "tracking data deleted after 10 days and opt-out",
                "you can get your data back"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "twitpic.com": {
        "score": 85,
        "all": {
            "bad": [
                "responsible and indemnify",
                "reduction of legal period for cause of action",
                "they can license to third parties"
            ],
            "good": []
        },
        "match": {
            "bad": [
                "they can license to third parties"
            ],
            "good": []
        },
        "class": false
    },
    "tumblr.com": {
        "score": 0,
        "all": {
            "bad": [
                "keep a license even after you close your account",
                "sets third-party cookies and/or ads"
            ],
            "good": [
                "they state that you own your data",
                "third parties are bound by confidentiality obligations",
                "archives provided"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "steampowered.com": {
        "score": -65,
        "all": {
            "bad": [
                "defend, indemnify, hold harmless; survives termination",
                "personal data is given to third parties",
                "they can delete your account without prior notice and without a reason",
                "class action waiver"
            ],
            "good": [
                "personal data is not sold",
                "pseudonyms allowed",
                "you can request access and deletion of personal data",
                "user is notified a month or more in advance",
                "you can leave at any time"
            ]
        },
        "match": {
            "bad": [
                "personal data is given to third parties"
            ],
            "good": [
                "personal data is not sold",
                "you can request access and deletion of personal data"
            ]
        },
        "class": false
    },
    "store.steampowered.com": {
        "score": -65,
        "all": {
            "bad": [
                "defend, indemnify, hold harmless; survives termination",
                "personal data is given to third parties",
                "they can delete your account without prior notice and without a reason",
                "class action waiver"
            ],
            "good": [
                "personal data is not sold",
                "pseudonyms allowed",
                "you can request access and deletion of personal data",
                "user is notified a month or more in advance",
                "you can leave at any time"
            ]
        },
        "match": {
            "bad": [
                "personal data is given to third parties"
            ],
            "good": [
                "personal data is not sold",
                "you can request access and deletion of personal data"
            ]
        },
        "class": false
    },
    "spotify.com": {
        "score": 10,
        "all": {
            "bad": [
                "you grant perpetual license to anything you publish-bad-80",
                "spotify may transfer and process your data to somewhere outside of your country-bad-50",
                "personal data is given to third parties",
                "they can delete your account without prior notice and without a reason",
                "no promise to inform/notify",
                "no quality guarantee",
                "third parties may be involved in operating the service",
                "no quality guarantee"
            ],
            "good": [
                "info given about risk of publishing your info online",
                "you can leave at any time",
                "they educate you about the risks",
                "info given about what personal data they collect",
                "info given about intended use of your information"
            ]
        },
        "match": {
            "bad": [
                "personal data is given to third parties"
            ],
            "good": []
        },
        "class": false
    },
    "soundcloud.com": {
        "score": 20,
        "all": {
            "bad": [
                "responsible and indemnify",
                "may sell your data in merger",
                "third-party cookies, but with opt-out instructions"
            ],
            "good": [
                "user is notified a month or more in advance",
                "easy to read",
                "you have control over licensing options",
                "your personal data is used for limited purposes",
                "pseudonyms allowed",
                "you can leave at any time"
            ]
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": "B"
    },
    "sonic.net": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "logs are deleted after two weeks"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "skype.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org",
                "you may not express negative opinions about them"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "seenthis.net": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "you can get your data back",
                "you can leave at any time",
                "you have control over licensing options"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "you can get your data back",
                "you can leave at any time",
                "you have control over licensing options"
            ]
        },
        "class": "A"
    },
    "runescape.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "rapidshare.com": {
        "score": -50,
        "all": {
            "bad": [],
            "good": [
                "no third-party access without a warrant",
                "they do not index or open files",
                "your personal data is used for limited purposes",
                "99.x% availability",
                "user is notified a month or more in advance"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no third-party access without a warrant"
            ]
        },
        "class": false
    },
    "quora.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "phpbb.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "packagetrackr.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "owncube.com": {
        "score": -25,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": [
                "personal data is not sold"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "personal data is not sold"
            ]
        },
        "class": false
    },
    "olx.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "netflix.com": {
        "score": -20,
        "all": {
            "bad": [
                "class action waiver",
                "sets third-party cookies and/or ads",
                "they can delete your account without prior notice and without a reason",
                "no liability for unauthorized access",
                "user needs to check tosback.org",
                "targeted third-party advertising",
                "no promise to inform/notify"
            ],
            "good": [
                "easy to read",
                "you can request access and deletion of personal data"
            ]
        },
        "match": {
            "bad": [
                "targeted third-party advertising"
            ],
            "good": [
                "you can request access and deletion of personal data"
            ]
        },
        "class": false
    },
    "nabble.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "mint.com": {
        "score": 20,
        "all": {
            "bad": [
                "may sell your data in merger",
                "user needs to rely on tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": false
    },
    "microsoft.com": {
        "score": 60,
        "all": {
            "bad": [
                "class action waiver",
                "tracks you on other websites",
                "no promise to inform/notify",
                "user needs to check tosback.org",
                "your data may be stored anywhere in the world"
            ],
            "good": [
                "personalized ads are opt-out"
            ]
        },
        "match": {
            "bad": [
                "tracks you on other websites"
            ],
            "good": []
        },
        "class": false
    },
    "lastpass.com": {
        "score": -50,
        "all": {
            "bad": [
                "they can delete your account without prior notice and without a reason",
                "no quality guarantee",
                "no quality guarantee",
                "they become the owner of ideas you give them",
                "user needs to check tosback.org",
                "promotional communications are not opt-out",
                "responsible and indemnify"
            ],
            "good": [
                "legal documents published under reusable license",
                "pseudonyms allowed",
                "info given about security practices",
                "only necessary logs are kept",
                "only temporary session cookies",
                "no third-party access without a warrant"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no third-party access without a warrant"
            ]
        },
        "class": "B"
    },
    "kolabnow.com": {
        "score": -75,
        "all": {
            "bad": [],
            "good": [
                "no third-party access without a warrant",
                "4 weeks to review changes and possibility to negotiate-good-60",
                "no tracking cookies and web analytics opt-out-good-20",
                "suspension will be fair and proportionate",
                "only necessary logs are kept",
                "no third-party access without a warrant",
                "free software; you can run your own instance",
                "personal data is not sold"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no third-party access without a warrant",
                "personal data is not sold"
            ]
        },
        "class": "A"
    },
    "kolab.org": {
        "score": -75,
        "all": {
            "bad": [],
            "good": [
                "no third-party access without a warrant",
                "4 weeks to review changes and possibility to negotiate-good-60",
                "no tracking cookies and web analytics opt-out-good-20",
                "suspension will be fair and proportionate",
                "only necessary logs are kept",
                "no third-party access without a warrant",
                "free software; you can run your own instance",
                "personal data is not sold"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no third-party access without a warrant",
                "personal data is not sold"
            ]
        },
        "class": "A"
    },
    "kippt.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to rely on tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "jagex.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "user is notified a week or more in advance"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "instagram.com": {
        "score": 0,
        "all": {
            "bad": [
                "class action waiver",
                "very broad"
            ],
            "good": [
                "user is notified a week or more in advance"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "informe.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "imgur.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "ifttt.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "identi.ca": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "you publish under a free license, not a bilateral one"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "hypster.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "habbo.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "gravatar.com": {
        "score": 0,
        "all": {
            "bad": [
                "broader than necessary"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "grammarly.com": {
        "score": 20,
        "all": {
            "bad": [
                "no promise to inform/notify",
                "your use is throttled",
                "no pricing info given before you sign up",
                "may sell your data in merger"
            ],
            "good": []
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": false
    },
    "google.com": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.in": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.jp": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.de": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.uk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.br": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.fr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ru": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.it": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.hk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.es": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ca": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.mx": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.tr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.au": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.tw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.pl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.id": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ar": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ua": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.th": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.sa": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.eg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.nl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ve": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.za": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ph": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.se": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.sg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.be": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.az": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ao": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.co": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.kr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.at": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.vn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ng": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ch": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.no": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ro": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pe": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.pt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ae": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ie": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.dk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.dz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.hu": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.fi": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.il": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.kz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.kw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.nz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.lk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.by": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.do": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ly": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.rs": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.mm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.hr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ec": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.my": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.lt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.iq": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.si": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.af": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.gt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.lv": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.gh": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.bd": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.cu": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.jo": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.lb": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.sv": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ee": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.bh": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ba": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.uy": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ma": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.kh": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.py": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.np": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.cy": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ni": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.et": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cd": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.hn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ge": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.am": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.lu": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.qa": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.mz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.bw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.bn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.tj": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ht": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.zm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ke": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.al": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bf": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mu": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.cr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.la": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.bo": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.org": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.jm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.tz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.na": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ml": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.mt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.is": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bj": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ug": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.rw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.om": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ci": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bs": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.td": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ps": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.gi": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pa": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.sl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.uz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.md": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bi": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cat": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.so": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.bt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.je": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gy": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.me": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.zw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gp": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ls": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.as": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.bz": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cf": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mv": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ad": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.li": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.cv": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.vc": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ag": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ne": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.mw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ws": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.kg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.to": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.sb": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.tn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ga": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tl": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.im": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.fj": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.dj": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ac": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.iq": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.vg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.dm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sc": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.pt": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.cn": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.st": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ng": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ai": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ki": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.vu": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.jp": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.om": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.vi": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.gg": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.fm": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.hk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.ck": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tk": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.in": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.co.je": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.ve": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.tw": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.us": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ua": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.de.com": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.ms": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.com.by": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.nr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.br.com": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.sh": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.hk.com": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "google.kr": {
        "score": 220,
        "all": {
            "bad": [
                "they may stop providing the service at any time",
                "they can use your content for all their existing and future services",
                "third-party access without a warrant",
                "your content stays licensed",
                "tracks you on other websites",
                "logs are kept forever",
                "device fingerprinting"
            ],
            "good": [
                "user is notified a week or more in advance",
                "archives provided",
                "they provide a way to export your data",
                "limited for purpose across broad platform"
            ]
        },
        "match": {
            "bad": [
                "they can use your content for all their existing and future services",
                "tracks you on other websites",
                "logs are kept forever"
            ],
            "good": []
        },
        "class": "C"
    },
    "github.com": {
        "score": 0,
        "all": {
            "bad": [
                "they can delete your account without prior notice and without a reason",
                "user needs to check tosback.org",
                "pseudonym not allowed (not because of user-to-user trust)",
                "defend, indemnify, hold harmless"
            ],
            "good": [
                "info given about security practices",
                "you publish under a free license, not a bilateral one",
                "will notify before merger",
                "your personal data is used for limited purposes"
            ]
        },
        "match": {
            "bad": [
                "they can delete your account without prior notice and without a reason",
                "user needs to check tosback.org",
                "pseudonym not allowed (not because of user-to-user trust)",
                "defend, indemnify, hold harmless"
            ],
            "good": [
                "info given about security practices",
                "you publish under a free license, not a bilateral one",
                "will notify before merger",
                "your personal data is used for limited purposes"
            ]
        },
        "class": "B"
    },
    "freeforums.org": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "foxnews.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "flickr.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": [
                "you can choose with whom you share content",
                "limited for purpose of same service",
                "you can choose the copyright license"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "flattr.com": {
        "score": 0,
        "all": {
            "bad": [
                "sets third-party cookies and/or ads"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "facebook.com": {
        "score": 100,
        "all": {
            "bad": [
                "pseudonym not allowed (not because of user-to-user trust)",
                "tracks you on other websites",
                "many third parties are involved in operating the service",
                "very broad",
                "your data is used for many purposes"
            ],
            "good": [
                "they state that you own your data",
                "user feedback is invited"
            ]
        },
        "match": {
            "bad": [
                "tracks you on other websites",
                "your data is used for many purposes"
            ],
            "good": []
        },
        "class": false
    },
    "evernote.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "envato.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "ebuddy.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "duckduckgo.com": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "duck.com": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "donttrack.us": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "privacyheroes.io": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "spreadprivacy.com": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "duckduckhack.com": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "privatebrowsingmyths.com": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "duck.co": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "cispaletter.org": {
        "score": -100,
        "all": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "match": {
            "bad": [],
            "good": [
                "no tracking"
            ]
        },
        "class": "A"
    },
    "dropbox.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "disqus.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": [
                "they will help you react to others infringing on your copyright"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "dictionary.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "delicious.com": {
        "score": 20,
        "all": {
            "bad": [
                "broad license including right to distribute through any media",
                "sets third-party cookies and/or ads",
                "may sell your data in merger",
                "only for your individual and non-commercial use"
            ],
            "good": [
                "third parties are bound by confidentiality obligations"
            ]
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": "D"
    },
    "delicious.com.au": {
        "score": 20,
        "all": {
            "bad": [
                "broad license including right to distribute through any media",
                "sets third-party cookies and/or ads",
                "may sell your data in merger",
                "only for your individual and non-commercial use"
            ],
            "good": [
                "third parties are bound by confidentiality obligations"
            ]
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": "D"
    },
    "coursera.org": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to rely on tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "couchsurfing.org": {
        "score": 20,
        "all": {
            "bad": [
                "your content stays licensed",
                "they can delete your account without prior notice and without a reason",
                "they become the owner of ideas you give them",
                "keep a license even after you close your account",
                "broader than necessary",
                "user needs to check tosback.org",
                "may sell your data in merger",
                "third-party cookies, but with opt-out instructions"
            ],
            "good": []
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": false
    },
    "cnn.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "cnet.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "cloudant.com": {
        "score": 20,
        "all": {
            "bad": [
                "defend, indemnify, hold harmless",
                "user needs to check tosback.org",
                "no liability for unauthorized access",
                "may sell your data in merger",
                "sets third-party cookies and/or ads"
            ],
            "good": [
                "limited for purpose of same service",
                "they provide a way to export your data",
                "refund policy",
                "you publish under a free license, not a bilateral one",
                "they give 30 days notice before closing your account",
                "will warn about maintenance"
            ]
        },
        "match": {
            "bad": [
                "may sell your data in merger"
            ],
            "good": []
        },
        "class": "B"
    },
    "null": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "bitly.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "bearshare.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "bbc.com": {
        "score": 0,
        "all": {
            "bad": [
                "device fingerprinting"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "icloud.com": {
        "score": 0,
        "all": {
            "bad": [],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "apple.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "app.net": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to rely on tosback.org",
                "you may not scrape",
                "defend, indemnify, hold harmless"
            ],
            "good": [
                "user feedback is invited",
                "archives provided",
                "you can delete your content",
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "amazon.com": {
        "score": 110,
        "all": {
            "bad": [
                "may sell your data in merger",
                "targeted third-party advertising",
                "tracks you on other websites",
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [
                "may sell your data in merger",
                "targeted third-party advertising",
                "tracks you on other websites"
            ],
            "good": []
        },
        "class": false
    },
    "allrecipes.com": {
        "score": 0,
        "all": {
            "bad": [
                "user needs to check tosback.org"
            ],
            "good": []
        },
        "match": {
            "bad": [],
            "good": []
        },
        "class": false
    },
    "500px.com": {
        "score": 0,
        "all": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "match": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "class": "D"
    },
    "500px.me": {
        "score": 0,
        "all": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "match": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "class": "D"
    },
    "500px.org": {
        "score": 0,
        "all": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "match": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "class": "D"
    },
    "500px.net": {
        "score": 0,
        "all": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "match": {
            "bad": [
                "class action waiver",
                "responsible and indemnify",
                "they can delete your account without prior notice and without a reason",
                "broader than necessary"
            ],
            "good": [
                "easy to read",
                "pseudonyms allowed"
            ]
        },
        "class": "D"
    }
}

},{}],43:[function(require,module,exports){
"use strict";

/**
 *
 * Sets GPC signal header
 *
 */
var settings = require('./settings');

// Return Sec-GPC header if setting enabled
function getHeader() {
  var GPCEnabled = settings.getSetting('GPC');
  if (GPCEnabled) {
    return {
      name: 'Sec-GPC',
      value: '1'
    };
  }
}
module.exports = {
  getHeader: getHeader
};

},{"./settings":90}],44:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var tdsStorage = require('./storage/tds')["default"];
var tldts = require('tldts');
var _require = require('./utils'),
  getURLWithoutQueryString = _require.getURLWithoutQueryString;
function isTrackerAllowlisted(site, request) {
  // check that allowlist exists and is not disabled
  if (!tdsStorage.config.features.trackerAllowlist || tdsStorage.config.features.trackerAllowlist.state === 'disabled') {
    return false;
  }

  // check that allowlist has entries
  if (!tdsStorage.config.features.trackerAllowlist.settings || !Object.keys(tdsStorage.config.features.trackerAllowlist.settings.allowlistedTrackers).length) {
    return false;
  }
  var parsedRequest = tldts.parse(request);
  if (!parsedRequest.domain) {
    return false;
  }
  var allowListEntry = tdsStorage.config.features.trackerAllowlist.settings.allowlistedTrackers[parsedRequest.domain];
  if (allowListEntry) {
    return _matchesRule(site, request, allowListEntry);
  } else {
    return false;
  }
}
function _matchesRule(site, request, allowListEntry) {
  var matchedRule = null;
  request = getURLWithoutQueryString(request).split(';')[0];

  // remove port from request urls
  var parsedRequest = new URL(request);
  if (parsedRequest.port) {
    parsedRequest.port = parsedRequest.protocol === 'https:' ? '443' : '80';
    request = parsedRequest.href;
  }
  if (allowListEntry.rules && allowListEntry.rules.length) {
    var _iterator = _createForOfIteratorHelper(allowListEntry.rules),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var ruleObj = _step.value;
        if (request.match(ruleObj.rule)) {
          matchedRule = ruleObj;
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (matchedRule) {
    if (matchedRule.domains.includes('<all>') || matchedRule.domains.includes(tldts.parse(site).domain)) {
      return matchedRule;
    }
  } else {
    return false;
  }
  return false;
}
module.exports = isTrackerAllowlisted;

},{"./storage/tds":93,"./utils":98,"tldts":10}],45:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var Site = require('./classes/site');
var tdsStorage = require('./storage/tds')["default"];
var utils = require('./utils');
var ampSettings = null;
var featureName = 'ampLinks';

/**
 * Ensure the config has the ampLinks feature and its settings
 *
 * @returns {boolean} - true if the config is loaded
 */
function ensureConfig() {
  if (ampSettings) {
    return true;
  }
  if (!tdsStorage.config || !tdsStorage.config.features || !tdsStorage.config.features.ampLinks || !tdsStorage.config.features.ampLinks.settings || !tdsStorage.config.features.ampLinks.settings.linkFormats || !tdsStorage.config.features.ampLinks.settings.keywords) {
    return false;
  }
  ampSettings = tdsStorage.config.features.ampLinks.settings;
  return true;
}

/**
 * This method checks if the given url is a Google hosted AMP url and resturns the canonical url if it is.
 *
 * @param {Site} site - the initiating site
 * @param {string} url - the url being loaded
 * @returns canonical url if found, null otherwise
 */
function extractAMPURL(site, url) {
  if (!ensureConfig()) {
    return null;
  }
  if (site.specialDomainName || !site.isFeatureEnabled(featureName)) {
    return null;
  }
  var _iterator = _createForOfIteratorHelper(ampSettings.linkFormats),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var regexPattern = _step.value;
      var match = url.match(regexPattern);
      if (match && match.length > 1) {
        var newSite = new Site(match[1].startsWith('http') ? match[1] : "https://".concat(match[1]));
        if (newSite.specialDomainName || !newSite.isFeatureEnabled(featureName)) {
          return null;
        }
        return newSite.url;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return null;
}

/**
 * Check if the given request is a suspected 1st party AMP URL. If it is, then we will attempt to fetch the canonical URL
 *
 * @param {object} requestData - request data
 * @param {object} thisTab - current tab
 * @param {object} mainFrameRequestURL - main frame request url
 * @returns true if the request is a suspected 1st party AMP url
 */
function tabNeedsDeepExtraction(requestData, thisTab, mainFrameRequestURL) {
  if (utils.getBrowserName() !== 'moz') {
    // deep extraction is only supported on Firefox
    return false;
  }
  if (!ensureConfig() || !ampSettings.deepExtractionEnabled) {
    return false;
  }
  if (requestIsExtension(requestData)) {
    return false;
  }
  if (thisTab.ampUrl && thisTab.ampUrl === mainFrameRequestURL.href) {
    return false;
  }
  return isAMPURL(mainFrameRequestURL.href);
}

/**
 * This method checks if the given url is a 1st party AMP url
 *
 * @param {string} url - the url being loaded
 * @returns true is the url is suspected to be a 1st party AMP url
 */
function isAMPURL(url) {
  if (!ensureConfig()) {
    return false;
  }
  var site = new Site(url);
  if (site.specialDomainName || !site.isFeatureEnabled(featureName)) {
    return false;
  }
  return ampSettings.keywords.some(function (keyword) {
    return url.includes(keyword);
  });
}

/**
 * This async method will fetch the DOM content of a suspected 1st party AMP URL and will
 * return the canonical URL if one is found.
 *
 * @param {Site} site - the initiating site
 * @param {string} url - the url being loaded
 * @returns cancalon url if found, null otherwise
 */
function fetchAMPURL(_x, _x2) {
  return _fetchAMPURL.apply(this, arguments);
}
/**
 * Check if the given request was initiated by the extension. On Chrome extension initiated requests
 * will cause a crash if we try to use fetch on their thread.
 *
 * @param {object} request - request object
 * @returns true if the request was initiated by an extension
 */
function _fetchAMPURL() {
  _fetchAMPURL = _asyncToGenerator(function* (site, url) {
    if (!ensureConfig()) {
      return null;
    }
    if (site.specialDomainName || !site.isFeatureEnabled(featureName) || site.url === 'about:blank') {
      return null;
    }
    var data = null;
    var timeoutController = new AbortController();
    setTimeout(function () {
      return timeoutController.abort();
    }, ampSettings.deepExtractionTimeout || 1500);
    try {
      data = yield fetch(url, {
        signal: timeoutController.signal
      });
    } catch (e) {
      console.error(e);
      return null;
    }
    if (!data) {
      return null;
    }
    var text = yield data.text();
    if (!text) {
      return null;
    }
    var doc = new DOMParser().parseFromString(text, 'text/html');

    /** @type {HTMLLinkElement?} */
    var firstCanonicalLink = doc.querySelector('[rel="canonical"]');
    if (firstCanonicalLink && firstCanonicalLink instanceof HTMLLinkElement) {
      var newSite = new Site(firstCanonicalLink.href);
      if (newSite.specialDomainName || !newSite.isFeatureEnabled(featureName)) {
        return null;
      }
      return firstCanonicalLink.href;
    }
    return null;
  });
  return _fetchAMPURL.apply(this, arguments);
}
function requestIsExtension(request) {
  return request.initiator && request.initiator.startsWith('chrome-extension://');
}
tdsStorage.onUpdate('config', function () {
  ampSettings = null;
});
module.exports = {
  isAMPURL: isAMPURL,
  extractAMPURL: extractAMPURL,
  fetchAMPURL: fetchAMPURL,
  tabNeedsDeepExtraction: tabNeedsDeepExtraction
};

},{"./classes/site":56,"./storage/tds":93,"./utils":98}],46:[function(require,module,exports){
"use strict";

var ATB_EPOCH = 1456290000000;
var ONE_WEEK = 604800000;
var ONE_DAY = 86400000;
var ONE_HOUR = 3600000;
var ONE_MINUTE = 60000;

/**
 * Returns an object with ATB
 * majorVersion and minorVersion
 *
 * majorVersion = # of weeks since noon EST on 2/24/16
 * minorVersion = # of days into the current week
 */
function getCurrentATB() {
  var d = new Date();
  var localTime = d.getTime();
  // convert local to UTC:
  var utcTime = localTime + d.getTimezoneOffset() * ONE_MINUTE;
  // convert to approximation of est using 5 hour offset so we
  // can compare to the DST start/stop date in eastern time and
  // determine whether it's DST or not.
  var est = new Date(utcTime + ONE_HOUR * -5);
  // First determine DST start/end day for Eastern Timezone.
  // It's always the 2nd Sunday in March. In 2016 it's 3/13/16 and 11/6/16, In 2017 it's 3/12/17 and 11/5/17, etc.
  var dstStartDay = 13 - (est.getFullYear() - 2016) % 6;
  var dstStopDay = 6 - (est.getFullYear() - 2016) % 6;
  // Once we have start/stop day for the current year, we can check whether the current day (based on est) is
  // within the EDT window:
  var isDST = (est.getMonth() > 2 || est.getMonth() === 2 && est.getDate() >= dstStartDay) && (est.getMonth() < 10 || est.getMonth() === 10 && est.getDate() < dstStopDay);
  // finally we need to adjust the epoch based on whether we're in EST or EDT, since
  // the constant ATB_EPOCH is in EST, when we're in EDT we need to subtract an
  // hour otherwise we'll be off by 1 hour when we try to calc the major/minor version #'s:
  var epoch = isDST ? ATB_EPOCH - ONE_HOUR : ATB_EPOCH;
  // time in ms since DST adjusted epoch:
  var timeSinceATBEpoch = localTime - epoch;
  var majorVersion = Math.ceil(timeSinceATBEpoch / ONE_WEEK);
  var minorVersion = Math.ceil(timeSinceATBEpoch % ONE_WEEK / ONE_DAY);
  var version = "v".concat(majorVersion, "-").concat(minorVersion);
  return {
    minorVersion: minorVersion,
    majorVersion: majorVersion,
    version: version
  };
}
function getDaysBetweenCohorts(cohort1, cohort2) {
  return 7 * (cohort2.majorVersion - cohort1.majorVersion) + (cohort2.minorVersion - cohort1.minorVersion);
}
module.exports = {
  getCurrentATB: getCurrentATB,
  getDaysBetweenCohorts: getDaysBetweenCohorts
};

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var settings = require('./settings');
var parseUserAgentString = require('../shared-utils/parse-user-agent-string');
var load = require('./load');
var browserWrapper = require('./wrapper');
var _require = require('./dnr-utils'),
  ATB_PARAM_RULE_ID = _require.ATB_PARAM_RULE_ID;
var _require2 = require('@duckduckgo/ddg2dnr/lib/rulePriorities'),
  ATB_PARAM_PRIORITY = _require2.ATB_PARAM_PRIORITY;
var _require3 = require('@duckduckgo/ddg2dnr/lib/utils'),
  generateDNRRule = _require3.generateDNRRule;
var ATB_ERROR_COHORT = 'v1-1';
var ATB_FORMAT_RE = /(v\d+-\d(?:[a-z_]{2})?)$/;

// list of accepted params in ATB url
var ACCEPTED_URL_PARAMS = ['natb', 'cp', 'npi'];
var manifestVersion = browserWrapper.getManifestVersion();
var ATB = function () {
  // regex to match ddg urls to add atb params to.
  // Matching subdomains, searches, newsletter page and chrome new tab page
  var regExpAboutPage = /^https?:\/\/([\w-]+\.)?duckduckgo\.com\/(\?.*|about#newsletter|chrome_newtab)/;
  var matchPage = /^https:\/\/([\w-]+\.)?duckduckgo.com\/\?/;
  var ddgAtbURL = 'https://duckduckgo.com/atb.js?';
  return {
    shouldUpdateSetAtb: function shouldUpdateSetAtb(request) {
      return matchPage.test(request.url);
    },
    updateSetAtb: function () {
      var _updateSetAtb = _asyncToGenerator(function* () {
        yield settings.ready();
        var atbSetting = settings.getSetting('atb');
        var setAtbSetting = settings.getSetting('set_atb');
        var errorParam = '';

        // client shouldn't have a falsy ATB value,
        // so mark them as having gone into an errored state
        // next time they won't send the e=1 param
        if (!atbSetting) {
          atbSetting = ATB_ERROR_COHORT;
          settings.updateSetting('atb', ATB_ERROR_COHORT);
          ATB.setOrUpdateATBdnrRule(ATB_ERROR_COHORT);
          errorParam = '&e=1';
        }
        var user = settings.getSetting('userData');
        var emailSetting = user && user.userName ? 1 : 0;
        var randomValue = Math.ceil(Math.random() * 1e7);
        // @ts-ignore
        var url = "".concat(ddgAtbURL).concat(randomValue, "&browser=").concat(parseUserAgentString().browser, "&atb=").concat(atbSetting, "&set_atb=").concat(setAtbSetting, "&email=").concat(emailSetting).concat(errorParam);
        return load.JSONfromExternalFile(url).then(function (res) {
          settings.updateSetting('set_atb', res.data.version);
          if (res.data.updateVersion) {
            settings.updateSetting('atb', res.data.updateVersion);
            ATB.setOrUpdateATBdnrRule(res.data.updateVersion);
          } else if (atbSetting === ATB_ERROR_COHORT) {
            settings.updateSetting('atb', res.data.version);
            ATB.setOrUpdateATBdnrRule(res.data.version);
          }
        });
      });
      function updateSetAtb() {
        return _updateSetAtb.apply(this, arguments);
      }
      return updateSetAtb;
    }(),
    /**
    * Accept the URL of a main_frame request in progress. If atb parameters
    * should be added by redirection, mutate the URL to add the parameters
    * and return true. Otherwise, return false.
    * @param {URL} url
    *   The request URL.
    *   Note: This is mutated to add parameters where necessary.
    * @returns {boolean}
    *   True if parameters were added and the request should be redirected,
    *   false otherwise.
    */
    addParametersMainFrameRequestUrl: function addParametersMainFrameRequestUrl(url) {
      if (url.searchParams.has('atb')) {
        return false;
      }
      var atbSetting = settings.getSetting('atb');
      if (!atbSetting || !regExpAboutPage.test(url.href)) {
        return false;
      }
      url.searchParams.append('atb', atbSetting);
      return true;
    },
    setInitialVersions: function setInitialVersions(numTries) {
      numTries = numTries || 0;
      if (settings.getSetting('atb') || numTries > 5) return Promise.resolve();
      var randomValue = Math.ceil(Math.random() * 1e7);
      // @ts-ignore
      var url = ddgAtbURL + randomValue + '&browser=' + parseUserAgentString().browser;
      return load.JSONfromExternalFile(url).then(function (res) {
        settings.updateSetting('atb', res.data.version);
        ATB.setOrUpdateATBdnrRule(res.data.version);
      }, function () {
        console.log('couldn\'t reach atb.js for initial server call, trying again');
        numTries += 1;
        return new Promise(function (resolve) {
          setTimeout(resolve, 500);
        }).then(function () {
          return ATB.setInitialVersions(numTries);
        });
      });
    },
    finalizeATB: function finalizeATB(params) {
      var atb = settings.getSetting('atb');

      // build query string when atb param wasn't acquired from any URLs
      var paramString = params && params.has('atb') ? params.toString() : "atb=".concat(atb);
      // @ts-ignore
      var browserName = parseUserAgentString().browser;
      paramString += "&browser=".concat(browserName);

      // make this request only once
      if (settings.getSetting('extiSent')) return;
      settings.updateSetting('extiSent', true);
      settings.updateSetting('set_atb', atb);
      // just a GET request, we only care that the request was made
      load.url("https://duckduckgo.com/exti/?".concat(paramString));
    },
    // iterate over a list of accepted params, and retrieve them from a URL
    // builds a new query string containing only accepted params
    getAcceptedParamsFromURL: function getAcceptedParamsFromURL(url) {
      var validParams = new URLSearchParams();
      if (url === '') return validParams;
      var parsedParams = new URL(url).searchParams;
      ACCEPTED_URL_PARAMS.forEach(function (param) {
        if (parsedParams.has(param)) {
          validParams.append(param === 'natb' ? 'atb' : param,
          // @ts-ignore
          parsedParams.get(param));
        }
      });

      // Only return params if URL contains valid atb value
      // @ts-ignore
      if (validParams.has('atb') && ATB_FORMAT_RE.test(validParams.get('atb'))) {
        return validParams;
      }
      return new URLSearchParams();
    },
    updateATBValues: function updateATBValues() {
      // wait until settings is ready to try and get atb from the page
      return settings.ready().then(ATB.setInitialVersions).then(browserWrapper.getDDGTabUrls).then(function (urls) {
        var atb;
        var params;
        urls.some(function (url) {
          params = ATB.getAcceptedParamsFromURL(url);
          atb = params.has('atb') && params.get('atb');
          return !!atb;
        });
        if (atb) {
          settings.updateSetting('atb', atb);
          ATB.setOrUpdateATBdnrRule(atb);
        }
        ATB.finalizeATB(params);
      });
    },
    openPostInstallPage: function () {
      var _openPostInstallPage = _asyncToGenerator(function* () {
        // only show post install page on install if:
        // - the user wasn't already looking at the app install page
        // - the user hasn't seen the page before
        yield settings.ready();
        var tabs = yield _webextensionPolyfill["default"].tabs.query({
          currentWindow: true,
          active: true
        });
        var domain = tabs && tabs[0] ? tabs[0].url : '';
        if (ATB.canShowPostInstall(domain)) {
          settings.updateSetting('hasSeenPostInstall', true);
          var postInstallURL = 'https://duckduckgo.com/extension-success';
          var atb = settings.getSetting('atb');
          postInstallURL += atb ? "?atb=".concat(atb) : '';
          _webextensionPolyfill["default"].tabs.create({
            url: postInstallURL
          });
        }
      });
      function openPostInstallPage() {
        return _openPostInstallPage.apply(this, arguments);
      }
      return openPostInstallPage;
    }(),
    canShowPostInstall: function canShowPostInstall(domain) {
      var regExpPostInstall = /duckduckgo\.com\/app/;
      var regExpSoftwarePage = /duckduckgo\.com\/software/;
      if (!(domain && settings)) return false;
      return !settings.getSetting('hasSeenPostInstall') && !domain.match(regExpPostInstall) && !domain.match(regExpSoftwarePage);
    },
    /**
    * Creates a DNR rule for ATB parameters
    * @param {string} atb
    */
    setOrUpdateATBdnrRule: function setOrUpdateATBdnrRule(atb) {
      if (!atb || manifestVersion !== 3) {
        return;
      }
      var atbRule = generateDNRRule({
        id: ATB_PARAM_RULE_ID,
        priority: ATB_PARAM_PRIORITY,
        actionType: 'redirect',
        redirect: {
          transform: {
            queryTransform: {
              addOrReplaceParams: [{
                key: 'atb',
                value: atb
              }]
            }
          }
        },
        resourceTypes: ['main_frame'],
        requestDomains: ['duckduckgo.com'],
        regexFilter: regExpAboutPage.source
      });
      chrome.declarativeNetRequest.updateDynamicRules({
        removeRuleIds: [atbRule.id],
        addRules: [atbRule]
      });
    },
    getSurveyURL: function getSurveyURL() {
      return _asyncToGenerator(function* () {
        var url = ddgAtbURL + Math.ceil(Math.random() * 1e7) + '&uninstall=1&action=survey';
        var atb = settings.getSetting('atb');
        var setAtb = settings.getSetting('set_atb');
        if (atb) url += "&atb=".concat(atb);
        if (setAtb) url += "&set_atb=".concat(setAtb);
        var browserInfo = parseUserAgentString();
        // @ts-ignore
        var browserName = browserInfo.browser;
        // @ts-ignore
        var browserVersion = browserInfo.version;
        var extensionVersion = browserWrapper.getExtensionVersion();
        if (browserName) url += "&browser=".concat(browserName);
        if (browserVersion) url += "&bv=".concat(browserVersion);
        if (extensionVersion) url += "&v=".concat(extensionVersion);
        if (yield browserWrapper.getFromSessionStorage('dev')) {
          url += '&test=1';
        }
        return url;
      })();
    }
  };
}();
settings.ready().then( /*#__PURE__*/_asyncToGenerator(function* () {
  // set initial uninstall url
  browserWrapper.setUninstallURL(yield ATB.getSurveyURL());
}));
var _default = ATB;
exports["default"] = _default;

},{"../shared-utils/parse-user-agent-string":100,"./dnr-utils":73,"./load":83,"./settings":90,"./wrapper":99,"@duckduckgo/ddg2dnr/lib/rulePriorities":27,"@duckduckgo/ddg2dnr/lib/utils":33,"webextension-polyfill":11}],48:[function(require,module,exports){
"use strict";

var _startup = require("./startup");
/*
 * Copyright (C) 2012, 2016 DuckDuckGo, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// NOTE: this needs to be the first thing that's require()d when the extension loads.
// otherwise FF might miss the onInstalled event
require('./events');
var settings = require('./settings');
require('./dnr-config-rulesets');
require('./script-injection');
settings.ready().then(function () {
  (0, _startup.onStartup)();
});

},{"./dnr-config-rulesets":68,"./events":75,"./script-injection":89,"./settings":90,"./startup":91}],49:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackerBlockedEvent = void 0;
exports.blockHandleResponse = blockHandleResponse;
exports.emitter = void 0;
exports.handleRequest = handleRequest;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _eventemitter = _interopRequireDefault(require("eventemitter2"));
var _atb = _interopRequireDefault(require("./atb"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var tldts = require('tldts');
var utils = require('./utils');
var trackers = require('./trackers');
var https = require('./https');
var Companies = require('./companies');
var tabManager = require('./tab-manager');
var browserWrapper = require('./wrapper');
var settings = require('./settings');
var devtools = require('./devtools');
var trackerAllowlist = require('./allowlisted-trackers');
var _require = require('./url-parameters'),
  stripTrackingParameters = _require.stripTrackingParameters,
  trackingParametersStrippingEnabled = _require.trackingParametersStrippingEnabled;
var ampProtection = require('./amp-protection');
var _require2 = require('./click-to-load'),
  displayClickToLoadPlaceholders = _require2.displayClickToLoadPlaceholders,
  getDefaultEnabledClickToLoadRuleActionsForTab = _require2.getDefaultEnabledClickToLoadRuleActionsForTab;
function buildResponse(url, requestData, tab, isMainFrame) {
  if (url.toLowerCase() !== requestData.url.toLowerCase()) {
    console.log('HTTPS: upgrade request url to ' + url);
    tab.httpsRedirects.registerRedirect(requestData);
    if (isMainFrame) {
      tab.upgradedHttps = true;
    }
    if (utils.getUpgradeToSecureSupport()) {
      return {
        upgradeToSecure: true
      };
    } else {
      return {
        redirectUrl: url
      };
    }
  } else if (isMainFrame) {
    tab.upgradedHttps = false;
  }
}
function updateTabCleanAmpUrl(currentTab, canonicalUrl, url) {
  if (currentTab) {
    currentTab.cleanAmpUrl = canonicalUrl || url;
  }
}
function handleAmpAsyncRedirect(_x, _x2) {
  return _handleAmpAsyncRedirect.apply(this, arguments);
}
function _handleAmpAsyncRedirect() {
  _handleAmpAsyncRedirect = _asyncToGenerator(function* (thisTab, url) {
    var canonicalUrl = yield ampProtection.fetchAMPURL(thisTab.site, url);
    var currentTab = tabManager.get({
      tabId: thisTab.id
    });
    updateTabCleanAmpUrl(currentTab, canonicalUrl, url);
    if (canonicalUrl) {
      return {
        redirectUrl: canonicalUrl
      };
    }
  });
  return _handleAmpAsyncRedirect.apply(this, arguments);
}
function handleAmpDelayedUpdate(_x3, _x4) {
  return _handleAmpDelayedUpdate.apply(this, arguments);
}
function _handleAmpDelayedUpdate() {
  _handleAmpDelayedUpdate = _asyncToGenerator(function* (thisTab, url) {
    var canonicalUrl = yield ampProtection.fetchAMPURL(thisTab.site, url);
    var currentTab = tabManager.get({
      tabId: thisTab.id
    });
    var newUrl = canonicalUrl || url;
    updateTabCleanAmpUrl(currentTab, canonicalUrl, url);
    _webextensionPolyfill["default"].tabs.update(thisTab.id, {
      url: newUrl
    });
  });
  return _handleAmpDelayedUpdate.apply(this, arguments);
}
function handleAmpRedirect(thisTab, url) {
  if (!thisTab) {
    return;
  }
  if (utils.getBrowserName() === 'moz') {
    return handleAmpAsyncRedirect(thisTab, url);
  }
  handleAmpDelayedUpdate(thisTab, url);
  return {
    redirectUrl: 'about:blank'
  };
}

/**
 * Where most of the extension work happens.
 *
 * For each request made:
 * - Add ATB param
 * - Block tracker requests
 * - Upgrade http -> https where possible
 * @param {import('webextension-polyfill').WebRequest.OnBeforeRedirectDetailsType} requestData
 */
function handleRequest(requestData) {
  var thisTab = tabManager.get(requestData);

  // control access to web accessible resources
  if (requestData.url.startsWith(browserWrapper.getExtensionURL('/web_accessible_resources'))) {
    if (!thisTab || !thisTab.hasWebResourceAccess(requestData.url)) {
      return {
        cancel: true
      };
    }
  }

  // There is a chance this tab was closed before the
  // webRequest.onBeforeRequest event fired. For new tabs, there is also a
  // chance that the webRequest.onBeforeRequest event fired before the
  // tabs.onCreated event.
  if (!thisTab) return;
  if (requestData.type === 'main_frame') {
    var mainFrameRequestURL = new URL(requestData.url);

    // AMP protection
    var canonUrl = ampProtection.extractAMPURL(thisTab.site, mainFrameRequestURL.href);
    if (canonUrl) {
      thisTab.setAmpUrl(mainFrameRequestURL.href);
      updateTabCleanAmpUrl(thisTab, canonUrl, mainFrameRequestURL.href);
      mainFrameRequestURL = new URL(canonUrl);
    } else if (ampProtection.tabNeedsDeepExtraction(requestData, thisTab, mainFrameRequestURL)) {
      thisTab.setAmpUrl(mainFrameRequestURL.href);
      return handleAmpRedirect(thisTab, mainFrameRequestURL.href);
    } else if (thisTab.cleanAmpUrl && mainFrameRequestURL.host !== new URL(thisTab.cleanAmpUrl).host) {
      thisTab.ampUrl = null;
      thisTab.cleanAmpUrl = null;
    }
    var ampRedirected = thisTab.ampUrl && thisTab.cleanAmpUrl && thisTab.cleanAmpUrl !== thisTab.ampUrl && requestData.url === thisTab.ampUrl;

    // Tracking parameter stripping.

    thisTab.urlParametersRemoved =
    // Tracking parameters were stripped previously, this is the request
    // event that fired after the redirection to strip the parameters.
    thisTab.urlParametersRemovedUrl && thisTab.urlParametersRemovedUrl === requestData.url ||
    // Strip tracking parameters if 1. there are any and 2. the feature
    // is enabled for both the request URL and the initiator URL.
    trackingParametersStrippingEnabled(thisTab.site, requestData.initiator || requestData.originUrl) && stripTrackingParameters(mainFrameRequestURL);

    // To strip tracking parameters, the request is redirected and this event
    // listener fires again for the redirected request. Take note of the URL
    // before redirecting the request, so that  the `urlParametersRemoved`
    // breakage flag persists after the redirection.
    if (thisTab.urlParametersRemoved && !thisTab.urlParametersRemovedUrl) {
      thisTab.urlParametersRemovedUrl = mainFrameRequestURL.href;
    } else {
      thisTab.urlParametersRemovedUrl = null;
    }

    // add atb params only to main_frame
    var atbParametersAdded = _atb["default"].addParametersMainFrameRequestUrl(mainFrameRequestURL);
    if (thisTab.urlParametersRemoved || ampRedirected || atbParametersAdded) {
      return {
        redirectUrl: mainFrameRequestURL.href
      };
    }
  } else {
    /**
     * Check that we have a valid tab
     * there is a chance this tab was closed before
     * we got the webrequest event
     */
    if (!(thisTab.url && thisTab.id)) return;

    // skip blocking on new tab and extension pages
    if (thisTab.site.specialDomainName) {
      return;
    }
    var handleResponse = blockHandleResponse(thisTab, requestData);
    if (handleResponse) {
      return handleResponse;
    }
  }

  /**
   * HTTPS Everywhere rules
   * If an upgrade rule is found, request is upgraded from http to https
   */

  if (!thisTab.site) return;

  // Skip https upgrade on broken sites
  if (thisTab.site.isBroken) {
    console.log('temporarily skip https upgrades for site: ' + utils.extractHostFromURL(thisTab.url) + '\n' + 'more info: https://github.com/duckduckgo/privacy-configuration');
    return;
  }

  // Is this request from the tab's main frame?
  var isMainFrame = requestData.type === 'main_frame';
  var isPost = requestData.method === 'POST';

  // Skip https upgrade if host failed before or if we detect redirect loop
  if (!thisTab.httpsRedirects.canRedirect(requestData)) {
    if (isMainFrame) {
      thisTab.upgradedHttps = false;
    }
    return;
  }

  // Fetch upgrade rule from https module:
  var resultUrl = https.getUpgradedUrl(requestData.url, thisTab, isMainFrame, isPost);
  if (resultUrl instanceof Promise) {
    return resultUrl.then(function (url) {
      return buildResponse(url, requestData, thisTab, isMainFrame);
    });
  } else {
    return buildResponse(resultUrl, requestData, thisTab, isMainFrame);
  }
}

/**
 * For publishing tracking events that other modules might care about
 * @type {EventEmitter2}
 */
var emitter = new _eventemitter["default"]();

/**
 * An event to publish the fact that we blocked a tracker.
 * Note: this is deliberately conservative about how much information is published,
 * for now it's just the parent company's display name which is enough
 * to power the NewTabTrackerStats module.
 */
exports.emitter = emitter;
var TrackerBlockedEvent = /*#__PURE__*/_createClass(
/**
 * @param {object} params
 * @param {string} params.companyDisplayName
 */
function TrackerBlockedEvent(params) {
  _classCallCheck(this, TrackerBlockedEvent);
  this.companyDisplayName = params.companyDisplayName;
});
/**
 * Tracker blocking
 * If request is a tracker, cancel the request
 * @param {import('./classes/tab')} thisTab
 * @param {import('webextension-polyfill').WebRequest.OnBeforeRedirectDetailsType} requestData
 * @returns {browser.WebRequest.BlockingResponseOrPromise | undefined}
 */
exports.TrackerBlockedEvent = TrackerBlockedEvent;
_defineProperty(TrackerBlockedEvent, "eventName", 'tracker-blocked');
function blockHandleResponse(thisTab, requestData) {
  var blockingEnabled = thisTab.site.isContentBlockingEnabled();

  // Find the supported and enabled Click to Load rule actions for this tab.
  var enabledRuleActions = new Set(getDefaultEnabledClickToLoadRuleActionsForTab(thisTab).filter(function (ruleAction) {
    return !thisTab.disabledClickToLoadRuleActions.includes(ruleAction);
  }));
  var tracker = trackers.getTrackerData(requestData.url, thisTab.site.url, requestData, enabledRuleActions);
  var baseDomain = trackers.getBaseDomain(requestData.url);
  var serviceWorkerInitiated = requestData.tabId === -1;
  if (tracker) {
    var _tracker$matchedRule, _tracker$matchedRule$, _reportedTracker$matc, _reportedTracker$matc2;
    if (tracker !== null && tracker !== void 0 && (_tracker$matchedRule = tracker.matchedRule) !== null && _tracker$matchedRule !== void 0 && (_tracker$matchedRule$ = _tracker$matchedRule.action) !== null && _tracker$matchedRule$ !== void 0 && _tracker$matchedRule$.startsWith('block-ctl-')) {
      displayClickToLoadPlaceholders(thisTab, tracker.matchedRule.action);
    }

    // temp allowlisted trackers to fix site breakage
    if (thisTab.site.isFeatureEnabled('trackerAllowlist')) {
      var allowListed = trackerAllowlist(thisTab.site.url, requestData.url);
      if (allowListed) {
        console.log("Allowlisted: ".concat(requestData.url, " Reason: ").concat(allowListed.reason));
        tracker.action = 'ignore';
        tracker.reason = "tracker allowlist - ".concat(allowListed.reason);
      }
    }

    // ad click attribution
    if (thisTab.allowAdAttribution(requestData.url)) {
      tracker.action = 'ad-attribution';
      tracker.reason = 'tracker allowlist - ad click';
    }
    if (!blockingEnabled && (tracker.action === 'block' || tracker.action === 'redirect')) {
      tracker.action = 'ignore-user';
      tracker.reason = 'content blocking disabled';
    }
    if (serviceWorkerInitiated && (tracker.action === 'block' || tracker.action === 'redirect')) {
      if (!thisTab.site.isFeatureEnabled('serviceworkerInitiatedRequests')) {
        tracker.action = 'ignore-user';
        tracker.reason = 'service worker initiated request blocking disabled';
      } else {
        tracker.reason += ' (service worker)';
      }
    }

    // allow embedded twitter content if user enabled this setting
    if (tracker.fullTrackerDomain === 'platform.twitter.com' && settings.getSetting('embeddedTweetsEnabled') === true) {
      tracker.action = 'ignore-user';
      tracker.reason = 'embedded tweets allowed';
    }
    var reportedTracker = _objectSpread({}, tracker);
    var cleanUrl = new URL(requestData.url);
    cleanUrl.search = '';
    cleanUrl.hash = '';
    // @ts-ignore
    thisTab.postDevtoolsMessage(devtools, 'tracker', {
      tracker: _objectSpread(_objectSpread({}, reportedTracker), {}, {
        matchedRule: (_reportedTracker$matc = reportedTracker.matchedRule) === null || _reportedTracker$matc === void 0 ? void 0 : (_reportedTracker$matc2 = _reportedTracker$matc.rule) === null || _reportedTracker$matc2 === void 0 ? void 0 : _reportedTracker$matc2.toString()
      }),
      url: cleanUrl,
      requestData: requestData,
      siteUrl: thisTab.site.url,
      serviceWorkerInitiated: serviceWorkerInitiated
    });

    // Count and block trackers.

    // Determine if this tracker was coming from our current tab. There can be cases where a tracker request
    // comes through on document unload and by the time we block it we have updated our tab data to the new
    // site. This can make it look like the tracker was on the new site we navigated to. We're blocking the
    // request anyway but deciding to show it in the popup or not. If we have a documentUrl, use it, otherwise
    // just default to true.
    var sameDomainDocument = isSameDomainRequest(thisTab, requestData);
    if (sameDomainDocument) {
      // record all tracker urls on a site even if we don't block them
      thisTab.site.addTracker(tracker);

      // record potential blocked trackers for this tab
      // without a baseDomain, it wouldn't make sense to record this
      if (baseDomain) {
        var url = utils.getURLWithoutQueryString(requestData.url);
        thisTab.addToTrackers(tracker, baseDomain, url);
      }
    }
    // the tab has finished loading
    browserWrapper.notifyPopup({
      updateTabData: true
    });
    // Block the request if the site is not allowlisted
    if (['block', 'redirect'].includes(tracker.action)) {
      // @ts-ignore
      Companies.add(tracker.tracker.owner);

      // publish the parent's display name only
      var displayName = utils.findParentDisplayName(requestData.url);
      emitter.emit(TrackerBlockedEvent.eventName, new TrackerBlockedEvent({
        companyDisplayName: displayName
      }));
      console.info('blocked ' + utils.extractHostFromURL(thisTab.url) +
      // @ts-ignore
      ' [' + tracker.tracker.owner.name + '] ' + requestData.url + (serviceWorkerInitiated ? ' (serviceworker)' : ''));

      // return surrogate redirect if match, otherwise
      // tell Chrome to cancel this webrequest
      if (tracker.redirectUrl && tracker.matchedRule) {
        var webResource = browserWrapper.getExtensionURL("web_accessible_resources/".concat(tracker.matchedRule.surrogate));

        // Firefox: check these for Origin headers in onBeforeSendHeaders before redirecting or not. Workaround for
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1694679
        // Surrogates that for sure need to load should have 'strictRedirect' set, and will have their headers checked
        // in onBeforeSendHeaders
        if (tracker.matchedRule.strictRedirect && utils.getBrowserName() === 'moz') {
          thisTab.surrogates[requestData.url] = webResource;
        } else {
          var key = thisTab.addWebResourceAccess(webResource);
          return {
            redirectUrl: "".concat(webResource, "?key=").concat(key)
          };
        }
      } else {
        return {
          cancel: true
        };
      }
    }
  }

  /**
   * Notify skipping for broken sites
   */
  if (thisTab.site.isBroken) {
    console.log('temporarily skip tracker blocking for site: ' + utils.extractHostFromURL(thisTab.url) + '\n' + 'more info: https://github.com/duckduckgo/privacy-configuration');
  }

  // If we didn't block this script and it's a tracker, notify the content script.
  if (requestData.type === 'script' && tracker && !tracker.sameEntity) {
    utils.sendTabMessage(requestData.tabId, {
      type: 'update',
      trackerDefinition: true,
      hostname: tldts.parse(requestData.url).hostname
    }, {
      frameId: requestData.frameId
    });
  }
}

/* Check to see if a request came from our current tab. This generally handles the
 * case of pings that fire on document unload. We can get into a case where we count the
 * ping to the new site we navigated to.
 *
 * In Firefox we can check the request frameAncestors to see if our current
 * tab url is one of the ancestors.
 * In Chrome we don't have access to a sub_frame ancestors. We can check that a request
 * is coming from the main_frame and that it matches our current tab url
 */
function isSameDomainRequest(tab, req) {
  // Firefox
  if (req.documentUrl) {
    if (req.frameAncestors && req.frameAncestors.length) {
      var ancestors = req.frameAncestors.reduce(function (lst, f) {
        lst.push(f.url);
        return lst;
      }, []);
      return ancestors.includes(tab.url);
    } else {
      return req.documentUrl === tab.url;
    }
    // Chrome
  } else if (req.initiator && req.frameId === 0) {
    return !!tab.url.match(req.initiator);
  } else {
    return true;
  }
}

},{"./allowlisted-trackers":44,"./amp-protection":45,"./atb":47,"./click-to-load":63,"./companies":64,"./devtools":66,"./https":82,"./settings":90,"./tab-manager":94,"./trackers":96,"./url-parameters":97,"./utils":98,"./wrapper":99,"eventemitter2":6,"tldts":10,"webextension-polyfill":11}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breakageReportForTab = breakageReportForTab;
exports.fire = fire;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/**
 *
 * This is part of our tool for anonymous broken site reports
 * Learn more at https://duck.co/help/privacy/atb
 *
 */
var load = require('./load');
var browserWrapper = require('./wrapper');
var settings = require('./settings');
var parseUserAgentString = require('../shared-utils/parse-user-agent-string');
var _require = require('./utils'),
  getURLWithoutQueryString = _require.getURLWithoutQueryString;
var _require2 = require('./pixels'),
  getURL = _require2.getURL;

/**
 *
 * Fire a pixel
 *
 * @param {string} querystring
 *
 */
function fire(querystring) {
  var randomNum = Math.ceil(Math.random() * 1e7);
  var pixelName = 'epbf';
  var browserInfo = parseUserAgentString();
  var browser = browserInfo === null || browserInfo === void 0 ? void 0 : browserInfo.browser;
  var extensionVersion = browserWrapper.getExtensionVersion();
  var atb = settings.getSetting('atb');
  var searchParams = new URLSearchParams(querystring);
  if (extensionVersion) {
    searchParams.append('extensionVersion', extensionVersion);
  }
  if (atb) {
    searchParams.append('atb', atb);
  }
  if (searchParams.get('category') === 'null') {
    searchParams["delete"]('category');
  }
  // build url string
  var url = getURL(pixelName);
  if (browser) {
    url += "_".concat(browser.toLowerCase());
  }
  // random number cache buster
  url += "?".concat(randomNum, "&");
  // some params should be not urlencoded
  var extraParams = '';
  ['tds', 'blockedTrackers', 'surrogates'].forEach(function (key) {
    if (searchParams.has(key)) {
      extraParams += "&".concat(key, "=").concat(decodeURIComponent(searchParams.get(key) || ''));
      searchParams["delete"](key);
    }
  });
  url += "".concat(searchParams.toString()).concat(extraParams);

  // Send the request
  load.url(url);
}

/**
 * Given an optional category and description, create a report for a given Tab instance.
 *
 * This code previously lived within the UI section of the dashboard,
 * but has been moved here since there's no longer a relationship to 'where' this request
 * came from.
 *
 * @param {import("./classes/tab")} tab
 * @param {string} tds - tds-etag from settings
 * @param {string | undefined} category - optional category
 * @param {string | undefined} description - optional description
 */
function breakageReportForTab(tab, tds, category, description) {
  if (!tab.url) {
    return;
  }
  var siteUrl = getURLWithoutQueryString(tab.url).split('#')[0];
  var blocked = [];
  var surrogates = [];
  for (var _i = 0, _Object$values = Object.values(tab.trackers); _i < _Object$values.length; _i++) {
    var tracker = _Object$values[_i];
    for (var _i2 = 0, _Object$entries = Object.entries(tracker.urls); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        entry = _Object$entries$_i[1];
      var _key$split = key.split(':'),
        _key$split2 = _slicedToArray(_key$split, 1),
        fullDomain = _key$split2[0];
      if (entry.action === 'block') {
        blocked.push(fullDomain);
      }
      if (entry.action === 'redirect') {
        surrogates.push(fullDomain);
      }
    }
  }
  var urlParametersRemoved = tab.urlParametersRemoved ? 'true' : 'false';
  var ctlYouTube = tab.ctlYouTube ? 'true' : 'false';
  var ampUrl = tab.ampUrl || undefined;
  var upgradedHttps = tab.upgradedHttps;
  var brokenSiteParams = new URLSearchParams({
    siteUrl: siteUrl,
    tds: tds,
    upgradedHttps: upgradedHttps.toString(),
    urlParametersRemoved: urlParametersRemoved,
    ctlYouTube: ctlYouTube,
    blockedTrackers: blocked.join(','),
    surrogates: surrogates.join(',')
  });
  if (ampUrl) brokenSiteParams.set('ampUrl', ampUrl);
  if (category) brokenSiteParams.set('category', category);
  if (description) brokenSiteParams.set('description', description);
  return fire(brokenSiteParams.toString());
}

},{"../shared-utils/parse-user-agent-string":100,"./load":83,"./pixels":87,"./settings":90,"./utils":98,"./wrapper":99}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AdClickAttributionPolicy = exports.AdClick = void 0;
var _rulePriorities = require("@duckduckgo/ddg2dnr/lib/rulePriorities");
var _utils = require("@duckduckgo/ddg2dnr/lib/utils");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('../utils'),
  getFeatureSettings = _require.getFeatureSettings,
  getBaseDomain = _require.getBaseDomain;
var browserWrapper = require('../wrapper');
var _require2 = require('../dnr-session-rule-id'),
  getNextSessionRuleId = _require2.getNextSessionRuleId;
var manifestVersion = browserWrapper.getManifestVersion();

/**
 * @typedef AdClickAttributionLinkFormat
 * @property {string} url
 * @property {string} [adDomainParameterName]
 **/

/**
 * @typedef AdClickAttributionAllowListItem
 * @property {string} blocklistEntry
 * @property {string} host
 **/

/**
 * @typedef { import('./tab') } Tab
 */
var AdClickAttributionPolicy = /*#__PURE__*/function () {
  function AdClickAttributionPolicy() {
    _classCallCheck(this, AdClickAttributionPolicy);
    var policy = getFeatureSettings('adClickAttribution');

    /** @type {AdClickAttributionLinkFormat[]} */
    this.linkFormats = policy.linkFormats || [];
    /** @type {AdClickAttributionAllowListItem[]} */
    this.allowlist = policy.allowlist || [];
    this.navigationExpiration = policy.navigationExpiration || 0;
    this.totalExpiration = policy.totalExpiration || 0;
    this.domainDetectionEnabled = policy.domainDetection === 'enabled';
    this.heuristicDetectionEnabled = policy.heuristicDetection === 'enabled';
  }

  /**
   * @param {URL} resourceURL
   * @returns {AdClickAttributionLinkFormat | undefined}
   */
  _createClass(AdClickAttributionPolicy, [{
    key: "getMatchingLinkFormat",
    value: function getMatchingLinkFormat(resourceURL) {
      var hostnameAndPath = resourceURL.hostname + resourceURL.pathname;
      var _iterator = _createForOfIteratorHelper(this.linkFormats),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var linkFormat = _step.value;
          if (hostnameAndPath === linkFormat.url) {
            if (linkFormat.adDomainParameterName) {
              var parameterDomain = resourceURL.searchParams.get(linkFormat.adDomainParameterName);
              if (parameterDomain !== null) {
                return linkFormat;
              }
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    /**
     * Constructs an AdClick object to be stored on the tab if the load is a valid ad click link format.
     * @param {string} resourcePath
     * @param {Tab} tab
     * @returns {AdClick | undefined}
     */
  }, {
    key: "createAdClick",
    value: function createAdClick(resourcePath, tab) {
      var resourceURL;
      try {
        resourceURL = new URL(resourcePath);
      } catch (_unused) {
        return;
      }
      var linkFormat = this.getMatchingLinkFormat(resourceURL);
      if (!linkFormat) return;
      var adClick = new AdClick(this.navigationExpiration, this.totalExpiration, this.allowlist);
      if (manifestVersion === 3) {
        adClick.createDNR(tab.id);
      }
      if (linkFormat.adDomainParameterName) {
        var parameterDomain = resourceURL.searchParams.get(linkFormat.adDomainParameterName);
        if (parameterDomain && this.domainDetectionEnabled) {
          var parsedParameterDomain = getBaseDomain(parameterDomain);
          if (parsedParameterDomain) {
            adClick.setAdBaseDomain(parsedParameterDomain);
            return adClick;
          }
        }
      }
      if (this.heuristicDetectionEnabled) {
        adClick.adClickRedirect = true;
        return adClick;
      }
    }

    /**
     * @param {string} resourcePath
     * @returns {boolean}
     */
  }, {
    key: "resourcePermitted",
    value: function resourcePermitted(resourcePath) {
      var resourceURL;
      try {
        resourceURL = new URL(resourcePath);
      } catch (_unused2) {
        return true; // fail open if we can't parse the URL
      }
      var _iterator2 = _createForOfIteratorHelper(this.allowlist),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var allowlistItem = _step2.value;
          if (resourceURL.hostname === allowlistItem.host || resourceURL.hostname.endsWith('.' + allowlistItem.host)) {
            return true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return false;
    }
  }]);
  return AdClickAttributionPolicy;
}();
exports.AdClickAttributionPolicy = AdClickAttributionPolicy;
var AdClick = /*#__PURE__*/function () {
  /**
   * @param {number} navigationExpiration in seconds
   * @param {number} totalExpiration in seconds
   */
  function AdClick(navigationExpiration, totalExpiration, allowlist) {
    _classCallCheck(this, AdClick);
    /** @type {string | null} */
    this.adBaseDomain = null;
    this.adClickRedirect = false;
    this.navigationExpiration = navigationExpiration;
    this.totalExpiration = totalExpiration;
    this.expires = Date.now() + this.totalExpiration * 1000;
    this.clickExpires = Date.now() + this.navigationExpiration * 1000;
    this.allowlist = allowlist;
    this.adClickDNR = null;
  }
  _createClass(AdClick, [{
    key: "clone",
    value: function clone() {
      var adClick = new AdClick(this.navigationExpiration, this.totalExpiration, this.allowlist);
      adClick.adBaseDomain = this.adBaseDomain;
      adClick.adClickRedirect = this.adClickRedirect;
      adClick.expires = this.expires;
      adClick.clickExpires = Date.now() + this.navigationExpiration * 1000;
      adClick.adClickDNR = this.adClickDNR;
      return adClick;
    }

    /**
     * Propagate an adclick to a new tab, used when a user navigates to a new tab.
     * @param {number} tabId
     * @returns {AdClick} adClick
     */
  }, {
    key: "propagate",
    value: function propagate(tabId) {
      var adClick = this.clone();
      if (this.adClickDNR) {
        this.createDNR(tabId);
      }
      return adClick;
    }
  }, {
    key: "setAdBaseDomain",
    value:
    /**
     * @param {string} domain
     **/
    function setAdBaseDomain(domain) {
      this.adBaseDomain = domain;
      this.adClickRedirect = false;
      if (this.adClickDNR) {
        this.updateDNRInitiator(domain);
      }
    }

    /**
     * @param {Tab} tab
     * @returns {boolean} true if a new tab should have the ad attribution policy applied
     */
  }, {
    key: "shouldPropagateAdClickForNewTab",
    value: function shouldPropagateAdClickForNewTab(tab) {
      if (tab.site.baseDomain === this.adBaseDomain) {
        return this.hasNotExpired();
      }
      return false;
    }

    /**
     * @param {Tab} tab
     * @returns {boolean} true if a new navigation should have the ad attribution policy applied
     */
  }, {
    key: "shouldPropagateAdClickForNavigation",
    value: function shouldPropagateAdClickForNavigation(tab) {
      if (tab.site.baseDomain !== this.adBaseDomain) {
        return this.clickExpires > Date.now();
      }
      return this.hasNotExpired();
    }
  }, {
    key: "hasNotExpired",
    value: function hasNotExpired() {
      if (this.expires > Date.now()) {
        return true;
      } else {
        this.removeDNR();
        return false;
      }
    }

    /**
     * For use of checking if a load should be permitted for a tab.
     * Returns true if the policy hasn't expired and the ad domain matches the tab domain.
     * @param {Tab} tab
     * @returns {boolean}
     */
  }, {
    key: "allowAdAttribution",
    value: function allowAdAttribution(tab) {
      if (tab.site.baseDomain !== this.adBaseDomain) return false;
      return this.hasNotExpired();
    }
  }, {
    key: "getAdClickDNR",
    value: function getAdClickDNR(tabId) {
      var adClickDNR = {
        rule: (0, _utils.generateDNRRule)({
          id: null,
          priority: _rulePriorities.AD_ATTRIBUTION_POLICY_PRIORITY,
          actionType: 'allow',
          requestDomains: this.allowlist.map(function (entry) {
            return entry.host;
          })
        })
      };
      adClickDNR.rule.condition.tabIds = [tabId];
      return adClickDNR;
    }
  }, {
    key: "updateDNRInitiator",
    value: function updateDNRInitiator(domain) {
      if (this.adClickDNR && domain) {
        this.adClickDNR.rule.condition.initiatorDomains = [domain];
        this.updateDNR();
      }
    }
  }, {
    key: "createDNR",
    value: function createDNR(tabId) {
      this.adClickDNR = this.getAdClickDNR(tabId);
      this.adClickDNR.rule.id = getNextSessionRuleId();
      chrome.declarativeNetRequest.updateSessionRules({
        addRules: [this.adClickDNR.rule]
      });
    }
  }, {
    key: "updateDNR",
    value: function updateDNR() {
      if (this.adClickDNR) {
        chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: [this.adClickDNR.rule.id],
          addRules: [this.adClickDNR.rule]
        });
      }
    }
  }, {
    key: "removeDNR",
    value: function removeDNR() {
      if (this.adClickDNR) {
        chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: [this.adClickDNR.rule.id]
        });
      }
    }
  }], [{
    key: "restore",
    value: function restore(adClick) {
      var restoredAdClick = new AdClick(adClick.navigationExpiration, adClick.totalExpiration, adClick.allowlist);
      restoredAdClick.adBaseDomain = adClick.adBaseDomain;
      restoredAdClick.adClickRedirect = adClick.adClickRedirect;
      restoredAdClick.expires = adClick.expires;
      restoredAdClick.clickExpires = adClick.clickExpires;
      restoredAdClick.adClickDNR = adClick.adClickDNR;
      return restoredAdClick;
    }
  }]);
  return AdClick;
}();
exports.AdClick = AdClick;

},{"../dnr-session-rule-id":70,"../utils":98,"../wrapper":99,"@duckduckgo/ddg2dnr/lib/rulePriorities":27,"@duckduckgo/ddg2dnr/lib/utils":33}],52:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Company = /*#__PURE__*/function () {
  function Company(c) {
    _classCallCheck(this, Company);
    this.name = c.name;
    this.count = 0;
    this.pagesSeenOn = 0;
    this.displayName = c.displayName || c.name;
  }
  _createClass(Company, [{
    key: "incrementCount",
    value: function incrementCount() {
      this.count += 1;
    }
  }, {
    key: "incrementPagesSeenOn",
    value: function incrementPagesSeenOn() {
      this.pagesSeenOn += 1;
    }
  }, {
    key: "get",
    value: function get(property) {
      return this[property];
    }
  }, {
    key: "set",
    value: function set(property, val) {
      this[property] = val;
    }
  }]);
  return Company;
}();
module.exports = Company;

},{}],53:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var utils = require('../utils');
var browserWrapper = require('../wrapper');
var _require = require('../dnr-smarter-encryption'),
  addSmarterEncryptionSessionException = _require.addSmarterEncryptionSessionException;
var MAINFRAME_RESET_MS = 3000;
var REQUEST_REDIRECT_LIMIT = 7;
var manifestVersion = browserWrapper.getManifestVersion();

/**
 * This class protects users from accidentally being sent into a redirect loop
 * if a site we've included into our HTTPS list redirects them back to HTTP.
 *
 * Every redirect we perform on a tab gets registered against an instance of this class.
 * If we hit too many redirects for a request, we block it via canRedirect().
 */
var HttpsRedirects = /*#__PURE__*/function () {
  function HttpsRedirects() {
    _classCallCheck(this, HttpsRedirects);
    this.failedUpgradeHosts = {};
    this.redirectCounts = {};
    this.mainFrameRedirect = null;
    this.clearMainFrameTimeout = null;
  }
  _createClass(HttpsRedirects, [{
    key: "registerRedirect",
    value: function registerRedirect(request) {
      if (request.type === 'main_frame') {
        if (this.mainFrameRedirect && request.url === this.mainFrameRedirect.url) {
          this.mainFrameRedirect.count += 1;
          return;
        }
        this.mainFrameRedirect = {
          url: request.url,
          time: Date.now(),
          count: 0
        };

        // @ts-ignore
        clearTimeout(this.clearMainFrameTimeout);
        this.clearMainFrameTimeout = setTimeout(this.resetMainFrameRedirect, MAINFRAME_RESET_MS);
      } else {
        this.redirectCounts[request.requestId] = this.redirectCounts[request.requestId] || 0;
        this.redirectCounts[request.requestId] += 1;
      }
    }
  }, {
    key: "canRedirect",
    value: function canRedirect(request) {
      var canRedirect = true;
      var hostname = utils.extractHostFromURL(request.url, true);

      // this hostname previously failed, don't try to upgrade it
      if (this.failedUpgradeHosts[hostname]) {
        console.log("HTTPS: not upgrading ".concat(request.url, ", hostname previously failed: ").concat(hostname));
        return false;
      }

      /**
       * Redirect loop detection is different when the request is for the main frame vs
       * any other request on the page.
       *
       * For main frames, the redirect loop could happen as part of several distinct hits to the same URL
       * (e.g. we saw a case where a site returned 200 and the redirected to HTTP via Javascript)
       *
       * To prevent this, we count main frame hits against the same URL within a short period of time,
       * and if they hit a certain threshold, we block any further attempts to upgrade this URL.
       *
       * We need to keep this threshold high, otherwise users can accidentally trigger redirect protection
       * by trying to open the same URL repeatedly before it's loaded.
       */
      if (request.type === 'main_frame') {
        if (this.mainFrameRedirect && this.mainFrameRedirect.url === request.url) {
          var timeSinceFirstHit = Date.now() - this.mainFrameRedirect.time;
          if (timeSinceFirstHit < MAINFRAME_RESET_MS && this.mainFrameRedirect.count >= REQUEST_REDIRECT_LIMIT) {
            canRedirect = false;
          }
        }
      } else if (this.redirectCounts[request.requestId]) {
        /**
         * For other requests, the server would likely just do a 301 redirect
         * to the HTTP version - so we can use the requestId as an identifier
         */
        canRedirect = this.redirectCounts[request.requestId] < REQUEST_REDIRECT_LIMIT;
      }

      // remember this hostname as previously failed, don't try to upgrade it
      if (!canRedirect) {
        this.failedUpgradeHosts[hostname] = true;
        console.log("HTTPS: not upgrading, redirect loop protection kicked in for url: ".concat(request.url));
        if (manifestVersion === 3) {
          // Create a temporary exception for the duration of the session
          addSmarterEncryptionSessionException(hostname);
        }
      }
      return canRedirect;
    }

    /**
     * We regenerate tab objects every time a new main_frame request is made.
     *
     * persistMainFrameRedirect() is used whenever a tab object is regenerated,
     * so we can maintain redirect loop protection across multiple main_frame requests
     */
  }, {
    key: "persistMainFrameRedirect",
    value: function persistMainFrameRedirect(redirectData) {
      if (!redirectData) {
        return;
      }

      // shallow copy to prevent pass-by-reference issues
      this.mainFrameRedirect = Object.assign({}, redirectData);

      // setup reset timeout again
      this.clearMainFrameTimeout = setTimeout(this.resetMainFrameRedirect, MAINFRAME_RESET_MS);
    }
  }, {
    key: "getMainFrameRedirect",
    value: function getMainFrameRedirect() {
      return this.mainFrameRedirect;
    }
  }, {
    key: "resetMainFrameRedirect",
    value: function resetMainFrameRedirect() {
      // @ts-ignore
      clearTimeout(this.clearMainFrameTimeout);
      this.mainFrameRedirect = null;
    }
  }]);
  return HttpsRedirects;
}();
module.exports = HttpsRedirects;

},{"../dnr-smarter-encryption":71,"../utils":98,"../wrapper":99}],54:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LegacyTabTransfer = void 0;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/**
 * This is used by the dashboard to get the tab data.
 */
var LegacyTabTransfer = /*#__PURE__*/_createClass(
/**
 * @param {import('./tab')} tab
 */
function LegacyTabTransfer(tab) {
  _classCallCheck(this, LegacyTabTransfer);
  var clonedTab = cloneClassObject(tab);
  var entries = Object.entries(clonedTab);
  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
    var _entries$_i = _slicedToArray(_entries[_i], 1),
      key = _entries$_i[0];
    this[key] = clonedTab[key];
  }
});
/**
 * @param {*} value
 * @returns {boolean}
 */
exports.LegacyTabTransfer = LegacyTabTransfer;
function isPrimitive(value) {
  return Object(value) !== value;
}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isStructuredCloneable(value) {
  return isPrimitive(value) || Array.isArray(value);
}
function cloneClassObject(object) {
  if (isStructuredCloneable(object)) {
    return structuredClone(object);
  }
  var out = {};
  for (var _i2 = 0, _Object$keys = Object.keys(object); _i2 < _Object$keys.length; _i2++) {
    var key = _Object$keys[_i2];
    var value = object[key];
    // Ignore 'private' keys
    if (key.startsWith('_')) {
      continue;
    }
    if (isStructuredCloneable(value)) {
      out[key] = structuredClone(value);
    } else {
      out[key] = cloneClassObject(value);
    }
  }
  if (hasModifiedPrototype(object)) {
    var objectDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(object));
    // Clone getter values
    for (var _i3 = 0, _Object$entries = Object.entries(objectDescriptors); _i3 < _Object$entries.length; _i3++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        _key = _Object$entries$_i[0],
        _value = _Object$entries$_i[1];
      if (typeof _value.get === 'function') {
        out[_key] = cloneClassObject(object[_key]);
      }
    }
  }
  return out;
}
function hasModifiedPrototype(object) {
  return Object.getPrototypeOf(object) !== Object.getPrototypeOf({});
}

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertState = convertState;
exports.dashboardDataFromTab = dashboardDataFromTab;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').GetPrivacyDashboardData} ExtensionGetPrivacyDashboardData
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').DetectedRequest} DetectedRequest
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').ProtectionsStatus} ProtectionsStatus
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').ParentEntity} ParentEntity
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').EmailProtectionUserData} EmailProtectionUserData
 */

/**
 * Convert internal extension data into a format accepted by the Privacy dashboard
 * The return type of this function comes from a schema defined in the Privacy Dashboard,
 *
 * @param {import("./tab.js")} tab
 * @param {EmailProtectionUserData | undefined | {}} userData
 * @returns {ExtensionGetPrivacyDashboardData}
 */
function dashboardDataFromTab(tab, userData) {
  var protectionsEnabled = !tab.site.allowlisted && !tab.site.isBroken && tab.site.enabledFeatures.includes('contentBlocking');

  // parent entity, if available
  /** @type {ParentEntity | undefined} */
  var parentEntity;
  if (tab.site.parentEntity) {
    var _tab$site$parentPreva;
    parentEntity = {
      displayName: tab.site.parentEntity,
      prevalence: (_tab$site$parentPreva = tab.site.parentPrevalence) !== null && _tab$site$parentPreva !== void 0 ? _tab$site$parentPreva : 0
    };
  }

  /** @type {ProtectionsStatus} */
  var protections = {
    allowlisted: Boolean(tab.site.allowlisted),
    denylisted: Boolean(tab.site.denylisted),
    unprotectedTemporary: Boolean(tab.site.isBroken),
    enabledFeatures: tab.site.enabledFeatures
  };
  var requests = convertToRequests(tab, protectionsEnabled);

  // Only assign `emailProtectionUserData` if we're sure it is valid data (eg: has at least 'nextAlias'
  // - otherwise allow it to be undefined.
  var emailProtectionUserData;
  if (userData && 'nextAlias' in userData) {
    emailProtectionUserData = userData;
  }
  return {
    tab: {
      id: tab.id,
      url: tab.url || '',
      protections: protections,
      upgradedHttps: tab.upgradedHttps,
      parentEntity: parentEntity,
      specialDomainName: tab.site.specialDomainName || undefined,
      /**
       * Explicitly setting this to 'en' for now. When ready we can send 2-character codes such
       * as 'pl' or 'de' etc. Please see https://duckduckgo.github.io/privacy-dashboard/interfaces/Generated_Schema_Definitions.LocaleSettings.html
       */
      localeSettings: {
        locale: 'en'
      }
    },
    requestData: {
      requests: requests
    },
    emailProtectionUserData: emailProtectionUserData
  };
}

/**
 * WIP - this is a just a hack to get the types working together, we'll create a better implementation
 *
 * @param {import('./tab')} tab
 * @param {boolean} protectionsEnabled
 * @returns {DetectedRequest[]}
 */
function convertToRequests(tab, protectionsEnabled) {
  /** @type {DetectedRequest[]} */
  var detectedRequests = [];
  for (var _i = 0, _Object$values = Object.values(tab.trackers || {}); _i < _Object$values.length; _i++) {
    var tracker = _Object$values[_i];
    for (var _i2 = 0, _Object$values2 = Object.values(tracker.urls || {}); _i2 < _Object$values2.length; _i2++) {
      var detectedRequest = _Object$values2[_i2];
      // When protections are off, change the 'state' of each tracking request
      if (!protectionsEnabled && detectedRequest.action !== 'none') {
        /** @type {DetectedRequest["state"]} */
        var nextState = {
          allowed: {
            reason: 'protectionDisabled'
          }
        };
        var request = _objectSpread(_objectSpread({}, detectedRequest), {}, {
          state: nextState
        });
        detectedRequests.push(request);
        continue;
      }

      // other, just add the request as-is
      detectedRequests.push(detectedRequest);
    }
  }
  return detectedRequests;
}

/**
 * @param {import('@duckduckgo/privacy-grade/src/classes/trackers.js').ActionName} action
 * @param {boolean} isSameEntity
 * @return {DetectedRequest["state"] | null}
 */
function convertState(action, isSameEntity) {
  if (action === 'none') {
    return {
      allowed: {
        reason: 'otherThirdPartyRequest'
      }
    };
  }
  if (action === 'ignore' || action === 'ignore-user') {
    if (isSameEntity) {
      return {
        allowed: {
          reason: 'ownedByFirstParty'
        }
      };
    }
    return {
      allowed: {
        reason: 'ruleException'
      }
    };
  }
  if (action === 'ad-attribution') {
    return {
      allowed: {
        reason: 'adClickAttribution'
      }
    };
  }
  if (action === 'block') {
    return {
      blocked: {}
    };
  }
  if (action === 'redirect') {
    return {
      blocked: {}
    };
  }
  /** @type {never} */
  // eslint-disable-next-line no-unused-vars
  var _output = action;
  return null;
}

},{}],56:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Each Site creates its own Grade instance. The attributes
 * of the Grade are updated as we process new events e.g. trackers
 * blocked or https status.
 *
 * The Grade attributes are then used generate a site
 * privacy grade used in the popup.
 */
var settings = require('../settings');
var utils = require('../utils');
var tdsStorage = require('./../storage/tds')["default"];
var privacyPractices = require('../privacy-practices');
var Grade = require('@duckduckgo/privacy-grade').Grade;
var browserWrapper = require('../wrapper');
var _require = require('./tab-state'),
  TabState = _require.TabState;

/**
 * @typedef {'allowlisted' | 'allowlistOptIn' | 'denylisted'} allowlistName
 */
var Site = /*#__PURE__*/function () {
  function Site(url, tabState) {
    _classCallCheck(this, Site);
    // If no tabState is passed in then we create a new one to simulate a new tab
    if (!tabState) {
      tabState = new TabState({
        tabId: 1,
        url: url,
        status: 'complete'
      });
    }
    this.url = url || '';
    /** @type {TabState} */
    this._tabState = tabState;
    this.trackerUrls = [];
    this.grade = new Grade();
    this.setListStatusFromGlobal();
    this.didIncrementCompaniesData = false;
    this.tosdr = privacyPractices.getTosdr(this.domain);
    if (this.parentEntity && this.parentPrevalence) {
      this.grade.setParentEntity(this.parentEntity, this.parentPrevalence);
    }
    if ('parent' in globalThis) {
      this.grade.setPrivacyScore(privacyPractices.getTosdrScore(this.domain, parent));
    }
    if (this.url.match(/^https:\/\//)) {
      this.grade.setHttps(true, true);
    }

    // set specialDomainName when the site is created
    this.specialDomainName = this.getSpecialDomain();
  }
  _createClass(Site, [{
    key: "allowlisted",
    get: function get() {
      return this._tabState.allowlisted;
    },
    set: function set(value) {
      this._tabState.setValue('allowlisted', value);
    }
  }, {
    key: "allowlistOptIn",
    get: function get() {
      return this._tabState.allowlistOptIn;
    },
    set: function set(value) {
      this._tabState.setValue('allowlistOptIn', value);
    }
  }, {
    key: "denylisted",
    get: function get() {
      return this._tabState.denylisted;
    },
    set: function set(value) {
      this._tabState.setValue('denylisted', value);
    }

    /**
     * Broken site reporting relies on the www. prefix being present as a.com matches *.a.com
     * This would make the list apply to a much larger audience than is required.
     * The other allowlisting code is different and probably should be changed to match.
     */
  }, {
    key: "isBroken",
    get: function get() {
      return utils.isBroken(this.domainWWW); // broken sites reported to github repo
    }
  }, {
    key: "enabledFeatures",
    get: function get() {
      return utils.getEnabledFeatures(this.domainWWW); // site issues reported to github repo
    }
  }, {
    key: "domain",
    get: function get() {
      var domain = utils.extractHostFromURL(this.url) || '';
      return domain.toLowerCase();
    }
  }, {
    key: "domainWWW",
    get: function get() {
      // Retain any www. prefix for our broken site lists
      var domainWWW = utils.extractHostFromURL(this.url, true) || '';
      return domainWWW.toLowerCase();
    }
  }, {
    key: "protocol",
    get: function get() {
      return this.url.substr(0, this.url.indexOf(':'));
    }
  }, {
    key: "baseDomain",
    get: function get() {
      return utils.getBaseDomain(this.url);
    }
  }, {
    key: "parentEntity",
    get: function get() {
      return utils.findParent(this.domain) || '';
    }
  }, {
    key: "parentPrevalence",
    get: function get() {
      var parent = tdsStorage.tds.entities[this.parentEntity];
      return parent ? parent.prevalence : 0;
    }

    /*
     * When site objects are created we check the stored lists
     * and set the new site list statuses
     */
  }, {
    key: "setListStatusFromGlobal",
    value: function setListStatusFromGlobal() {
      var _this = this;
      /** @type {allowlistName[]} */
      var globalLists = ['allowlisted', 'allowlistOptIn', 'denylisted'];
      globalLists.forEach(function (name) {
        var list = settings.getSetting(name) || {};
        _this.setListValue(name, list[_this.domain]);
      });
    }

    /**
     * @param {allowlistName} listName
     * @param {boolean} value
     */
  }, {
    key: "setListValue",
    value: function setListValue(listName, value) {
      if (value === true || value === false) {
        this[listName] = value;
      }
    }
  }, {
    key: "isContentBlockingEnabled",
    value: function isContentBlockingEnabled() {
      return this.isFeatureEnabled('contentBlocking');
    }
  }, {
    key: "isProtectionEnabled",
    value: function isProtectionEnabled() {
      if (this.denylisted) {
        return true;
      }
      // Check if user has allowed disabled blocking or it's a known broken site.
      return !(this.allowlisted || this.isBroken);
    }

    /**
     * Checks different toggles we have in the application:
     * - User toggle off
     * - Remotely disable it
     *      - tempAllowlist
     *      - "status" check
     *      - "exceptions" check
     * - User toggle on
     */
  }, {
    key: "isFeatureEnabled",
    value: function isFeatureEnabled(featureName) {
      var allowlistOnlyFeatures = ['autofill', 'adClickAttribution'];
      if (allowlistOnlyFeatures.includes(featureName)) {
        return this.enabledFeatures.includes(featureName);
      }
      if (this.denylisted) {
        return true;
      }
      return this.isProtectionEnabled() && this.enabledFeatures.includes(featureName);
    }

    /**
     * @param {import("../../../../node_modules/@duckduckgo/privacy-grade/src/classes/trackers").TrackerData} t
     */
  }, {
    key: "addTracker",
    value: function addTracker(t) {
      // Ignore trackers that aren't first party
      if (t.action === 'ignore' && !t.sameEntity) {
        return;
      }
      if (t.tracker && this.trackerUrls.indexOf(t.tracker.domain) === -1) {
        var _tdsStorage$tds$entit;
        this.trackerUrls.push(t.tracker.domain);
        var entityPrevalence = (_tdsStorage$tds$entit = tdsStorage.tds.entities[t.tracker.owner.name]) === null || _tdsStorage$tds$entit === void 0 ? void 0 : _tdsStorage$tds$entit.prevalence;
        if (t.action) {
          if (['block', 'redirect', 'ignore-user'].includes(t.action)) {
            this.grade.addEntityBlocked(t.tracker.owner.name, entityPrevalence);
          } else if (t.action === 'ignore') {
            this.grade.addEntityNotBlocked(t.tracker.owner.name, entityPrevalence);
          }
        }
      }
    }

    /*
     * specialDomain
     *
     * determine if domain is a special page
     *
     * returns: a useable special page description string.
     *          or null if not a special page.
     */
  }, {
    key: "getSpecialDomain",
    value: function getSpecialDomain() {
      var extensionId = browserWrapper.getExtensionId();
      var localhostName = 'localhost';
      var domain = this.domain,
        protocol = this.protocol,
        url = this.url;
      if (url === '') {
        return 'new tab';
      }

      // Both 'localhost' and the loopback IP have to be specified
      // since they're treated as different domains.
      if (domain === localhostName || domain.match(/^127\.0\.0\.1/)) {
        return localhostName;
      }

      // Handle non-routable meta-address.
      if (domain.match(/^0\.0\.0\.0/)) {
        return domain;
      }

      // For special pages with a protocol, just return whatever word comes
      // after the protocol. E.g. 'chrome://extensions' becomes 'extensions'.
      if (protocol === 'about' || protocol === 'chrome' || protocol === 'chrome-search' || protocol === 'vivaldi') {
        if (domain === 'newtab' || domain === 'local-ntp') {
          return 'new tab';
        }
        return domain;
      }
      if (protocol === 'file') {
        return 'local file';
      }

      // Extension pages
      if (protocol === 'chrome-extension' || protocol === 'moz-extension') {
        // This is our own extension, let's try and get a meaningful
        // description.
        if (domain === extensionId) {
          var matches = url.match(/^(?:chrome|moz)-extension:\/\/[^/]+\/html\/([a-z-]+).html/);
          if (matches && matches[1]) {
            return matches[1];
          }
        }

        // If we failed, or this is not our extension, return a generic message.
        return 'extension page';
      }

      // Our new tab page URL that is hard-coded in the Chromium source.
      // See https://source.chromium.org/chromium/chromium/src/+/main:components/search_engines/prepopulated_engines.json
      if (url === 'https://duckduckgo.com/chrome_newtab') {
        return 'new tab';
      }
      return null;
    }
  }]);
  return Site;
}();
module.exports = Site;

},{"../privacy-practices":88,"../settings":90,"../utils":98,"../wrapper":99,"./../storage/tds":93,"./tab-state":58,"@duckduckgo/privacy-grade":34}],57:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var Tab = require('./tab');

/**
 * A stub tab implementation for service workers.
 *
 * For most actions, this just mimics a tab with the service worker URL as the tab URL. However, for cases
 * such as tracker counts, it distributes stats to all known tabs with the same origin.
 */
var ServiceWorkerTab = /*#__PURE__*/function (_Tab) {
  _inherits(ServiceWorkerTab, _Tab);
  var _super = _createSuper(ServiceWorkerTab);
  /**
   * @param {string} swUrl
   * @param {Record<number, Tab>} tabContainer
   */
  function ServiceWorkerTab(swUrl, tabContainer) {
    var _this;
    _classCallCheck(this, ServiceWorkerTab);
    _this = _super.call(this, {
      tabId: -1,
      url: swUrl,
      status: null
    });
    _this.origin = new URL(swUrl).origin;
    _this.tabContainer = tabContainer;
    return _this;
  }

  /**
   * Find the list of tabs which share the same origin as this service worker.
   * @returns {Tab[]}
   */
  _createClass(ServiceWorkerTab, [{
    key: "_findMatchingTabs",
    value: function _findMatchingTabs() {
      var _this2 = this;
      // Iterate all tabs to find matching origins.
      // In future we may want to consider caching this data to avoid O(n) cost per request
      return Object.keys(this.tabContainer).filter(function (tabId) {
        var tab = _this2.tabContainer[tabId];
        try {
          return Number(tabId) > -1 && new URL(tab.url).origin === _this2.origin;
        } catch (e) {
          // URL can throw on invalid URL
          return false;
        }
      }).map(function (k) {
        return _this2.tabContainer[k];
      });
    }

    /**
     * @param t
     * @param {string} baseDomain
     * @param {string} url
     * @returns {import('./tracker').Tracker}
     */
  }, {
    key: "addToTrackers",
    value: function addToTrackers(tracker, baseDomain, url) {
      var results = this._findMatchingTabs().map(function (tab) {
        return tab.addToTrackers(tracker, baseDomain, url);
      });
      return results[0];
    }

    /**
     * Post a message to the devtools panel for all matching
     * @param {Object} devtools
     * @param {string} action
     * @param {Object} message
     */
  }, {
    key: "postDevtoolsMessage",
    value: function postDevtoolsMessage(devtools, action, message) {
      this._findMatchingTabs().forEach(function (tab) {
        return tab.postDevtoolsMessage(devtools, action, message);
      });
    }
  }]);
  return ServiceWorkerTab;
}(Tab);
module.exports = ServiceWorkerTab;

},{"./tab":59}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabState = void 0;
var _wrapper = require("../wrapper");
var _tracker = require("./tracker");
var _adClickAttributionPolicy = require("./ad-click-attribution-policy");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var TabState = /*#__PURE__*/function () {
  /**
   * @param {import('./tab').TabData} tabData
   */
  function TabState(tabData) {
    var restoring = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, TabState);
    this.tabId = tabData.tabId;
    this.url = tabData.url;
    /** @type {boolean} */
    this.upgradedHttps = false;
    /** @type {boolean} */
    this.hasHttpsError = false;
    /** @type {boolean} */
    this.mainFrameUpgraded = false;
    /** @type {boolean} */
    this.urlParametersRemoved = false;
    /** @type {string | null} */
    this.urlParametersRemovedUrl = null;
    /** @type {string | null} */
    this.ampUrl = null;
    /** @type {string | null} */
    this.cleanAmpUrl = null;
    this.requestId = tabData.requestId;
    this.status = tabData.status;
    this.statusCode = null; // statusCode is set when headers are recieved in tabManager.js
    /** @type {null | import('./ad-click-attribution-policy').AdClick} */
    this.adClick = null;
    /** @type {Record<string, import('./tracker').Tracker>} */
    this.trackers = {};
    /** @type {null | import('../events/referrer-trimming').Referrer} */
    this.referrer = null;
    /** @type {string[]} */
    this.disabledClickToLoadRuleActions = [];
    /** @type {Record<string, number[]>} */
    this.dnrRuleIdsByDisabledClickToLoadRuleAction = {};
    /** @type {boolean} */
    this.ctlYouTube = false; // True when at least one YouTube Click to Load placeholder was displayed in the tab.

    /** @type {boolean} */
    this.allowlisted = false; // user-allowlisted sites; applies to all privacy features
    /** @type {boolean} */
    this.allowlistOptIn = false;
    /** @type {boolean} */
    this.denylisted = false;
    // Whilst restoring, prevent the tab data being stored
    if (!restoring) {
      Storage.backup(this);
    }
  }
  _createClass(TabState, [{
    key: "setValue",
    value:
    /**
     * @template {InstanceType<typeof TabState>} T
     * @template {keyof T} K
     * @param {K} key
     * @param {T[K]} value
     */
    function setValue(key, value) {
      // @ts-expect-error - we know this is a valid key, ts doesn't seem to understand T matches this
      this[key] = value;
      // Fire and forget storage backup
      Storage.backup(this);
    }

    /**
     * Restores a tab state from storage.
     * @param {number} tabId
     * @returns {Promise<TabState | null>}
     */
  }], [{
    key: "done",
    value: function () {
      var _done = _asyncToGenerator(function* () {
        yield Storage.done();
      });
      function done() {
        return _done.apply(this, arguments);
      }
      return done;
    }()
  }, {
    key: "restore",
    value: function () {
      var _restore = _asyncToGenerator(function* (tabId) {
        var data = yield Storage.get(tabId);
        if (!data) {
          return null;
        }
        var parsedData;
        try {
          parsedData = JSON.parse(data);
        } catch (e) {
          console.error('Error parsing tab state', e);
          return null;
        }
        var state = new TabState(parsedData, true);
        for (var _i = 0, _Object$entries = Object.entries(parsedData); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];
          if (key === 'trackers') {
            /** @type {Record<string, import('./tracker').Tracker>} */
            var trackers = {};
            for (var _i2 = 0, _Object$keys = Object.keys(value); _i2 < _Object$keys.length; _i2++) {
              var trackerKey = _Object$keys[_i2];
              var tracker = parsedData[key][trackerKey];
              trackers[trackerKey] = _tracker.Tracker.restore(tracker);
            }
            state[key] = trackers;
          } else if (key === 'adClick' && value) {
            state[key] = _adClickAttributionPolicy.AdClick.restore(value);
          } else {
            state[key] = value;
          }
        }
        yield Storage.backup(state);
        return state;
      });
      function restore(_x) {
        return _restore.apply(this, arguments);
      }
      return restore;
    }()
    /**
     * Used for removing the stored tab state.
     * @param {number} tabId
     */
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator(function* (tabId) {
        yield Storage["delete"](tabId);
      });
      function _delete(_x2) {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
  }]);
  return TabState;
}();
/**
 * Singleton that handles storage of tab state to session storage.
 * Guarantees that the tasks are performed in the order they are added.
 * Fire and forget of the storage tasks to simplify call sites.
 */
exports.TabState = TabState;
var StorageInstance = /*#__PURE__*/function () {
  function StorageInstance() {
    _classCallCheck(this, StorageInstance);
    _defineProperty(this, "taskQueue", []);
    _defineProperty(this, "processing", false);
  }
  _createClass(StorageInstance, [{
    key: "done",
    value:
    /**
     * Awaits until the storage queue is empty.
     * @returns {Promise<void>}
     */
    function () {
      var _done2 = _asyncToGenerator(function* () {
        var queue = this.taskQueue;
        yield Promise.all(queue);
      });
      function done() {
        return _done2.apply(this, arguments);
      }
      return done;
    }()
    /**
     * Adds a task to the storage queue, prevents tasks from being executed in parallel.
     * Returns the result of the task.
     * Please handle the error handling of the task method yourself.
     * @template T
     * @param {() => Promise<T>} task
     * @returns {Promise<T>}
     */
  }, {
    key: "_addTask",
    value: function () {
      var _addTask2 = _asyncToGenerator(function* (task) {
        var done = function done(_) {};
        this.taskQueue.push( /*#__PURE__*/_asyncToGenerator(function* () {
          var value = yield Promise.resolve(task());
          done(value);
        }));
        this.processQueue();
        return new Promise(function (resolve) {
          done = resolve;
        });
      });
      function _addTask(_x3) {
        return _addTask2.apply(this, arguments);
      }
      return _addTask;
    }()
    /**
     * Processes the storage queue in order.
     */
  }, {
    key: "processQueue",
    value: function () {
      var _processQueue = _asyncToGenerator(function* () {
        if (!this.processing) {
          while (this.taskQueue.length > 0) {
            this.processing = true;
            var task = this.taskQueue.shift();
            yield task();
          }
          this.processing = false;
        }
      });
      function processQueue() {
        return _processQueue.apply(this, arguments);
      }
      return processQueue;
    }()
    /**
     * Returns a string key for the storage lookup of a tab.
     * @param {number} tabId
     * @returns {string}
     */
  }, {
    key: "delete",
    value:
    /**
     * Deletes a tab-state from session storage.
     * @param {number} tabId
     */
    function () {
      var _delete3 = _asyncToGenerator(function* (tabId) {
        yield this._addTask( /*#__PURE__*/_asyncToGenerator(function* () {
          try {
            yield (0, _wrapper.removeFromSessionStorage)(StorageInstance._getStorageKey(tabId));
          } catch (e) {
            console.error('Removal of tab state failed', e);
          }
        }));
      });
      function _delete(_x4) {
        return _delete3.apply(this, arguments);
      }
      return _delete;
    }()
    /**
     * Gets a serialized tab-state from session storage.
     * @param {number} tabId
     * @returns {Promise<string | undefined>}
     */
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(function* (tabId) {
        return this._addTask( /*#__PURE__*/_asyncToGenerator(function* () {
          try {
            return (0, _wrapper.getFromSessionStorage)(StorageInstance._getStorageKey(tabId));
          } catch (e) {
            console.error('Retrieval of tab state failed', e);
            return undefined;
          }
        }));
      });
      function get(_x5) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
    /**
     * @param {TabState} tabState
     * @returns {Promise<void>}
     */
  }, {
    key: "backup",
    value: function () {
      var _backup = _asyncToGenerator(function* (tabState) {
        yield this._addTask( /*#__PURE__*/_asyncToGenerator(function* () {
          try {
            yield (0, _wrapper.setToSessionStorage)(StorageInstance._getStorageKey(tabState.tabId), JSON.stringify(tabState));
          } catch (e) {
            console.error('Storage of tab state failed', e);
          }
        }));
      });
      function backup(_x6) {
        return _backup.apply(this, arguments);
      }
      return backup;
    }()
  }], [{
    key: "_getStorageKey",
    value: function _getStorageKey(tabId) {
      return "tabState-".concat(tabId);
    }
  }]);
  return StorageInstance;
}();
var Storage = new StorageInstance();

},{"../wrapper":99,"./ad-click-attribution-policy":51,"./tracker":62}],59:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/* This class contains information about what trackers and sites
 * are on a given tab:
 *  id: Chrome tab id
 *  url: url of the tab
 *  site: ref to a Site object
 *  trackers: {object} all trackers requested on page/tab (listed by company)
 *      is in this format:
 *      {
 *         '<companyName>': {
 *              parentCompany: ref to a Company object
 *              urls: all unique tracker urls we have seen for this company
 *              count: total number of requests to unique tracker urls for this company
 *          }
 *      }
 */

var Site = require('./site');
var _require = require('./tracker'),
  Tracker = _require.Tracker;
var HttpsRedirects = require('./https-redirects');
var Companies = require('../companies');
var webResourceKeyRegex = /.*\?key=(.*)/;
var _require2 = require('./ad-click-attribution-policy'),
  AdClickAttributionPolicy = _require2.AdClickAttributionPolicy;
var _require3 = require('./tab-state'),
  TabState = _require3.TabState;

/** @typedef {{tabId: number, url: string | undefined, requestId?: string, status: string | null | undefined}} TabData */
var Tab = /*#__PURE__*/function () {
  /**
   * @param {TabData|TabState} tabData
   */
  function Tab(tabData) {
    _classCallCheck(this, Tab);
    if (tabData instanceof TabState) {
      /** @type {TabState} */
      this._tabState = tabData;
    } else {
      /** @type {TabState} */
      this._tabState = new TabState(tabData);
    }
    this.site = new Site(this.url, this._tabState);
    this.httpsRedirects = new HttpsRedirects();
    this.webResourceAccess = [];
    this.surrogates = {};
  }

  /**
   * @param {number} tabId
   */
  _createClass(Tab, [{
    key: "referrer",
    get: function get() {
      return this._tabState.referrer;
    },
    set: function set(value) {
      this._tabState.setValue('referrer', value);
    }
  }, {
    key: "adClick",
    get: function get() {
      return this._tabState.adClick;
    },
    set: function set(value) {
      this._tabState.setValue('adClick', value);
    }
  }, {
    key: "disabledClickToLoadRuleActions",
    get: function get() {
      return this._tabState.disabledClickToLoadRuleActions;
    },
    set: function set(value) {
      this._tabState.setValue('disabledClickToLoadRuleActions', value);
    }
  }, {
    key: "dnrRuleIdsByDisabledClickToLoadRuleAction",
    get: function get() {
      return this._tabState.dnrRuleIdsByDisabledClickToLoadRuleAction;
    },
    set: function set(value) {
      this._tabState.setValue('dnrRuleIdsByDisabledClickToLoadRuleAction', value);
    }
  }, {
    key: "trackers",
    get: function get() {
      return this._tabState.trackers;
    },
    set: function set(value) {
      this._tabState.setValue('trackers', value);
    }
  }, {
    key: "url",
    get: function get() {
      return this._tabState.url;
    },
    set: function set(url) {
      this._tabState.setValue('url', url);
    }
  }, {
    key: "id",
    get: function get() {
      return this._tabState.tabId;
    },
    set: function set(tabId) {
      this._tabState.setValue('tabId', tabId);
    }
  }, {
    key: "upgradedHttps",
    get: function get() {
      return this._tabState.upgradedHttps;
    },
    set: function set(value) {
      this._tabState.setValue('upgradedHttps', value);
    }
  }, {
    key: "hasHttpsError",
    get: function get() {
      return this._tabState.hasHttpsError;
    },
    set: function set(value) {
      this._tabState.setValue('hasHttpsError', value);
    }
  }, {
    key: "mainFrameUpgraded",
    get: function get() {
      return this._tabState.mainFrameUpgraded;
    },
    set: function set(value) {
      this._tabState.setValue('mainFrameUpgraded', value);
    }
  }, {
    key: "urlParametersRemoved",
    get: function get() {
      return this._tabState.urlParametersRemoved;
    },
    set: function set(value) {
      this._tabState.setValue('urlParametersRemoved', value);
    }
  }, {
    key: "urlParametersRemovedUrl",
    get: function get() {
      return this._tabState.urlParametersRemovedUrl;
    },
    set: function set(value) {
      this._tabState.setValue('urlParametersRemovedUrl', value);
    }
  }, {
    key: "ampUrl",
    get: function get() {
      return this._tabState.ampUrl;
    },
    set: function set(url) {
      this._tabState.setValue('ampUrl', url);
    }
  }, {
    key: "cleanAmpUrl",
    get: function get() {
      return this._tabState.cleanAmpUrl;
    },
    set: function set(url) {
      this._tabState.setValue('cleanAmpUrl', url);
    }
  }, {
    key: "requestId",
    get: function get() {
      return this._tabState.requestId;
    }
  }, {
    key: "status",
    get: function get() {
      return this._tabState.status;
    },
    set: function set(value) {
      this._tabState.setValue('status', value);
    }
  }, {
    key: "statusCode",
    get: function get() {
      return this._tabState.statusCode;
    },
    set: function set(value) {
      this._tabState.setValue('statusCode', value);
    }
  }, {
    key: "ctlYouTube",
    get: function get() {
      return this._tabState.ctlYouTube;
    },
    set: function set(value) {
      this._tabState.setValue('ctlYouTube', value);
    }

    /**
     * If given a valid adClick redirect, set the adClick to the tab.
     * @param {string} requestURL
     */
  }, {
    key: "setAdClickIfValidRedirect",
    value: function setAdClickIfValidRedirect(requestURL) {
      var policy = this.getAdClickAttributionPolicy();
      var adClick = policy.createAdClick(requestURL, this);
      if (adClick) {
        this.adClick = adClick;
      }
    }

    /**
     * @returns {AdClickAttributionPolicy}
     */
  }, {
    key: "getAdClickAttributionPolicy",
    value: function getAdClickAttributionPolicy() {
      this._adClickAttributionPolicy = this._adClickAttributionPolicy || new AdClickAttributionPolicy();
      return this._adClickAttributionPolicy;
    }

    /**
     * Returns true if a resource should be permitted when the tab is in the adClick state.
     * @param {string} resourcePath
     * @returns {boolean}
     */
  }, {
    key: "allowAdAttribution",
    value: function allowAdAttribution(resourcePath) {
      if (!this.site.isFeatureEnabled('adClickAttribution') || !this.adClick || !this.adClick.allowAdAttribution(this)) return false;
      var policy = this.getAdClickAttributionPolicy();
      return policy.resourcePermitted(resourcePath);
    }
  }, {
    key: "updateSite",
    value: function updateSite(url) {
      if (this.site.url === url) return;
      this.url = url;
      this.site = new Site(url, this._tabState);
    }

    // Store all trackers for a given tab even if we don't block them.
    /**
     * @param t
     * @param {string} baseDomain
     * @param {string} url
     * @returns {Tracker}
     */
  }, {
    key: "addToTrackers",
    value: function addToTrackers(t, baseDomain, url) {
      var trackers = this.trackers;
      var tracker = this.trackers[t.tracker.owner.name];
      if (tracker) {
        tracker.addTrackerUrl(t, this.url || '', baseDomain, url);
      } else if (t.tracker) {
        var newTracker = new Tracker(t);
        newTracker.addTrackerUrl(t, this.url || '', baseDomain, url);
        this.trackers[t.tracker.owner.name] = newTracker;

        // first time we have seen this network tracker on the page
        if (t.tracker.owner.name !== 'unknown') Companies.countCompanyOnPage(t.tracker.owner);
      }
      // Set the trackers on the tab which will trigger a state update
      this.trackers = trackers;
      return this.trackers[t.tracker.owner.name];
    }

    /**
     * Adds an entry to the tab webResourceAccess list.
     * @param {string} resourceName URL to the web accessible resource
     * @returns {string} generated access key
     **/
  }, {
    key: "addWebResourceAccess",
    value: function addWebResourceAccess(resourceName) {
      // random 8-9 character key for web resource access
      var key = Math.floor(Math.random() * 10000000000).toString(16);
      this.webResourceAccess.push({
        key: key,
        resourceName: resourceName,
        time: Date.now(),
        wasAccessed: false
      });
      return key;
    }

    /**
     * Access to web accessible resources needs to have the correct key passed in the URL
     * and the requests needs to happen within 1 second since the generation of the key
     * in addWebResourceAccess
     * @param {string} resourceURL web accessible resource URL
     * @returns {boolean} is access to the resource allowed
     **/
  }, {
    key: "hasWebResourceAccess",
    value: function hasWebResourceAccess(resourceURL) {
      // no record of web resource access for this tab
      if (!this.webResourceAccess.length) {
        return false;
      }
      var keyMatches = webResourceKeyRegex.exec(resourceURL);
      if (!keyMatches) {
        return false;
      }
      var key = keyMatches[1];
      var hasAccess = this.webResourceAccess.some(function (resource) {
        if (resource.key === key && !resource.wasAccessed) {
          resource.wasAccessed = true;
          if (Date.now() - resource.time < 1000) {
            return true;
          }
        }
        return false;
      });
      return hasAccess;
    }

    /**
     * This method sets ampUrl. In cases where ampUrl is already set with an AMP url and the new url is
     * contained in the current ampUrl, we don't want to set ampUrl to the new url. This is because in some cases
     * simple amp urls (e.g. google.com/amp) will contain another amp url as the extacted url.
     *
     * @param {string} url - the url to set ampUrl to
     */
  }, {
    key: "setAmpUrl",
    value: function setAmpUrl(url) {
      if (this.ampUrl) {
        var ampUrl = new URL(this.ampUrl);
        var newUrl = new URL(url);
        if (ampUrl.hostname.includes('google') && ampUrl.pathname.includes(newUrl.hostname)) {
          return;
        }
      }
      this.ampUrl = url;
    }

    /**
     * Post a message to the devtools panel for this tab
     * @param {Object} devtools
     * @param {string} action
     * @param {Object} message
     */
  }, {
    key: "postDevtoolsMessage",
    value: function postDevtoolsMessage(devtools, action, message) {
      devtools.postMessage(this.id, action, message);
    }
  }], [{
    key: "restore",
    value: function () {
      var _restore = _asyncToGenerator(function* (tabId) {
        var state = yield TabState.restore(tabId);
        if (!state) {
          return null;
        }
        return new Tab(state);
      });
      function restore(_x) {
        return _restore.apply(this, arguments);
      }
      return restore;
    }()
  }]);
  return Tab;
}();
module.exports = Tab;

},{"../companies":64,"./ad-click-attribution-policy":51,"./https-redirects":53,"./site":56,"./tab-state":58,"./tracker":62}],60:[function(require,module,exports){
"use strict";

function TopBlocked() {
  this.data = [];
}
TopBlocked.prototype = {
  add: function add(element) {
    this.data.push(element);
  },
  getTop: function getTop(n, sortFunc) {
    this.sort(sortFunc);
    n = n || 10;
    return this.data.slice(0, n);
  },
  sort: function sort(sortFunc) {
    this.data.sort(sortFunc);
  },
  clear: function clear() {
    this.data = [];
  },
  setData: function setData(data) {
    this.data = data;
  }
};
module.exports = TopBlocked;

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackerStats = void 0;
var _zod = _interopRequireDefault(require("zod"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * A single place to collect information about the number of requests
 * we have blocked, grouped by the owner's display name.
 */
var TrackerStats = /*#__PURE__*/function () {
  function TrackerStats() {
    _classCallCheck(this, TrackerStats);
    _defineProperty(this, "maxAgeMs", 1000 * 60 * 60);
    _defineProperty(this, "entries", new Map());
    _defineProperty(this, "totalCount", 0);
  }
  _createClass(TrackerStats, [{
    key: "increment",
    value:
    /**
     * Given a key eg: 'displayName', store current timestamp +
     * increment the 'since-install-time' value
     *
     * @param {string} key
     * @param {number} [timestamp] - optional timestamp
     */
    function increment(key) {
      var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
      // ensure we always have an array for this incoming key
      var prev = this.entries.get(key) || [];

      // now add this entry to the end
      prev.push(timestamp);

      // re-store the array of timestamps
      this.entries.set(key, prev);

      // increment the total count
      this.totalCount += 1;
    }

    /**
     * Ensure we're not holding onto stale data.
     *
     * Note: entries are skipped at read-time anyway, but this ensures
     * that we don't maintain a growing list of timestamp entries over time.
     *
     * This may be called by an alarm or at any other period
     *
     * @param {number} [now] - the timestamp to compare entries against
     * @returns {this}
     */
  }, {
    key: "evictExpired",
    value: function evictExpired() {
      var _this = this;
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();
      var _iterator = _createForOfIteratorHelper(this.entries),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            key = _step$value[0],
            timestamps = _step$value[1];
          // note: there's an assumption here that this *won't* be a perf
          // bottleneck. `.filter(...)` is not always ideal since it allocates a new array
          // but in this instance we're not in a 'hot' path as pruning only happens
          // in response to things like timed-alarm.
          var filteredTimestamps = timestamps.filter(function (previousTimestamp) {
            var delta = now - previousTimestamp;
            return delta <= _this.maxAgeMs;
          });

          // evict the entry entirely if there are no valid timestamps
          if (filteredTimestamps.length === 0) {
            this.entries["delete"](key);
          } else {
            // otherwise just re-set this entry to have only valid ones.
            this.entries.set(key, filteredTimestamps);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return this;
    }

    /**
     * Produce a simplified 'sorted' view of the underlying data.
     *
     * We store data in the following format:
     *
     * {
     *     "Google": [1673438914778],
     *     "Facebook: [1673438914778, 1673438914778, 1673438914792]
     * }
     *
     * We have to keep track of those timestamps, but only internally. When a consumer
     * wants access to our data, we collapse it down into the following format:
     *
     * {
     *     results: { Facebook: 3, Google: 1 },
     *     overflow: 5
     * }
     *
     * Where 'overflow' represents the number of requests for companies
     * outside the `maxCount`.
     *
     * @param {number} [maxCount] - how many companies to display
     * @param {number} [now] - an optional timestamp, defaults to call-time
     * @returns {{
     *     results: { key: string, count: number }[],
     *     overflow: number
     * }}
     */
  }, {
    key: "sorted",
    value: function sorted() {
      var maxCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
      /** @type {{key: string, count: number}[]} */
      var stats = [];

      // For every entry, only count the ones within the last hour.
      var _iterator2 = _createForOfIteratorHelper(this.entries),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
            key = _step2$value[0],
            timestamps = _step2$value[1];
          var count = 0;
          var _iterator3 = _createForOfIteratorHelper(timestamps),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var timestamp = _step3.value;
              var delta = now - timestamp;
              if (delta <= this.maxAgeMs) {
                count += 1;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          if (count > 0) {
            stats.push({
              key: key,
              count: count
            });
          }
        }

        // sort them, so that the highest count's are first
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var sorted = stats.sort(function (a, b) {
        return b.count - a.count;
      });

      // now it's sorted, we need to partition the array based on the maxCount
      var results = sorted.slice(0, maxCount);

      // everything else will make up the 'overflow' count that can be used to
      // display a category like 'Other'
      var overflowItems = sorted.slice(maxCount);
      var overflow = overflowItems.reduce(function (sum, item) {
        return sum + item.count;
      }, 0);
      return {
        results: results,
        overflow: overflow
      };
    }

    /**
     * Allow our internal data to be 'set'.
     *
     * We are very strict about the incoming data here, mostly treating
     * it as untrusted.
     *
     * It should be in this format:
     *
     * {
     *     "totalCount": 12,
     *     "entries": {
     *         "Google": [1673438914778],
     *         "Facebook": [1673438914778, 1673438914778, 1673438914792]
     *     }
     * }
     *
     * This is normally produced by `.serialize()` on this instance (see below)
     *
     * @param {object} params
     * @param {number} params.totalCount
     * @param {Record<string, number[]>} params.entries
     * @throws
     */
  }, {
    key: "deserialize",
    value: function deserialize(params) {
      // define what shape incoming data must be in
      var storageSchema = _zod["default"].object({
        totalCount: _zod["default"].number(),
        entries: _zod["default"].record(_zod["default"].string(), _zod["default"].array(_zod["default"].number()))
      });

      // try to validate the data
      var result = storageSchema.safeParse(params);

      // if any errors occur, bail and don't use this data at all (start a fresh)
      if (!result.success) {
        console.warn('could not accept the incoming data because of schema errors', result.error.errors.length);
      } else {
        // but if we get here, we can use the data internally, we 'trust' it.
        this.totalCount = result.data.totalCount;
        this.entries = new Map(Object.entries(result.data.entries));
      }
    }

    /**
     * Produce a data format that can be stored and restored from.
     *
     * The data produced by this method will be stored and should be used
     * in calls to 'deserialize' (above)
     */
  }, {
    key: "serialize",
    value: function serialize() {
      return {
        entries: Object.fromEntries(this.entries),
        totalCount: this.totalCount
      };
    }
  }]);
  return TrackerStats;
}();
exports.TrackerStats = TrackerStats;

},{"zod":19}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tracker = void 0;
var _constants = _interopRequireDefault(require("../../../data/constants"));
var _privacyDashboardData = require("./privacy-dashboard-data");
var _tds = _interopRequireDefault(require("../storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Companies = require('../companies');

/**
 * @typedef {import('../trackers').ActionName} ActionName
 * @typedef {import('../trackers').TrackerData} TrackerData
 * @typedef {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').DetectedRequest} DetectedRequest
 * @typedef {DetectedRequest & { action: ActionName }} DetectedRequestWithAction
 */
var Tracker = /*#__PURE__*/function () {
  /**
   * @param {TrackerData | null} t
   */
  function Tracker(t) {
    var _this$parentCompany, _tdsStorage$tds$entit;
    _classCallCheck(this, Tracker);
    /** @type {Record<string, DetectedRequestWithAction>} */
    this.urls = {};
    this.count = 0; // request count
    // Used for class deserizalization
    if (!t) {
      return;
    }
    if (!t.tracker) {
      throw new Error('Tracker object required for Tracker constructor');
    }
    this.parentCompany = Companies.get(t.tracker.owner.ownedBy || t.tracker.owner.name);
    this.displayName = ((_this$parentCompany = this.parentCompany) === null || _this$parentCompany === void 0 ? void 0 : _this$parentCompany.displayName) || t.tracker.owner.displayName;
    this.prevalence = (_tdsStorage$tds$entit = _tds["default"].tds.entities[t.tracker.owner.name]) === null || _tdsStorage$tds$entit === void 0 ? void 0 : _tdsStorage$tds$entit.prevalence;
  }

  /**
   * A parent company may try to track you through many different entities.
   * We store a list of all unique urls here.
   * @param {TrackerData} t
   * @param {string} tabUrl
   * @param {string} baseDomain
   * @param {string} url
   */
  _createClass(Tracker, [{
    key: "addTrackerUrl",
    value: function addTrackerUrl(t, tabUrl, baseDomain, url) {
      var _t$tracker, _t$tracker$categories, _this$parentCompany2;
      // don't consider first-party requests at all
      if (t.sameBaseDomain) {
        return;
      }
      this.count += 1;

      // make a key from `fullTrackerDomain` + action to ensure we only deliver 1 entry per domain + status.
      var key = t.fullTrackerDomain + ':' + t.action;

      // return early if this combination exists.
      if (this.urls[key]) return;
      var state = (0, _privacyDashboardData.convertState)(t.action, t.sameEntity);

      // if we can't convert the state, do nothing.
      if (!state) return;

      // Choose the first tracker radar category that we accept
      var category = (_t$tracker = t.tracker) === null || _t$tracker === void 0 ? void 0 : (_t$tracker$categories = _t$tracker.categories) === null || _t$tracker$categories === void 0 ? void 0 : _t$tracker$categories.find(function (trackerRadarCategory) {
        return _constants["default"].displayCategories.includes(trackerRadarCategory);
      });

      /** @type {DetectedRequestWithAction} */
      var detectedRequest = {
        action: t.action,
        url: url,
        eTLDplus1: baseDomain,
        pageUrl: tabUrl,
        entityName: this.displayName,
        prevalence: this.prevalence,
        ownerName: (_this$parentCompany2 = this.parentCompany) === null || _this$parentCompany2 === void 0 ? void 0 : _this$parentCompany2.name,
        category: category,
        state: state
      };
      this.urls[key] = detectedRequest;
    }

    /**
     * @param {Tracker} data
     * @returns {Tracker}
     */
  }], [{
    key: "restore",
    value: function restore(data) {
      var tracker = new Tracker(null);
      for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
        tracker[key] = value;
      }
      return tracker;
    }
  }]);
  return Tracker;
}();
exports.Tracker = Tracker;

},{"../../../data/constants":38,"../companies":64,"../storage/tds":93,"./privacy-dashboard-data":55}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.displayClickToLoadPlaceholders = displayClickToLoadPlaceholders;
exports.getDefaultEnabledClickToLoadRuleActionsForTab = getDefaultEnabledClickToLoadRuleActionsForTab;
var _tds = _interopRequireDefault(require("./storage/tds"));
var _utils = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/**
 * Find the enabled Click to Load rule actions for the given tab.
 * Note: Take care to ensure wait for the extension configuration to be ready
 *       first.
 * @param {import('./classes/tab')} tab
 * @return {string[]}
 */
function getDefaultEnabledClickToLoadRuleActionsForTab(tab) {
  var _tab$site, _tdsStorage$config, _tdsStorage$config$fe, _tdsStorage$config$fe2;
  // Click to Load feature isn't supported or is disabled for the tab.
  if (!(tab !== null && tab !== void 0 && (_tab$site = tab.site) !== null && _tab$site !== void 0 && _tab$site.isFeatureEnabled('clickToLoad'))) {
    return [];
  }
  var clickToLoadSettings = _tds["default"] === null || _tds["default"] === void 0 ? void 0 : (_tdsStorage$config = _tds["default"].config) === null || _tdsStorage$config === void 0 ? void 0 : (_tdsStorage$config$fe = _tdsStorage$config.features) === null || _tdsStorage$config$fe === void 0 ? void 0 : (_tdsStorage$config$fe2 = _tdsStorage$config$fe.clickToLoad) === null || _tdsStorage$config$fe2 === void 0 ? void 0 : _tdsStorage$config$fe2.settings;

  // Click to Load configuration isn't ready yet.
  if (!clickToLoadSettings) {
    console.warn('Click to Load configuration not ready yet, skipped.');
    return [];
  }
  var enabledRuleActions = [];
  var parentEntity = tab.site.parentEntity;
  for (var _i = 0, _Object$entries = Object.entries(clickToLoadSettings); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      entity = _Object$entries$_i[0],
      _Object$entries$_i$ = _Object$entries$_i[1],
      ruleActions = _Object$entries$_i$.ruleActions,
      state = _Object$entries$_i$.state;
    // No rule actions, or entity is disabled.
    if (!ruleActions || ruleActions.length === 0 || state !== 'enabled') {
      continue;
    }

    // Enabled Click to Load entity is third-party for this tab, note its
    // rule actions.
    if (parentEntity !== entity) {
      enabledRuleActions.push.apply(enabledRuleActions, _toConsumableArray(ruleActions));
    }
  }
  return enabledRuleActions;
}

/**
 * Triggers a refresh of the Click to Load placeholders for the given tab.
 * @param {import('./classes/tab')} tab
 * @param {string} [ruleAction]
 *   If provided, only placeholders associated with the entity containing that
 *   rule action will be refreshed. By default, all placeholders will be
 *   refreshed.
 */
function displayClickToLoadPlaceholders(_x2, _x3) {
  return _displayClickToLoadPlaceholders.apply(this, arguments);
}
function _displayClickToLoadPlaceholders() {
  _displayClickToLoadPlaceholders = _asyncToGenerator(function* (tab, ruleAction) {
    var message = {
      type: 'update',
      feature: 'clickToLoad',
      messageType: 'displayClickToLoadPlaceholders',
      options: {}
    };
    if (typeof ruleAction === 'string') {
      message.options.ruleAction = ruleAction;
    }
    yield (0, _utils.sendTabMessage)(tab.id, message);
  });
  return _displayClickToLoadPlaceholders.apply(this, arguments);
}

},{"./storage/tds":93,"./utils":98}],64:[function(require,module,exports){
"use strict";

var TopBlocked = require('./classes/top-blocked');
var Company = require('./classes/company');
var browserWrapper = require('./wrapper');
var Companies = function () {
  var companyContainer = {};
  var topBlocked = new TopBlocked();
  var storageName = 'companyData';
  var totalPages = 0;
  var totalPagesWithTrackers = 0;
  var lastStatsResetDate = null;
  function sortByCount(a, b) {
    return companyContainer[b].count - companyContainer[a].count;
  }
  function sortByPages(a, b) {
    return companyContainer[b].pagesSeenOn - companyContainer[a].pagesSeenOn;
  }
  return {
    get: function get(name) {
      return companyContainer[name];
    },
    getTotalPages: function getTotalPages() {
      return totalPages;
    },
    add: function add(c) {
      if (!companyContainer[c.name]) {
        companyContainer[c.name] = new Company(c);
        topBlocked.add(c.name);
      }
      companyContainer[c.name].incrementCount();
      return companyContainer[c.name];
    },
    // This is used by tab.js to count only unique tracking networks on a tab
    countCompanyOnPage: function countCompanyOnPage(c) {
      if (!companyContainer[c.name]) {
        companyContainer[c.name] = new Company(c);
        topBlocked.add(c.name);
      }
      if (c.name !== 'unknown') companyContainer[c.name].incrementPagesSeenOn();
    },
    all: function all() {
      return Object.keys(companyContainer);
    },
    getTopBlocked: function getTopBlocked(n) {
      var topBlockedData = [];
      topBlocked.getTop(n, sortByCount).forEach(function (name) {
        var c = Companies.get(name);
        topBlockedData.push({
          name: c.name,
          count: c.count,
          displayName: c.displayName
        });
      });
      return topBlockedData;
    },
    getTopBlockedByPages: function getTopBlockedByPages(n) {
      var topBlockedData = [];
      topBlocked.getTop(n, sortByPages).forEach(function (name) {
        var c = Companies.get(name);
        topBlockedData.push({
          name: c.name,
          displayName: c.displayName,
          percent: Math.min(100, Math.round(c.pagesSeenOn / totalPages * 100))
        });
      });
      return {
        topBlocked: topBlockedData,
        totalPages: totalPages,
        pctPagesWithTrackers: Math.min(100, Math.round(totalPagesWithTrackers / totalPages * 100)),
        lastStatsResetDate: lastStatsResetDate
      };
    },
    setTotalPagesFromStorage: function setTotalPagesFromStorage(n) {
      if (n) totalPages = n;
    },
    setTotalPagesWithTrackersFromStorage: function setTotalPagesWithTrackersFromStorage(n) {
      if (n) totalPagesWithTrackers = n;
    },
    resetData: function resetData() {
      companyContainer = {};
      topBlocked.clear();
      totalPages = 0;
      totalPagesWithTrackers = 0;
      lastStatsResetDate = Date.now();
      Companies.syncToStorage();
      var resetDate = Companies.getLastResetDate();
      browserWrapper.notifyPopup({
        didResetTrackersData: resetDate
      });
    },
    getLastResetDate: function getLastResetDate() {
      return lastStatsResetDate;
    },
    incrementTotalPages: function incrementTotalPages() {
      totalPages += 1;
      Companies.syncToStorage();
    },
    incrementTotalPagesWithTrackers: function incrementTotalPagesWithTrackers() {
      totalPagesWithTrackers += 1;
      Companies.syncToStorage();
    },
    syncToStorage: function syncToStorage() {
      var toSync = {};
      toSync[storageName] = companyContainer;
      browserWrapper.syncToStorage(toSync);
      browserWrapper.syncToStorage({
        totalPages: totalPages
      });
      browserWrapper.syncToStorage({
        totalPagesWithTrackers: totalPagesWithTrackers
      });
      browserWrapper.syncToStorage({
        lastStatsResetDate: lastStatsResetDate
      });
    },
    sanitizeData: function sanitizeData(storageData) {
      if (storageData && Object.hasOwnProperty.call(storageData, 'twitter')) {
        delete storageData.twitter;
      }
      return storageData;
    },
    buildFromStorage: function buildFromStorage() {
      browserWrapper.getFromStorage(storageName).then(function (storageData) {
        // uncomment for testing
        // storageData.twitter = {count: 10, name: 'twitter', pagesSeenOn: 10}
        storageData = Companies.sanitizeData(storageData);
        for (var company in storageData) {
          var newCompany = Companies.add(storageData[company]);
          newCompany.set('count', storageData[company].count || 0);
          newCompany.set('pagesSeenOn', storageData[company].pagesSeenOn || 0);
        }
      });
      browserWrapper.getFromStorage('totalPages').then(function (n) {
        if (n) totalPages = n;
      });
      browserWrapper.getFromStorage('totalPagesWithTrackers').then(function (n) {
        if (n) totalPagesWithTrackers = n;
      });
      browserWrapper.getFromStorage('lastStatsResetDate').then(function (d) {
        if (d) {
          lastStatsResetDate = d;
        } else {
          // if 'lastStatsResetDate' not found, reset all data
          // https://app.asana.com/0/0/460622849089890/f
          Companies.resetData();
        }
      });
    }
  };
}();
module.exports = Companies;

},{"./classes/company":52,"./classes/top-blocked":60,"./wrapper":99}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function init() {
  _webextensionPolyfill["default"].webRequest.onBeforeRequest.addListener(function (details) {
    try {
      // parse requestBody as an ASCII string
      var report = String.fromCharCode.apply(null, new Uint8Array(details.requestBody.raw[0].bytes));
      if (report.indexOf('moz-extension://') !== -1) {
        return {
          cancel: true
        };
      }
    } catch (e) {
      console.warn('Unable to parse CSP report contents', details.url);
    }
  }, {
    urls: ['<all_urls>'],
    types: ['csp_report']
  }, ['blocking', 'requestBody']);
}

},{"webextension-polyfill":11}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.isActive = isActive;
exports.postMessage = postMessage;
exports.serializeTab = serializeTab;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _tds = _interopRequireDefault(require("./storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var tldts = require('tldts');
var tabManager = require('./tab-manager');
var trackers = require('./trackers');
var _require = require('./utils'),
  removeBroken = _require.removeBroken;

// Note: It is not necessary to use session storage to store the tabId -> port
//       mapping for MV3 compatibility. That is because when the background
//       ServiceWoker becomes inactive, any open connections will be closed and
//       the devtools pages will reopen their connections. At that point, the
//       background ServiceWorker will become active again and the onConnect
//       event will fire again.
var ports = new Map();
function init() {
  _webextensionPolyfill["default"].runtime.onConnect.addListener(connected);
}

/**
 * Serialize a subset of the tab object to be sent to the panel
 * @param {Object} tab
 */
function serializeTab(tab) {
  if (tab.site) {
    return {
      site: {
        allowlisted: tab.site.allowlisted,
        isBroken: tab.site.isBroken,
        enabledFeatures: tab.site.enabledFeatures || []
      }
    };
  }
  return {};
}
function connected(port) {
  if (port.name !== 'devtools') {
    return;
  }
  var tabId = -1;
  port.onMessage.addListener(function (m) {
    if (m.action === 'setTab') {
      tabId = m.tabId;
      ports.set(tabId, port);
      var tab = tabManager.get({
        tabId: tabId
      });
      postMessage(tabId, 'tabChange', serializeTab(tab));
    } else if (m.action === 'I' || m.action === 'B') {
      var requestData = m.requestData,
        siteUrl = m.siteUrl,
        tracker = m.tracker;
      var matchedTracker = trackers.getTrackerData(requestData.url, siteUrl, requestData);
      if (!matchedTracker || !matchedTracker.tracker) {
        return;
      }
      if (tracker.matchedRule && matchedTracker.tracker) {
        // find the rule for this url
        var ruleIndex = matchedTracker.tracker.rules.findIndex(function (r) {
          var _r$rule;
          return ((_r$rule = r.rule) === null || _r$rule === void 0 ? void 0 : _r$rule.toString()) === tracker.matchedRule;
        });
        var rule = matchedTracker.tracker.rules[ruleIndex];
        var parsedHost = tldts.parse(siteUrl);
        if (!parsedHost.domain || !parsedHost.hostname) {
          return;
        }
        if (!rule.exceptions) {
          rule.exceptions = {};
        }
        if (!rule.exceptions.domains) {
          rule.exceptions.domains = [];
        }
        if (m.action === 'B' && matchedTracker.action === 'redirect') {
          matchedTracker.tracker.rules.splice(ruleIndex, 1);
        } else if (m.action === 'I') {
          rule.exceptions.domains.push(parsedHost.domain);
          if (rule.exceptions.types && !rule.exceptions.types.includes(requestData.type)) {
            rule.exceptions.types.push(requestData.type);
          }
        } else {
          var index = rule.exceptions.domains.indexOf(parsedHost.domain);
          if (index === -1) {
            index = rule.exceptions.domains.indexOf(parsedHost.hostname);
          }
          rule.exceptions.domains.splice(index, 1);
        }
        console.log('add exception for ', matchedTracker, rule);
      } else {
        matchedTracker.tracker["default"] = m.action === 'I' ? 'ignore' : 'block';
      }
    } else if (m.action === 'toggleProtection') {
      var _tab$site;
      var _tab = tabManager.get({
        tabId: m.tabId
      });
      if ((_tab$site = _tab.site) !== null && _tab$site !== void 0 && _tab$site.isBroken && _tab.url) {
        removeBroken(_tab.site.domain);
        removeBroken(new URL(_tab.url).hostname);
      } else {
        tabManager.setList({
          list: 'allowlisted',
          domain: _tab.site.domain,
          value: !_tab.site.allowlisted
        });
      }
      postMessage(tabId, 'tabChange', serializeTab(_tab));
    } else if (m.action === 'toggletrackerAllowlist') {
      if (_tds["default"].config.features.trackerAllowlist.state === 'enabled') {
        _tds["default"].config.features.trackerAllowlist.state = 'disabled';
      } else {
        _tds["default"].config.features.trackerAllowlist.state = 'enabled';
      }
    } else if (m.action.startsWith('toggle')) {
      var _tab2$site;
      var feature = m.action.slice(6);
      var _tab2 = tabManager.get({
        tabId: m.tabId
      });
      var enabled = (_tab2$site = _tab2.site) === null || _tab2$site === void 0 ? void 0 : _tab2$site.enabledFeatures.includes(feature);
      var excludedSites = _tds["default"].config.features[feature].exceptions;
      var tabDomain = tldts.getDomain(_tab2.site.domain);
      if (enabled) {
        excludedSites.push({
          domain: tabDomain,
          reason: 'Manually disabled'
        });
      } else {
        excludedSites.splice(excludedSites.findIndex(function (_ref) {
          var domain = _ref.domain;
          return domain === tabDomain;
        }), 1);
      }
    }
  });
  port.onDisconnect.addListener(function () {
    if (tabId !== -1) {
      ports["delete"](tabId);
    }
  });
}
function postMessage(tabId, action, message) {
  if (ports.has(tabId)) {
    ports.get(tabId).postMessage(JSON.stringify({
      tabId: tabId,
      action: action,
      message: message
    }));
  }
}
function isActive(tabId) {
  return ports.has(tabId);
}

},{"./storage/tds":93,"./tab-manager":94,"./trackers":96,"./utils":98,"tldts":10,"webextension-polyfill":11}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearClickToLoadDnrRulesForTab = clearClickToLoadDnrRulesForTab;
exports.ensureClickToLoadRuleActionDisabled = ensureClickToLoadRuleActionDisabled;
exports.restoreDefaultClickToLoadRuleActions = restoreDefaultClickToLoadRuleActions;
var _clickToLoad = require("./click-to-load");
var _dnrSessionRuleId = require("./dnr-session-rule-id");
var _settings = _interopRequireDefault(require("./settings"));
var _tds = _interopRequireDefault(require("./storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Generates the declarativeNetRequest allowing rules required to disable the
 * specified Click to Load rule action for the given tab. If the tab already has
 * the required declarativeNetRequest allowing rules, none are returned. If
 * declarativeNetRequest rules are returned, the tab's rule lookup is also
 * mutated to note the new rule IDs as a side effect.
 * @param {string} ruleAction
 * @param {import('./classes/tab')} tab
 * @return {Promise<import('@duckduckgo/ddg2dnr/lib/utils.js').DNRRule[]>}
 */
function generateDnrAllowingRules(_x, _x2) {
  return _generateDnrAllowingRules.apply(this, arguments);
}
/**
 * Ensure the correct declarativeNetRequest allowing session rules are added so
 * that the default Click to Load rule actions are enabled/disabled for the tab.
 *
 * 1. The blocking declarativeNetRequest rules for Click to Load are added with
 *    the rules generated for the tracker block list (tds.json). Therefore, to
 *    start with all Click to Load rule actions are enabled.
 * 2. Session allowing declarativeNetRequest rules are added to disable Click to
 *    Load rule actions as necessary for tabs. That happens on both navigation
 *    (with this function) and when the user clicks to load content
 *    (@see {ensureClickToLoadRuleActionDisabled}).
 * 3. Finally, all of session allowing declarativeNetRequest rules are removed
 *    for a tab when it is closed (@see clearClickToLoadDnrRulesForTab).
 *
 * Factors that determine which Click to Load rule actions should be enabled for
 * a tab include the tab's origin, the extension configuration and the user's
 * list of allowlisted domains.
 * @param {import('./classes/tab')} tab
 * @return {Promise}
 */
function _generateDnrAllowingRules() {
  _generateDnrAllowingRules = _asyncToGenerator(function* (tab, ruleAction) {
    // The necessary declarativeNetRequest allowing rules already exist for this
    // tab, nothing to do.
    var existingRuleIds = tab.dnrRuleIdsByDisabledClickToLoadRuleAction[ruleAction];
    if (existingRuleIds && existingRuleIds.length > 0) {
      return [];
    }

    // Load the Click to Load declarativeNetRequest allowing rule lookup from
    // the settings.
    yield _settings["default"].ready();
    var allowingDnrRulesByClickToLoadRuleAction = _settings["default"].getSetting('allowingDnrRulesByClickToLoadRuleAction');
    if (!allowingDnrRulesByClickToLoadRuleAction) {
      console.warn('Failed to load Click to Load allowing rules.');
      return [];
    }

    // Find the correct declarativeNetRequest allowing rules for this Click to
    // Load rule action.
    var allowingRules = allowingDnrRulesByClickToLoadRuleAction[ruleAction];
    if (!allowingRules) {
      console.warn("No Click to Load allowing rules for action ".concat(ruleAction, "."));
      return [];
    }

    // Make a copy of those declarativeNetRequest rules and assign IDs and
    // tab ID matching rule conditions.
    var ruleIds = [];
    allowingRules = JSON.parse(JSON.stringify(allowingRules));
    var _iterator = _createForOfIteratorHelper(allowingRules),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rule = _step.value;
        // Assign the rule ID.
        var ruleId = (0, _dnrSessionRuleId.getNextSessionRuleId)();
        if (typeof ruleId !== 'number') {
          // Not much that can be done if fetching the rule ID failed. Also,
          // no need to log a warning here as getNextSessionRuleId will have
          // done that already.
          continue;
        }
        rule.id = ruleId;
        ruleIds.push(ruleId);

        // Assign the tab ID condition.
        rule.condition.tabIds = [tab.id];
      }

      // Save the rule IDs on the Tab Object, so that the tab's rules can be
      // removed/updated as necessary later.
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (ruleIds.length > 0) {
      tab.dnrRuleIdsByDisabledClickToLoadRuleAction[ruleAction] = ruleIds;
    }
    return allowingRules;
  });
  return _generateDnrAllowingRules.apply(this, arguments);
}
function restoreDefaultClickToLoadRuleActions(_x3) {
  return _restoreDefaultClickToLoadRuleActions.apply(this, arguments);
}
/**
 * Ensure the necessary declarativeNetRequest allowing rules are added to
 * disable the given Click to Load rule action for the tab.
 * @param {string} ruleAction
 * @param {import('./classes/tab')} tab
 * @return {Promise}
 */
function _restoreDefaultClickToLoadRuleActions() {
  _restoreDefaultClickToLoadRuleActions = _asyncToGenerator(function* (tab) {
    var addRules = [];
    var removeRuleIds = [];
    yield _settings["default"].ready();
    var allowingDnrRulesByClickToLoadRuleAction = _settings["default"].getSetting('allowingDnrRulesByClickToLoadRuleAction');
    if (!allowingDnrRulesByClickToLoadRuleAction) {
      console.warn('Click to Load DNR rules are not known yet, skipping.');
      return;
    }

    // Assume all Click to Load rule actions should be disabled initially.
    var disabledRuleActions = new Set(Object.keys(allowingDnrRulesByClickToLoadRuleAction));

    // If the Click to Load feature is supported and enabled for this tab, see
    // which rule actions shouldn't be disabled.
    yield _tds["default"].ready('config');
    var _iterator2 = _createForOfIteratorHelper((0, _clickToLoad.getDefaultEnabledClickToLoadRuleActionsForTab)(tab)),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var ruleAction = _step2.value;
        disabledRuleActions["delete"](ruleAction);
      }

      // Tab was cleared by the time the extension configuration was read.
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (!tab) {
      return;
    }

    // Check which Click to Load rule actions are already disabled for the tab.
    for (var _i = 0, _Object$keys = Object.keys(tab.dnrRuleIdsByDisabledClickToLoadRuleAction); _i < _Object$keys.length; _i++) {
      var disabledRuleAction = _Object$keys[_i];
      if (disabledRuleActions.has(disabledRuleAction)) {
        // Existing declarativeNetRequest rules can be reused, since this
        // Click to Load rule action should still be still be disabled.
        disabledRuleActions["delete"](disabledRuleAction);
      } else {
        // Existing declarativeNetRequest rules should be cleared.
        var _iterator3 = _createForOfIteratorHelper(tab.dnrRuleIdsByDisabledClickToLoadRuleAction[disabledRuleAction]),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var ruleId = _step3.value;
            removeRuleIds.push(ruleId);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        delete tab.dnrRuleIdsByDisabledClickToLoadRuleAction[disabledRuleAction];
      }
    }

    // Generate any missing declarativeNetRequest allowing rules needed to
    // disable Click to Load rule actions for the tab.
    // Note: This also updates the dnrRuleIdsByDisabledClickToLoadRuleAction
    //       lookup for the tab.
    var _iterator4 = _createForOfIteratorHelper(disabledRuleActions),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _disabledRuleAction = _step4.value;
        addRules.push.apply(addRules, _toConsumableArray(yield generateDnrAllowingRules(tab, _disabledRuleAction)));
      }

      // Notes:
      //  - The allowing declarativeNetRequest rule IDs for the tab are noted in
      //    the Tab Object before the rules are added. If there is a problem
      //    adding the rules, it will result in an inconsistent state.
      //  - There is a race condition between the declarativeNetRequest rules
      //    being added for a tab, and the (potentially blocked) requests from
      //    being made. This is made worse since some asynchronous operations are
      //    required (e.g. checking the extension configuration) to know which
      //    rules should be added/removed. It is possible that sometimes the
      //    blocking/allowing action will be incorrect if the request happens more
      //    quickly than the ruleset can be updated.
      //  - A future optimisation could be to add the allowing
      //    declarativeNetRequest rules for disabled Click to Load rule actions
      //    once for all tabs. But note that since there is already an
      //    optimisation to avoid removing+re-adding rules unnecessarily on
      //    navigation, it might not be worth the added code complexity.

      // Update the declarativeNetRequest session rules for the tab.
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    if (addRules.length > 0 || removeRuleIds.length > 0) {
      return yield chrome.declarativeNetRequest.updateSessionRules({
        addRules: addRules,
        removeRuleIds: removeRuleIds
      });
    }
  });
  return _restoreDefaultClickToLoadRuleActions.apply(this, arguments);
}
function ensureClickToLoadRuleActionDisabled(_x4, _x5) {
  return _ensureClickToLoadRuleActionDisabled.apply(this, arguments);
}
/**
 * Removes all Click to Load session declarativeNetRequest rules associated with
 * the given tab.
 * @param {import('./classes/tab')} tab
 * @return {Promise}
 */
function _ensureClickToLoadRuleActionDisabled() {
  _ensureClickToLoadRuleActionDisabled = _asyncToGenerator(function* (ruleAction, tab) {
    var addRules = yield generateDnrAllowingRules(tab, ruleAction);
    if (addRules.length > 0) {
      return yield chrome.declarativeNetRequest.updateSessionRules({
        addRules: addRules
      });
    }
  });
  return _ensureClickToLoadRuleActionDisabled.apply(this, arguments);
}
function clearClickToLoadDnrRulesForTab(_x6) {
  return _clearClickToLoadDnrRulesForTab.apply(this, arguments);
}
function _clearClickToLoadDnrRulesForTab() {
  _clearClickToLoadDnrRulesForTab = _asyncToGenerator(function* (tab) {
    var _Array$prototype;
    var removeRuleIds = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, _toConsumableArray(Object.values(tab.dnrRuleIdsByDisabledClickToLoadRuleAction)));
    if (removeRuleIds.length > 0) {
      return yield chrome.declarativeNetRequest.updateSessionRules({
        removeRuleIds: removeRuleIds
      });
    }
  });
  return _clearClickToLoadDnrRulesForTab.apply(this, arguments);
}

},{"./click-to-load":63,"./dnr-session-rule-id":70,"./settings":90,"./storage/tds":93}],68:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SETTING_PREFIX = void 0;
exports.onConfigUpdate = onConfigUpdate;
exports.ruleIdRangeByConfigName = void 0;
exports.updateCombinedConfigBlocklistRules = updateCombinedConfigBlocklistRules;
exports.updateExtensionConfigRules = updateExtensionConfigRules;
var browserWrapper = _interopRequireWildcard(require("./wrapper"));
var _settings = _interopRequireDefault(require("./settings"));
var _tds = _interopRequireDefault(require("./storage/tds"));
var _trackers = _interopRequireDefault(require("./trackers"));
var startup = _interopRequireWildcard(require("./startup"));
var _utils = require("./utils");
var _dnrServiceWorkerInitiated = require("./dnr-service-worker-initiated");
var _dnrUserAllowlist = require("./dnr-user-allowlist");
var _dnrUtils = require("./dnr-utils");
var _extensionConfiguration = require("@duckduckgo/ddg2dnr/lib/extensionConfiguration");
var _tds2 = require("@duckduckgo/ddg2dnr/lib/tds");
var _utils2 = require("@duckduckgo/ddg2dnr/lib/utils");
var _combined = require("@duckduckgo/ddg2dnr/lib/combined");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var SETTING_PREFIX = 'declarative_net_request-';

// Allocate blocks of rule IDs for the different configurations. That way, the
// rules associated with a configuration can be safely cleared without the risk
// of removing rules associated with different configurations.
exports.SETTING_PREFIX = SETTING_PREFIX;
var ruleIdRangeByConfigName = {
  tds: [1, 10000],
  config: [10001, 20000],
  _RESERVED: [20001, 21000],
  combined: [21001, 31000]
};

/**
 * A dummy etag rule is saved with the declarativeNetRequest rules generated for
 * each configuration. That way, a consistent extension state (between tds
 * configurations, extension settings and declarativeNetRequest rules) can be
 * ensured.
 * @param {number} id
 * @param {string} etag
 * @returns {import('@duckduckgo/ddg2dnr/lib/utils.js').DNRRule}
 */
exports.ruleIdRangeByConfigName = ruleIdRangeByConfigName;
function generateEtagRule(id, etag) {
  return (0, _utils2.generateDNRRule)({
    id: id,
    priority: 1,
    actionType: 'allow',
    urlFilter: etag,
    requestDomains: ['etag.invalid']
  });
}

/**
 * Check if the declarativeNetRequest rules for a configuration need to be
 * updated. Returns true if so, false if they are already up to date.
 * @param {string} configName
 * @param {Object} expectedState
 * @returns {Promise<boolean>}
 */
function configRulesNeedUpdate(_x, _x2) {
  return _configRulesNeedUpdate.apply(this, arguments);
}
/**
 * Utility function that takes the extension config, and returns a minimal
 * config Object with disabled/unsupported features + unnecessary metadata
 * removed.
 * Note: Does not mutate the original config Object, but the returned config is
 *       equally not safe to mutate as it shares some Object references.
 * @param {Object} config
 * @returns {Object}
 */
function _configRulesNeedUpdate() {
  _configRulesNeedUpdate = _asyncToGenerator(function* (configName, expectedState) {
    var settingName = SETTING_PREFIX + configName;
    yield _settings["default"].ready();
    var settingValue = _settings["default"].getSetting(settingName);

    // No setting saved for the configuration yet, this is likely the first time
    // it has been updated - rules definitely need to be updated.
    if (!settingValue) {
      return true;
    }

    // To be sure the rules are up to date, there must be an expected etag.
    if (!expectedState.etag) {
      return true;
    }

    // If any of the setting values aren't as expected, the rules could be out
    // of date.
    for (var _i2 = 0, _Object$entries = Object.entries(expectedState); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
      if (settingValue[key] !== value) {
        return true;
      }
    }

    // Find the etag rule for this configuration.
    var _ruleIdRangeByConfigN = _slicedToArray(ruleIdRangeByConfigName[configName], 1),
      etagRuleId = _ruleIdRangeByConfigN[0];
    var existingEtagRule = yield (0, _dnrUtils.findExistingDynamicRule)(etagRuleId);

    // If none exists, the rules definitely need to be updated.
    if (!existingEtagRule) {
      return true;
    }

    // Otherwise, the rules only need be updated if the etags no longer match.
    return existingEtagRule.condition.urlFilter !== expectedState.etag;
  });
  return _configRulesNeedUpdate.apply(this, arguments);
}
function minimalConfig(_ref) {
  var unprotectedTemporary = _ref.unprotectedTemporary,
    features = _ref.features;
  var result = {
    features: {},
    unprotectedTemporary: unprotectedTemporary
  };
  for (var _i = 0, _Object$keys = Object.keys(features); _i < _Object$keys.length; _i++) {
    var featureName = _Object$keys[_i];
    if ((0, _utils.isFeatureEnabled)(featureName)) {
      result.features[featureName] = features[featureName];
    }
  }
  return result;
}

/**
 * Update the declarativeNetRequest rules and corresponding state in settings
 * for a configuration.
 * @param {string} configName
 * @param {Object} latestState
 * @param {import('@duckduckgo/ddg2dnr/lib/utils.js').DNRRule[]} rules
 * @param {Object} matchDetailsByRuleId
 * @returns {Promise<>}
 */
function updateConfigRules(_x3, _x4, _x5, _x6) {
  return _updateConfigRules.apply(this, arguments);
}
/**
 * Utility function to regenerate the declarativeNetRequest rules for the
 * extension configuration (extension-config.json). The configuration's value
 * and etag can optionally be passed in (e.g. when the configuration has just
 * been updated), but will be read from settings storage otherwise.
 * @param {string?} etag
 * @param {object?} configValue
 * @returns {Promise<>}
 */
function _updateConfigRules() {
  _updateConfigRules = _asyncToGenerator(function* (configName, latestState, rules, matchDetailsByRuleId) {
    var allowingRulesByClickToLoadAction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    var _ruleIdRangeByConfigN2 = _slicedToArray(ruleIdRangeByConfigName[configName], 2),
      ruleIdStart = _ruleIdRangeByConfigN2[0],
      ruleIdEnd = _ruleIdRangeByConfigN2[1];
    var etagRuleId = ruleIdStart;
    var maxNumberOfRules = ruleIdEnd - ruleIdStart;
    var etag = latestState.etag;
    if (!rules) {
      console.error('No declarativeNetRequest rules generated for configuration: ', configName, '(Etag: ', etag, ')');
      return;
    }

    // Add the new etag rule.
    rules.push(generateEtagRule(etagRuleId, etag));
    if (rules.length > maxNumberOfRules) {
      console.error('Too many declarativeNetRequest rules generated for configuration: ', configName, '(Etag: ', etag, ', Rules generated: ', rules.length, ')');
      return;
    }

    // Ensure any existing rules for the configuration are removed.
    var removeRuleIds = [];
    for (var i = ruleIdStart; i <= ruleIdEnd; i++) {
      removeRuleIds.push(i);
    }

    // Install the updated rules.
    yield chrome.declarativeNetRequest.updateDynamicRules({
      removeRuleIds: removeRuleIds,
      addRules: rules
    });

    // Then update the setting entry.
    var settingName = SETTING_PREFIX + configName;
    var settingValue = {
      matchDetailsByRuleId: matchDetailsByRuleId
    };
    for (var _i3 = 0, _Object$keys2 = Object.keys(latestState); _i3 < _Object$keys2.length; _i3++) {
      var key = _Object$keys2[_i3];
      settingValue[key] = latestState[key];
    }
    yield _settings["default"].ready();
    if (Object.keys(allowingRulesByClickToLoadAction).length) {
      _settings["default"].updateSetting('allowingDnrRulesByClickToLoadRuleAction', allowingRulesByClickToLoadAction);
    }
    _settings["default"].updateSetting(settingName, settingValue);
  });
  return _updateConfigRules.apply(this, arguments);
}
function updateExtensionConfigRules() {
  return _updateExtensionConfigRules.apply(this, arguments);
}
function _updateExtensionConfigRules() {
  _updateExtensionConfigRules = _asyncToGenerator(function* () {
    var etag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var configValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var extensionVersion = browserWrapper.getExtensionVersion();
    var denylistedDomains = yield (0, _dnrUserAllowlist.getDenylistedDomains)();
    var latestState = {
      extensionVersion: extensionVersion,
      denylistedDomains: denylistedDomains.join(),
      etag: etag
    };
    if (!configValue) {
      yield _tds["default"].ready('config');
      configValue = _tds["default"].config;
    }
    if (!etag) {
      var settingName = SETTING_PREFIX + 'config';
      yield _settings["default"].ready();
      yield _tds["default"].ready('config');
      var settingValue = _settings["default"].getSetting(settingName);
      if (!(settingValue !== null && settingValue !== void 0 && settingValue.etag)) {
        // Should not be possible, but if the etag is unknown at this point
        // there's not much that can be done.
        return;
      }
      latestState.etag = settingValue.etag;
    }
    if (!(yield configRulesNeedUpdate('config', latestState))) {
      return;
    }
    var _ruleIdRangeByConfigN3 = _slicedToArray(ruleIdRangeByConfigName.config, 1),
      ruleIdStart = _ruleIdRangeByConfigN3[0];
    var _yield$generateExtens = yield (0, _extensionConfiguration.generateExtensionConfigurationRuleset)(minimalConfig(configValue), denylistedDomains, chrome.declarativeNetRequest.isRegexSupported, ruleIdStart + 1),
      ruleset = _yield$generateExtens.ruleset,
      matchDetailsByRuleId = _yield$generateExtens.matchDetailsByRuleId;
    yield updateConfigRules('config', latestState, ruleset, matchDetailsByRuleId);
  });
  return _updateExtensionConfigRules.apply(this, arguments);
}
function updateCombinedConfigBlocklistRules() {
  return _updateCombinedConfigBlocklistRules.apply(this, arguments);
}
function _updateCombinedConfigBlocklistRules() {
  _updateCombinedConfigBlocklistRules = _asyncToGenerator(function* () {
    var extensionVersion = browserWrapper.getExtensionVersion();
    var denylistedDomains = yield (0, _dnrUserAllowlist.getDenylistedDomains)();
    var tdsEtag = _settings["default"].getSetting('tds-etag');
    var combinedState = {
      etag: "".concat(_settings["default"].getSetting('config-etag'), "-").concat(tdsEtag),
      denylistedDomains: denylistedDomains.join(),
      extensionVersion: extensionVersion
    };
    // require a blocklist before generating rules - config is optional
    if (tdsEtag && (yield configRulesNeedUpdate('combined', combinedState))) {
      var _generateCombinedConf = (0, _combined.generateCombinedConfigBlocklistRuleset)(_tds["default"].tds, minimalConfig(_tds["default"].config), denylistedDomains, ruleIdRangeByConfigName.combined[0] + 1),
        ruleset = _generateCombinedConf.ruleset,
        matchDetailsByRuleId = _generateCombinedConf.matchDetailsByRuleId;
      yield updateConfigRules('combined', combinedState, ruleset, matchDetailsByRuleId);
    }
  });
  return _updateCombinedConfigBlocklistRules.apply(this, arguments);
}
var ruleUpdateLock = Promise.resolve();
/**
 * tdsStorage.onUpdate listener which is called when the configurations are
 * updated and when the background ServiceWorker is restarted.
 * Note: Only exported for use by unit tests, do not call manually.
 * @param {'config'|'tds'} configName
 * @param {string} etag
 * @param {object} configValue
 * @returns {Promise}
 */
function onConfigUpdate(_x7, _x8, _x9) {
  return _onConfigUpdate.apply(this, arguments);
}
function _onConfigUpdate() {
  _onConfigUpdate = _asyncToGenerator(function* (configName, etag, configValue) {
    var extensionVersion = browserWrapper.getExtensionVersion();
    // Run an async lock on all blocklist updates so the latest update is always processed last
    ruleUpdateLock = ruleUpdateLock.then( /*#__PURE__*/_asyncToGenerator(function* () {
      // TDS (aka the block list).
      if (configName === 'tds') {
        var _ruleIdRangeByConfigN4 = _slicedToArray(ruleIdRangeByConfigName[configName], 1),
          ruleIdStart = _ruleIdRangeByConfigN4[0];
        var latestState = {
          etag: etag,
          extensionVersion: extensionVersion
        };
        if (!(yield configRulesNeedUpdate(configName, latestState))) {
          return;
        }
        yield startup.ready();
        // @ts-ignore: Once startup.ready() has finished, surrogateList will be
        //             assigned.
        var supportedSurrogates = new Set(Object.keys(_trackers["default"].surrogateList));
        var _yield$generateTdsRul = yield (0, _tds2.generateTdsRuleset)(configValue, supportedSurrogates, '/web_accessible_resources/', chrome.declarativeNetRequest.isRegexSupported, ruleIdStart + 1),
          ruleset = _yield$generateTdsRul.ruleset,
          matchDetailsByRuleId = _yield$generateTdsRul.matchDetailsByRuleId,
          allowingRulesByClickToLoadAction = _yield$generateTdsRul.allowingRulesByClickToLoadAction;
        yield updateConfigRules(configName, latestState, ruleset, matchDetailsByRuleId, allowingRulesByClickToLoadAction);
        // Extension configuration.
      } else if (configName === 'config') {
        yield updateExtensionConfigRules(etag, configValue);
        yield (0, _dnrServiceWorkerInitiated.ensureServiceWorkerInitiatedRequestExceptions)(configValue);
      }
      // combined rules (cookie blocking)
      yield updateCombinedConfigBlocklistRules();
    }));
    yield ruleUpdateLock;
  });
  return _onConfigUpdate.apply(this, arguments);
}
if (browserWrapper.getManifestVersion() === 3) {
  _tds["default"].onUpdate('config', onConfigUpdate);
  _tds["default"].onUpdate('tds', onConfigUpdate);
}

},{"./dnr-service-worker-initiated":69,"./dnr-user-allowlist":72,"./dnr-utils":73,"./settings":90,"./startup":91,"./storage/tds":93,"./trackers":96,"./utils":98,"./wrapper":99,"@duckduckgo/ddg2dnr/lib/combined":23,"@duckduckgo/ddg2dnr/lib/extensionConfiguration":25,"@duckduckgo/ddg2dnr/lib/tds":29,"@duckduckgo/ddg2dnr/lib/utils":33}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureServiceWorkerInitiatedRequestExceptions = ensureServiceWorkerInitiatedRequestExceptions;
var _dnrUtils = require("./dnr-utils");
var _rulePriorities = require("@duckduckgo/ddg2dnr/lib/rulePriorities");
var _utils = require("@duckduckgo/ddg2dnr/lib/utils");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Ensure that the allowing rule for ServiceWorker initiated requests is
 * enabled. Since the rule needs to be restricted to matching requests not
 * associated with a tab (tabId of -1) and so must be a session rule. Session
 * rules don't persist past a browsing session, so must be re-added.
 * Note: Only exported for use by unit tests, do not call manually.
 * @param {Object} config The privacy configuration
 * @return {Promise}
 */
function ensureServiceWorkerInitiatedRequestExceptions(_x) {
  return _ensureServiceWorkerInitiatedRequestExceptions.apply(this, arguments);
}
function _ensureServiceWorkerInitiatedRequestExceptions() {
  _ensureServiceWorkerInitiatedRequestExceptions = _asyncToGenerator(function* (config) {
    var _config$features$serv, _config$features$serv2;
    var removeRuleIds = [_dnrUtils.SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID];
    var addRules = [];
    if ((_config$features$serv = config.features.serviceworkerInitiatedRequests) !== null && _config$features$serv !== void 0 && (_config$features$serv2 = _config$features$serv.exceptions) !== null && _config$features$serv2 !== void 0 && _config$features$serv2.length) {
      var exceptionDomains = config.features.serviceworkerInitiatedRequests.exceptions.map(function (entry) {
        return entry.domain;
      });
      addRules.push((0, _utils.generateDNRRule)({
        id: _dnrUtils.SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID,
        priority: _rulePriorities.SERVICE_WORKER_INITIATED_ALLOWING_PRIORITY,
        actionType: 'allow',
        tabIds: [-1],
        initiatorDomains: exceptionDomains
      }));
    }

    // Rather than check if the rule already exists before adding it, add it and
    // just clear the existing rule if it exists.
    // Note: This might need to be adjusted in the future if there is a
    //       performance impact, on the other hand, checking for the rule first
    //       might cause a race-condition, where ServiceWorker requests are
    //       blocked before the rule is added.
    yield chrome.declarativeNetRequest.updateSessionRules({
      removeRuleIds: removeRuleIds,
      addRules: addRules
    });
  });
  return _ensureServiceWorkerInitiatedRequestExceptions.apply(this, arguments);
}

},{"./dnr-utils":73,"@duckduckgo/ddg2dnr/lib/rulePriorities":27,"@duckduckgo/ddg2dnr/lib/utils":33}],70:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flushSessionRules = flushSessionRules;
exports.getNextSessionRuleId = getNextSessionRuleId;
exports.setSessionRuleOffsetFromStorage = setSessionRuleOffsetFromStorage;
var browserWrapper = _interopRequireWildcard(require("./wrapper"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var SESSION_RULE_ID_START = 100000;
var SESSION_RULE_STORAGE_KEY = 'sessionRuleOffset';
var sessionRuleOffset = 0;
var ready = false;
function setSessionRuleOffsetFromStorage() {
  return _setSessionRuleOffsetFromStorage.apply(this, arguments);
}
/**
 * Get the next unique session rule id to use when creating session DNR rules
 * @returns {number | null} nextRuleId
 */
function _setSessionRuleOffsetFromStorage() {
  _setSessionRuleOffsetFromStorage = _asyncToGenerator(function* () {
    var offset = yield browserWrapper.getFromSessionStorage(SESSION_RULE_STORAGE_KEY);
    if (offset) {
      sessionRuleOffset = offset;
    }
    ready = true;
  });
  return _setSessionRuleOffsetFromStorage.apply(this, arguments);
}
function getNextSessionRuleId() {
  if (!ready) {
    console.warn('Tried to get session rule id before reading offset from storage');
    return null;
  }
  var nextRuleId = SESSION_RULE_ID_START + sessionRuleOffset;
  sessionRuleOffset += 1;
  browserWrapper.setToSessionStorage(SESSION_RULE_STORAGE_KEY, sessionRuleOffset);
  return nextRuleId;
}
function isValidSessionId(id) {
  return id >= SESSION_RULE_ID_START;
}

/**
* Remove orphaned session ids
* We increment the rule IDs for some session rules, starting at STARTING_RULE_ID and
* keep a note of the next rule ID in session storage. During extesion update/restarts
* session storage is cleared, while session rules are not, which causes errors due to
* session rule ID conflicts
 * @return {Promise}
 */
function flushSessionRules() {
  return chrome.declarativeNetRequest.getSessionRules().then(function (rules) {
    var ruleIds = rules.map(function (_ref) {
      var id = _ref.id;
      return id;
    }).filter(isValidSessionId);
    if (ruleIds.length) {
      return chrome.declarativeNetRequest.updateSessionRules({
        removeRuleIds: ruleIds
      });
    }
  });
}

},{"./wrapper":99}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSmarterEncryptionSessionException = addSmarterEncryptionSessionException;
exports.addSmarterEncryptionSessionRule = addSmarterEncryptionSessionRule;
var _smarterEncryption = require("@duckduckgo/ddg2dnr/lib/smarterEncryption");
var _dnrUtils = require("./dnr-utils");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Update a Smarter Encryption session rule, adding the given domain to the list of domains in the condition.
 * @param {number} ruleId Session rule ID
 * @param {string} addDomain Domain to add to this rule's requestDomains condition.
 * @param {'allow' | 'upgrade'} type If the rule should be an allow or upgrade rule.
 */
function updateSmarterEncryptionSessionRule(_x, _x2, _x3) {
  return _updateSmarterEncryptionSessionRule.apply(this, arguments);
}
function _updateSmarterEncryptionSessionRule() {
  _updateSmarterEncryptionSessionRule = _asyncToGenerator(function* (ruleId, addDomain, type) {
    var existingRule = yield (0, _dnrUtils.findExistingSessionRule)(ruleId);
    var ruleDomains = (existingRule === null || existingRule === void 0 ? void 0 : existingRule.condition.requestDomains) || [];
    if (ruleDomains.includes(addDomain)) {
      return;
    }
    ruleDomains.push(addDomain);
    var _createSmarterEncrypt = (0, _smarterEncryption.createSmarterEncryptionTemporaryRule)(ruleDomains, type, ruleId),
      rule = _createSmarterEncrypt.rule;
    yield chrome.declarativeNetRequest.updateSessionRules({
      removeRuleIds: [ruleId],
      addRules: [rule]
    });
  });
  return _updateSmarterEncryptionSessionRule.apply(this, arguments);
}
function addSmarterEncryptionSessionException(_x4) {
  return _addSmarterEncryptionSessionException.apply(this, arguments);
}
function _addSmarterEncryptionSessionException() {
  _addSmarterEncryptionSessionException = _asyncToGenerator(function* (domain) {
    return updateSmarterEncryptionSessionRule(_dnrUtils.HTTPS_SESSION_ALLOWLIST_RULE_ID, domain, 'allow');
  });
  return _addSmarterEncryptionSessionException.apply(this, arguments);
}
function addSmarterEncryptionSessionRule(_x5) {
  return _addSmarterEncryptionSessionRule.apply(this, arguments);
}
function _addSmarterEncryptionSessionRule() {
  _addSmarterEncryptionSessionRule = _asyncToGenerator(function* (domain) {
    return updateSmarterEncryptionSessionRule(_dnrUtils.HTTPS_SESSION_UPGRADE_RULE_ID, domain, 'upgrade');
  });
  return _addSmarterEncryptionSessionRule.apply(this, arguments);
}

},{"./dnr-utils":73,"@duckduckgo/ddg2dnr/lib/smarterEncryption":28}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDenylistedDomains = getDenylistedDomains;
exports.refreshUserAllowlistRules = refreshUserAllowlistRules;
exports.toggleUserAllowlistDomain = toggleUserAllowlistDomain;
exports.updateUserDenylist = updateUserDenylist;
var _settings = _interopRequireDefault(require("./settings"));
var _rulePriorities = require("@duckduckgo/ddg2dnr/lib/rulePriorities");
var _dnrConfigRulesets = require("./dnr-config-rulesets");
var _dnrUtils = require("./dnr-utils");
var _utils = require("@duckduckgo/ddg2dnr/lib/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Normalize and validate the given untrusted domain (e.g. from user input).
 * Returns the normalized domain, or null should the domain be considered
 * invalid.
 * @param {string} domain
 * @return {null|string}
 */
function normalizeUntrustedDomain(domain) {
  try {
    return new URL('https://' + domain).hostname;
  } catch (e) {
    return null;
  }
}

/**
 * Update the user allowlisting declarativeNetRequest rule to ensure the correct
 * domains are allowlisted.
 * @param {string[]} allowlistedDomains
 * @return {Promise}
 */
function updateUserAllowlistRule(_x) {
  return _updateUserAllowlistRule.apply(this, arguments);
}
/**
 * Update the user allowlisting declarativeNetRequest rule to enable/disable
 * user allowlisting for the given domain.
 * @param {string} domain
 * @param {boolean} enable
 *   True if the domain is being added to the allowlist, false if it is being
 *   removed.
 * @return {Promise}
 */
function _updateUserAllowlistRule() {
  _updateUserAllowlistRule = _asyncToGenerator(function* (allowlistedDomains) {
    var addRules = [];
    var removeRuleIds = [_dnrUtils.USER_ALLOWLIST_RULE_ID];
    if (allowlistedDomains.length > 0) {
      addRules.push((0, _utils.generateDNRRule)({
        id: _dnrUtils.USER_ALLOWLIST_RULE_ID,
        priority: _rulePriorities.USER_ALLOWLISTED_PRIORITY,
        actionType: 'allowAllRequests',
        resourceTypes: ['main_frame'],
        requestDomains: allowlistedDomains
      }));
    }
    yield chrome.declarativeNetRequest.updateDynamicRules({
      removeRuleIds: removeRuleIds,
      addRules: addRules
    });
  });
  return _updateUserAllowlistRule.apply(this, arguments);
}
function toggleUserAllowlistDomain(_x2, _x3) {
  return _toggleUserAllowlistDomain.apply(this, arguments);
}
/**
 * Reset the user allowlisting declarativeNetRequest rule to match the given
 * array of user allowlisted domains.
 * @param {string[]} allowlistedDomains
 * @return {Promise}
 */
function _toggleUserAllowlistDomain() {
  _toggleUserAllowlistDomain = _asyncToGenerator(function* (domain, enable) {
    var normalizedDomain = normalizeUntrustedDomain(domain);
    if (typeof normalizedDomain !== 'string') {
      return;
    }

    // Figure out the correct set of allowlisted domains.
    var existingRule = yield (0, _dnrUtils.findExistingDynamicRule)(_dnrUtils.USER_ALLOWLIST_RULE_ID);
    var allowlistedDomains = new Set(existingRule ? existingRule.condition.requestDomains : []);
    allowlistedDomains[enable ? 'add' : 'delete'](normalizedDomain);
    yield updateUserAllowlistRule(Array.from(allowlistedDomains));
  });
  return _toggleUserAllowlistDomain.apply(this, arguments);
}
function refreshUserAllowlistRules(_x4) {
  return _refreshUserAllowlistRules.apply(this, arguments);
}
/**
 * Retrieve a normalized and sorted list of user denylisted domains.
 * @returns {Promise<string[]>}
 */
function _refreshUserAllowlistRules() {
  _refreshUserAllowlistRules = _asyncToGenerator(function* (allowlistedDomains) {
    // Normalise and validate the domains. We're passing the user provided
    // domains through to the declarativeNetRequest API, so it's important to
    // prevent invalid input sneaking through.
    var normalizedAllowlistedDomains = /** @type {string[]} */
    allowlistedDomains.map(normalizeUntrustedDomain).filter(function (domain) {
      return typeof domain === 'string';
    });
    yield updateUserAllowlistRule(normalizedAllowlistedDomains);
  });
  return _refreshUserAllowlistRules.apply(this, arguments);
}
function getDenylistedDomains() {
  return _getDenylistedDomains.apply(this, arguments);
}
/**
 * Update all the extension configuration rulesets, so that the
 * declarativeNetRequest rules generated for the contentBlocking and
 * unprotectedTemporary allowlisting features take care to exclude the
 * user "denylisted" domains.
 * @return {Promise}
 */
function _getDenylistedDomains() {
  _getDenylistedDomains = _asyncToGenerator(function* () {
    yield _settings["default"].ready();
    var denylist = _settings["default"].getSetting('denylisted') || {};
    var denylistedDomains = [];
    for (var _i = 0, _Object$entries = Object.entries(denylist); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        domain = _Object$entries$_i[0],
        enabled = _Object$entries$_i[1];
      if (enabled) {
        var normalizedDomain = normalizeUntrustedDomain(domain);
        if (normalizedDomain) {
          denylistedDomains.push(normalizedDomain);
        }
      }
    }
    return denylistedDomains.sort();
  });
  return _getDenylistedDomains.apply(this, arguments);
}
function updateUserDenylist() {
  return _updateUserDenylist.apply(this, arguments);
}
function _updateUserDenylist() {
  _updateUserDenylist = _asyncToGenerator(function* () {
    yield (0, _dnrConfigRulesets.updateExtensionConfigRules)();
    yield (0, _dnrConfigRulesets.updateCombinedConfigBlocklistRules)();
  });
  return _updateUserDenylist.apply(this, arguments);
}

},{"./dnr-config-rulesets":68,"./dnr-utils":73,"./settings":90,"@duckduckgo/ddg2dnr/lib/rulePriorities":27,"@duckduckgo/ddg2dnr/lib/utils":33}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.USER_ALLOWLIST_RULE_ID = exports.SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID = exports.NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID = exports.HTTPS_SESSION_UPGRADE_RULE_ID = exports.HTTPS_SESSION_ALLOWLIST_RULE_ID = exports.ATB_PARAM_RULE_ID = void 0;
exports.clearInvalidDynamicRules = clearInvalidDynamicRules;
exports.findExistingSessionRule = exports.findExistingDynamicRule = void 0;
exports.getMatchDetails = getMatchDetails;
var _dnrConfigRulesets = require("./dnr-config-rulesets");
var _settings = _interopRequireDefault(require("./settings"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Rule IDs notes:
// - Individual hardcoded rule IDs live here.
// - Ensure they are within the range of 20001 to 21000, otherwise
//   they could clash by the rule ID ranges used by dnr-config.js.
// - While dynamic and session rules are considered as being different
//   rulesets, and therefore can have overlapping rule IDs, the
//   convention here is to keep the rule IDs unique.
// - When adding a dynamic rule ID here, ensure to also add it to the
//   RESERVED_DYNAMIC_RULE_IDS array. Otherwise the rule will be
//   cleared when the extension install event fires.
//   Note: This is _not_ necessary for session rule IDs.
// - While other rule ID ranges are defined elsewhere (e.g. in
//   dnr-config.js and dnr-session-rule-id.js), keep other hard-coded
//   rule IDs together here. Otherwise it's easy to miss clashing rule
//   IDs.

// User allowlisting and the ServicerWorker initiated request exception both
// only require one declarativeNetRequest rule, so hardcode the rule IDs here.
var USER_ALLOWLIST_RULE_ID = 20001;
exports.USER_ALLOWLIST_RULE_ID = USER_ALLOWLIST_RULE_ID;
var ATB_PARAM_RULE_ID = 20003;
exports.ATB_PARAM_RULE_ID = ATB_PARAM_RULE_ID;
var NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID = 20006;

// Rule IDs for static session rules
exports.NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID = NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID;
var SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID = 20002;
exports.SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID = SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID;
var HTTPS_SESSION_ALLOWLIST_RULE_ID = 20004;
exports.HTTPS_SESSION_ALLOWLIST_RULE_ID = HTTPS_SESSION_ALLOWLIST_RULE_ID;
var HTTPS_SESSION_UPGRADE_RULE_ID = 20005;

// Valid dynamic rule IDs - others will be removed on extension start
exports.HTTPS_SESSION_UPGRADE_RULE_ID = HTTPS_SESSION_UPGRADE_RULE_ID;
var RESERVED_DYNAMIC_RULE_IDS = [USER_ALLOWLIST_RULE_ID, ATB_PARAM_RULE_ID, NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID];

/**
 * Find an existing session or dynamic declarativeNetRequest rule with the given rule ID
 * and return it.
 * @param {number} desiredRuleId
 * @returns {Promise<chrome.declarativeNetRequest.Rule | undefined>}
 */
function findExistingRule() {
  return _findExistingRule.apply(this, arguments);
}
function _findExistingRule() {
  _findExistingRule = _asyncToGenerator(function* () {
    var isSessionRule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var desiredRuleId = arguments.length > 1 ? arguments[1] : undefined;
    // TODO: Pass a rule ID filter[1] (to avoid querying all rules) once
    //       Chrome >= 111 is the minimum supported version.
    //       See https://crbug.com/1379699
    // 1 - https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-GetRulesFilter
    var rules = yield chrome.declarativeNetRequest[isSessionRule ? 'getSessionRules' : 'getDynamicRules']();
    return rules.find(function (r) {
      return r.id === desiredRuleId;
    });
  });
  return _findExistingRule.apply(this, arguments);
}
var findExistingDynamicRule = findExistingRule.bind(null, false);
exports.findExistingDynamicRule = findExistingDynamicRule;
var findExistingSessionRule = findExistingRule.bind(null, true);

/**
 * @typedef {object} getMatchDetailsTrackerBlockingResult
 * @property {string} type
 *   The match type 'trackerBlocking'.
 * @property {string[]} possibleTrackerDomains
 *   The list of possible tracking domains associated with this match.
 */

/**
 * @typedef {object} getMatchDetailsExtensionConfigurationResult
 * @property {string} type
 *   The match type, for example 'trackerAllowlist'.
 * @property {string} domain
 *   The matching tracker domain.
 * @property {string} reason
 *   The reason for the match.
 */

/**
 * @typedef {object} getMatchDetailsResult
 * @property {string} type
 *   The match type, e.g. 'unknown' or 'userAllowlist'.
 */

/**
 * Find the match details (if any) associated with the given
 * declarativeNetRequest rule ID.
 * @param {number} ruleId
 * @return {Promise<getMatchDetailsResult |
 *                  getMatchDetailsExtensionConfigurationResult |
 *                  getMatchDetailsTrackerBlockingResult>}
 */
exports.findExistingSessionRule = findExistingSessionRule;
function getMatchDetails(_x) {
  return _getMatchDetails.apply(this, arguments);
}
/**
 * Find any dynamic rules outside of the existing expected rule range and remove them.
 */
function _getMatchDetails() {
  _getMatchDetails = _asyncToGenerator(function* (ruleId) {
    yield _settings["default"].ready();
    if (ruleId === USER_ALLOWLIST_RULE_ID) {
      return {
        type: 'userAllowlist'
      };
    }
    if (ruleId === SERVICE_WORKER_INITIATED_ALLOWING_RULE_ID) {
      return {
        type: 'serviceWorkerInitiatedAllowing'
      };
    }
    if (ruleId === ATB_PARAM_RULE_ID) {
      return {
        type: 'atbParam'
      };
    }
    for (var _i = 0, _Object$entries = Object.entries(_dnrConfigRulesets.ruleIdRangeByConfigName); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        configName = _Object$entries$_i[0],
        _Object$entries$_i$ = _slicedToArray(_Object$entries$_i[1], 2),
        ruleIdStart = _Object$entries$_i$[0],
        ruleIdEnd = _Object$entries$_i$[1];
      if (ruleId >= ruleIdStart && ruleId <= ruleIdEnd) {
        var _settingValue$matchDe;
        var settingName = _dnrConfigRulesets.SETTING_PREFIX + configName;
        var settingValue = _settings["default"].getSetting(settingName);
        var matchDetails = settingValue === null || settingValue === void 0 ? void 0 : (_settingValue$matchDe = settingValue.matchDetailsByRuleId) === null || _settingValue$matchDe === void 0 ? void 0 : _settingValue$matchDe[ruleId];
        if (matchDetails) {
          if (configName === 'tds') {
            return {
              type: 'trackerBlocking',
              possibleTrackerDomains: matchDetails.split(',')
            };
          }
          return JSON.parse(JSON.stringify(matchDetails));
        }
      }
    }
    return {
      type: 'unknown'
    };
  });
  return _getMatchDetails.apply(this, arguments);
}
function clearInvalidDynamicRules() {
  return _clearInvalidDynamicRules.apply(this, arguments);
}
function _clearInvalidDynamicRules() {
  _clearInvalidDynamicRules = _asyncToGenerator(function* () {
    var existingRules = yield chrome.declarativeNetRequest.getDynamicRules();
    var invalidRules = existingRules.filter(function (rule) {
      if (rule.id >= _dnrConfigRulesets.ruleIdRangeByConfigName.combined[1]) {
        // greater than the max rule ID
        return true;
      }
      if (rule.id >= _dnrConfigRulesets.ruleIdRangeByConfigName._RESERVED[0] && rule.id <= _dnrConfigRulesets.ruleIdRangeByConfigName._RESERVED[1]) {
        // in the reserved rule range, only explictly defined IDs are allowed
        return !RESERVED_DYNAMIC_RULE_IDS.includes(rule.id);
      }
      return false;
    }).map(function (rule) {
      return rule.id;
    });
    if (invalidRules.length > 0) {
      console.log('Removing invliad rule ids', invalidRules);
      yield chrome.declarativeNetRequest.updateDynamicRules({
        removeRuleIds: invalidRules
      });
    }
  });
  return _clearInvalidDynamicRules.apply(this, arguments);
}

},{"./dnr-config-rulesets":68,"./settings":90}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showContextMenuAction = exports.sendJSPixel = exports.isValidUsername = exports.isValidToken = exports.hideContextMenuAction = exports.getAddresses = exports.formatAddress = exports.fetchAlias = exports.REFETCH_ALIAS_ALARM = void 0;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _pixels = require("./pixels");
var _load = _interopRequireDefault(require("./load"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var _require = require('./settings'),
  getSetting = _require.getSetting,
  updateSetting = _require.updateSetting;
var browserWrapper = require('./wrapper');
var utils = require('./utils');
var REFETCH_ALIAS_ALARM = 'refetchAlias';
exports.REFETCH_ALIAS_ALARM = REFETCH_ALIAS_ALARM;
var REFETCH_ALIAS_ATTEMPT = 'refetchAliasAttempt';
var pixelsEnabled = utils.getBrowserName() !== 'moz';
var fetchAlias = function fetchAlias() {
  // if another fetch was previously scheduled, clear that and execute now
  _webextensionPolyfill["default"].alarms.clear(REFETCH_ALIAS_ALARM);
  var userData = getSetting('userData');
  if (!(userData !== null && userData !== void 0 && userData.token)) return;
  return fetch('https://quack.duckduckgo.com/api/email/addresses', {
    method: 'post',
    headers: {
      Authorization: "Bearer ".concat(userData.token)
    }
  }).then( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (response) {
      if (response.ok) {
        return response.json().then( /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator(function* (_ref2) {
            var address = _ref2.address;
            if (!/^[a-z0-9]+$/.test(address)) throw new Error('Invalid address');
            updateSetting('userData', Object.assign(userData, {
              nextAlias: "".concat(address)
            }));
            // Reset attempts
            yield browserWrapper.removeFromSessionStorage(REFETCH_ALIAS_ATTEMPT);
            return {
              success: true
            };
          });
          return function (_x2) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        throw new Error('An error occurred while fetching the alias');
      }
    });
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }())["catch"]( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(function* (e) {
      // TODO: Do we want to logout if the error is a 401 unauthorized?
      console.log('Error fetching new alias', e);
      // Don't try fetching more than 5 times in a row
      var attempts = (yield browserWrapper.getFromSessionStorage(REFETCH_ALIAS_ATTEMPT)) || 1;
      if (attempts < 5) {
        browserWrapper.createAlarm(REFETCH_ALIAS_ALARM, {
          delayInMinutes: 2
        });
        yield browserWrapper.setToSessionStorage(REFETCH_ALIAS_ATTEMPT, attempts + 1);
      }
      // Return the error so we can handle it
      return {
        error: e
      };
    });
    return function (_x3) {
      return _ref4.apply(this, arguments);
    };
  }());
};
exports.fetchAlias = fetchAlias;
var MENU_ITEM_ID = 'ddg-autofill-context-menu-item';
// Create the contextual menu hidden by default
_webextensionPolyfill["default"].contextMenus.create({
  id: MENU_ITEM_ID,
  title: 'Generate Private Duck Address',
  contexts: ['editable'],
  documentUrlPatterns: ['https://*/*'],
  visible: false
}, function () {
  // It's fine if this context menu already exists, suppress that error.
  // Note: Since webextension-polyfill does not wrap the contextMenus.create
  //       API, the old callback + runtime.lastError approach must be used.
  var lastError = _webextensionPolyfill["default"].runtime.lastError;
  if (lastError && lastError.message && !lastError.message.startsWith('Cannot create item with duplicate id')) {
    throw lastError;
  }
});
_webextensionPolyfill["default"].contextMenus.onClicked.addListener(function (info, tab) {
  var userData = getSetting('userData');
  if (tab !== null && tab !== void 0 && tab.id && userData.nextAlias) {
    _webextensionPolyfill["default"].tabs.sendMessage(tab.id, {
      type: 'contextualAutofill',
      alias: userData.nextAlias
    });
  }
});
var showContextMenuAction = function showContextMenuAction() {
  return _webextensionPolyfill["default"].contextMenus.update(MENU_ITEM_ID, {
    visible: true
  });
};
exports.showContextMenuAction = showContextMenuAction;
var hideContextMenuAction = function hideContextMenuAction() {
  return _webextensionPolyfill["default"].contextMenus.update(MENU_ITEM_ID, {
    visible: false
  });
};
exports.hideContextMenuAction = hideContextMenuAction;
var getAddresses = function getAddresses() {
  var userData = getSetting('userData');
  return {
    personalAddress: userData === null || userData === void 0 ? void 0 : userData.userName,
    privateAddress: userData === null || userData === void 0 ? void 0 : userData.nextAlias
  };
};
exports.getAddresses = getAddresses;
function sendPixelRequest(pixelName) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var randomNum = Math.ceil(Math.random() * 1e7);
  var searchParams = new URLSearchParams(Object.entries(params));
  var url = (0, _pixels.getURL)(pixelName) + "?".concat(randomNum, "&").concat(searchParams.toString());
  _load["default"].url(url);
}
function currentDate() {
  return new Date().toLocaleString('en-CA', {
    timeZone: 'America/New_York',
    dateStyle: 'short'
  });
}
var getFullPixelName = function getFullPixelName(name, browserName) {
  return "".concat(name, "_").concat(browserName.toLowerCase());
};
var fireAddressUsedPixel = function fireAddressUsedPixel(pixel) {
  var _utils$getBrowserName, _getSetting;
  var browserName = (_utils$getBrowserName = utils.getBrowserName()) !== null && _utils$getBrowserName !== void 0 ? _utils$getBrowserName : 'unknown';
  if (!pixelsEnabled) return;
  var userData = getSetting('userData');
  if (!(userData !== null && userData !== void 0 && userData.userName)) return;
  var lastAddressUsedAt = (_getSetting = getSetting('lastAddressUsedAt')) !== null && _getSetting !== void 0 ? _getSetting : '';
  sendPixelRequest(getFullPixelName(pixel, browserName), {
    duck_address_last_used: lastAddressUsedAt,
    cohort: userData.cohort
  });
  updateSetting('lastAddressUsedAt', currentDate());
};
var fireIncontextSignupPixel = function fireIncontextSignupPixel(pixel) {
  var _utils$getBrowserName2;
  var browserName = (_utils$getBrowserName2 = utils.getBrowserName()) !== null && _utils$getBrowserName2 !== void 0 ? _utils$getBrowserName2 : 'unknown';
  if (!pixelsEnabled) return;
  sendPixelRequest(getFullPixelName(pixel, browserName));
};

/**
 * Config type definition
 * @typedef {Object} FirePixelOptions
 * @property {import('@duckduckgo/autofill/src/deviceApiCalls/__generated__/validators-ts').SendJSPixelParams['pixelName']} pixelName
 */

/**
 *
 * @param {FirePixelOptions}  options
 */
var sendJSPixel = function sendJSPixel(options) {
  var pixelName = options.pixelName;
  switch (pixelName) {
    case 'autofill_show':
      fireAddressUsedPixel('email_tooltip_show_extension');
      break;
    case 'autofill_private_address':
      fireAddressUsedPixel('email_filled_random_extension');
      break;
    case 'autofill_personal_address':
      fireAddressUsedPixel('email_filled_main_extension');
      break;
    case 'incontext_show':
      fireIncontextSignupPixel('incontext_show_extension');
      break;
    case 'incontext_primary_cta':
      fireIncontextSignupPixel('incontext_primary_cta_extension');
      break;
    case 'incontext_dismiss_persisted':
      fireIncontextSignupPixel('incontext_dismiss_persisted_extension');
      break;
    case 'incontext_close_x':
      fireIncontextSignupPixel('incontext_close_x_extension');
      break;
    default:
      console.error('Unknown pixel name', pixelName);
  }
};

/**
 * Given a username, returns a valid email address with the duck domain
 * @param {string} address
 * @returns {string}
 */
exports.sendJSPixel = sendJSPixel;
var formatAddress = function formatAddress(address) {
  return address + '@duck.com';
};

/**
 * Checks formal username validity
 * @param {string} userName
 * @returns {boolean}
 */
exports.formatAddress = formatAddress;
var isValidUsername = function isValidUsername(userName) {
  return /^[a-z0-9_]+$/.test(userName);
};

/**
 * Checks formal token validity
 * @param {string} token
 * @returns {boolean}
 */
exports.isValidUsername = isValidUsername;
var isValidToken = function isValidToken(token) {
  return /^[a-z0-9]+$/.test(token);
};
exports.isValidToken = isValidToken;

},{"./load":83,"./pixels":87,"./settings":90,"./utils":98,"./wrapper":99,"webextension-polyfill":11}],75:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var messageHandlers = _interopRequireWildcard(require("./message-handlers"));
var _privacyIconIndicator = require("./events/privacy-icon-indicator");
var _dnrSessionRuleId = require("./dnr-session-rule-id");
var _dnrClickToLoad = require("./dnr-click-to-load");
var _dnrUtils = require("./dnr-utils");
var _dnrUserAllowlist = require("./dnr-user-allowlist");
var _tds = _interopRequireDefault(require("./storage/tds"));
var _https = _interopRequireDefault(require("./storage/https"));
var _atb = _interopRequireDefault(require("./atb"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var utils = require('./utils');
var experiment = require('./experiments');
var settings = require('./settings');
var constants = require('../../data/constants');
var onboarding = require('./onboarding');
var cspProtection = require('./csp-blocking');
var browserName = utils.getBrowserName();
var devtools = require('./devtools');
var browserWrapper = require('./wrapper');
var limitReferrerData = require('./events/referrer-trimming');
var _require = require('./events/3p-tracking-cookie-blocking'),
  dropTracking3pCookiesFromResponse = _require.dropTracking3pCookiesFromResponse,
  dropTracking3pCookiesFromRequest = _require.dropTracking3pCookiesFromRequest,
  validateSetCookieBlock = _require.validateSetCookieBlock;
var manifestVersion = browserWrapper.getManifestVersion();
function onInstalled(_x) {
  return _onInstalled.apply(this, arguments);
}
function _onInstalled() {
  _onInstalled = _asyncToGenerator(function* (details) {
    _tds["default"].initOnInstall();
    if (details.reason.match(/install/)) {
      yield settings.ready();
      settings.updateSetting('showWelcomeBanner', true);
      if (browserName === 'chrome') {
        settings.updateSetting('showCounterMessaging', true);
      }
      yield _atb["default"].updateATBValues();
      yield _atb["default"].openPostInstallPage();
      if (browserName === 'chrome') {
        experiment.setActiveExperiment();
      }
    } else if (details.reason.match(/update/) && browserName === 'chrome') {
      experiment.setActiveExperiment();
    }
    if (manifestVersion === 3) {
      yield settings.ready();

      // remove any orphaned session rules (can happen on extension update/restart)
      yield (0, _dnrSessionRuleId.flushSessionRules)();

      // check that the dynamic rule state is consistent with the rule ranges we expect
      (0, _dnrUtils.clearInvalidDynamicRules)();

      // create ATB rule if there is a stored value in settings
      _atb["default"].setOrUpdateATBdnrRule(settings.getSetting('atb'));

      // Refresh the user allowlisting declarativeNetRequest rule, only
      // necessary to handle the upgrade between MV2 and MV3 extensions.
      // TODO: Remove this a while after users have all been migrated to
      //       the MV3 build.
      var allowlist = settings.getSetting('allowlisted') || {};
      var allowlistedDomains = [];
      for (var _i2 = 0, _Object$entries = Object.entries(allowlist); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
          domain = _Object$entries$_i[0],
          enabled = _Object$entries$_i[1];
        if (enabled) {
          allowlistedDomains.push(domain);
        }
      }
      yield (0, _dnrUserAllowlist.refreshUserAllowlistRules)(allowlistedDomains);
    }

    // Inject the email content script on all tabs upon installation (not needed on Firefox)
    // FIXME the below code throws an unhandled exception in MV3
    try {
      if (browserName !== 'moz') {
        var tabs = yield _webextensionPolyfill["default"].tabs.query({});
        var _iterator = _createForOfIteratorHelper(tabs),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tab = _step.value;
            // Ignore URLs that we aren't permitted to access
            if (tab.url.startsWith('chrome://')) {
              continue;
            }
            yield browserWrapper.executeScript({
              target: {
                tabId: tab.id
              },
              files: ['public/js/content-scripts/autofill.js']
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    } catch (e) {
      console.warn('Failed to inject email content script at startup:', e);
    }
  });
  return _onInstalled.apply(this, arguments);
}
_webextensionPolyfill["default"].runtime.onInstalled.addListener(onInstalled);

/**
 * ONBOARDING
 * Logic to allow the SERP to display onboarding UI
 */
function onboardingMessaging(_x2) {
  return _onboardingMessaging.apply(this, arguments);
}
function _onboardingMessaging() {
  _onboardingMessaging = _asyncToGenerator(function* (_ref) {
    var transitionQualifiers = _ref.transitionQualifiers,
      tabId = _ref.tabId;
    yield settings.ready();
    var showWelcomeBanner = settings.getSetting('showWelcomeBanner');
    var showCounterMessaging = settings.getSetting('showCounterMessaging');

    // If the onboarding messaging has already been displayed, there's no need
    // to trigger this event listener any longer.
    if (!showWelcomeBanner && !showCounterMessaging) {
      _webextensionPolyfill["default"].webNavigation.onCommitted.removeListener(onboardingMessaging);
      return;
    }

    // The counter messaging should only be active for the very first search
    // navigation observed.
    var isAddressBarQuery = transitionQualifiers.includes('from_address_bar');
    if (isAddressBarQuery && showCounterMessaging) {
      settings.removeSetting('showCounterMessaging');
    }

    // Clear the showWelcomeBanner setting to ensure that the welcome banner
    // isn't shown again in the future.
    if (showWelcomeBanner) {
      settings.removeSetting('showWelcomeBanner');
    }

    // Display the onboarding messaging.

    if (browserName === 'chrome') {
      browserWrapper.executeScript({
        target: {
          tabId: tabId
        },
        func: onboarding.onDocumentStart,
        args: [{
          duckDuckGoSerpHostname: constants.duckDuckGoSerpHostname
        }],
        injectImmediately: true
      });
    }
    browserWrapper.executeScript({
      target: {
        tabId: tabId
      },
      func: onboarding.onDocumentEnd,
      args: [{
        isAddressBarQuery: isAddressBarQuery,
        showWelcomeBanner: showWelcomeBanner,
        showCounterMessaging: showCounterMessaging,
        browserName: browserName,
        duckDuckGoSerpHostname: constants.duckDuckGoSerpHostname,
        extensionId: browserWrapper.getExtensionId()
      }],
      injectImmediately: false
    });
  });
  return _onboardingMessaging.apply(this, arguments);
}
_webextensionPolyfill["default"].webNavigation.onCommitted.addListener(onboardingMessaging, {
  // We only target the search results page (SERP), which has a 'q' query
  // parameter. Two filters are required since the parameter is not
  // necessarily first.
  url: [{
    schemes: ['https'],
    hostEquals: constants.duckDuckGoSerpHostname,
    pathEquals: '/',
    queryContains: '?q='
  }, {
    schemes: ['https'],
    hostEquals: constants.duckDuckGoSerpHostname,
    pathEquals: '/',
    queryContains: '&q='
  }]
});

/**
 * Health checks + `showCounterMessaging` mutation
 * (Chrome only)
 */
if (browserName === 'chrome') {
  chrome.runtime.onMessage.addListener( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (request, sender, sendResponse) {
      if (request === 'healthCheckRequest') {
        sendResponse(true);
      } else if (request === 'rescheduleCounterMessagingRequest') {
        yield settings.ready();
        settings.updateSetting('rescheduleCounterMessagingOnStart', true);
        sendResponse(true);
      }
    });
    return function (_x3, _x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }());
  _webextensionPolyfill["default"].runtime.onStartup.addListener( /*#__PURE__*/_asyncToGenerator(function* () {
    yield settings.ready();
    if (settings.getSetting('rescheduleCounterMessagingOnStart')) {
      settings.removeSetting('rescheduleCounterMessagingOnStart');
      settings.updateSetting('showCounterMessaging', true);
    }
  }));
}

/**
 * REQUESTS
 */

var beforeRequest = require('./before-request');
var tabManager = require('./tab-manager');
var https = require('./https');
var additionalOptions = [];
if (manifestVersion === 2) {
  additionalOptions = ['blocking'];
}
_webextensionPolyfill["default"].webRequest.onBeforeRequest.addListener(beforeRequest.handleRequest, {
  urls: ['<all_urls>']
}, additionalOptions);

// MV2 needs blocking for webRequest
// MV3 still needs some info from response headers
var extraInfoSpec = ['responseHeaders'];
if (manifestVersion === 2) {
  extraInfoSpec.push('blocking');
}
if (_webextensionPolyfill["default"].webRequest.OnHeadersReceivedOptions.EXTRA_HEADERS) {
  extraInfoSpec.push(_webextensionPolyfill["default"].webRequest.OnHeadersReceivedOptions.EXTRA_HEADERS);
}

// We determine if browsingTopics is enabled by testing for availability of its
// JS API.
// Note: This approach will not work with MV3 since the background
//       ServiceWorker does not have access to a `document` Object.
var isTopicsEnabled = manifestVersion === 2 && 'browsingTopics' in document && utils.isFeatureEnabled('googleRejected');
_webextensionPolyfill["default"].webRequest.onHeadersReceived.addListener(function (request) {
  if (request.type === 'main_frame') {
    tabManager.updateTabUrl(request);
    var tab = tabManager.get({
      tabId: request.tabId
    });
    // SERP ad click detection
    if (utils.isRedirect(request.statusCode)) {
      tab.setAdClickIfValidRedirect(request.url);
    } else if (tab && tab.adClick && tab.adClick.adClickRedirect && !utils.isRedirect(request.statusCode)) {
      tab.adClick.setAdBaseDomain(tab.site.baseDomain);
    }
  }
  if (_atb["default"].shouldUpdateSetAtb(request)) {
    // returns a promise
    return _atb["default"].updateSetAtb();
  }
  var responseHeaders = request.responseHeaders;
  if (isTopicsEnabled && responseHeaders && (request.type === 'main_frame' || request.type === 'sub_frame')) {
    // there can be multiple permissions-policy headers, so we are good always appending one
    // According to Google's docs a site can opt out of browsing topics the same way as opting out of FLoC
    // https://privacysandbox.com/proposals/topics (See FAQ)
    responseHeaders.push({
      name: 'permissions-policy',
      value: 'interest-cohort=()'
    });
  }
  return {
    responseHeaders: responseHeaders
  };
}, {
  urls: ['<all_urls>']
}, extraInfoSpec);

// Store the created tab id for when onBeforeNavigate is called so data can be copied across from the source tab
var createdTargets = new Map();
_webextensionPolyfill["default"].webNavigation.onCreatedNavigationTarget.addListener(function (details) {
  createdTargets.set(details.tabId, details.sourceTabId);
});

/**
 * Web Navigation
 */
// keep track of URLs that the browser navigates to.
//
// this is supplemented by tabManager.updateTabUrl() on headersReceived:
// tabManager.updateTabUrl only fires when a tab has finished loading with a 200,
// which misses a couple of edge cases like browser special pages
// and Gmail's weird redirect which returns a 200 via a service worker
_webextensionPolyfill["default"].webNavigation.onBeforeNavigate.addListener(function (details) {
  // ignore navigation on iframes
  if (details.frameId !== 0) return;
  var currentTab = tabManager.get({
    tabId: details.tabId
  });
  var newTab = tabManager.create({
    tabId: details.tabId,
    url: details.url
  });
  if (manifestVersion === 3) {
    // Ensure that the correct declarativeNetRequest allowing rules are
    // added for this tab.
    // Note: The webNavigation.onBeforeCommitted event would be better,
    //       since onBeforeNavigate can be fired for a navigation that is
    //       not later committed. But since there is a race-condition
    //       between the page loading and the rules being added, let's use
    //       onBeforeNavigate for now as it fires sooner.
    (0, _dnrClickToLoad.restoreDefaultClickToLoadRuleActions)(newTab);
  }

  // persist the last URL the tab was trying to upgrade to HTTPS
  if (currentTab && currentTab.httpsRedirects) {
    newTab.httpsRedirects.persistMainFrameRedirect(currentTab.httpsRedirects.getMainFrameRedirect());
  }
  if (createdTargets.has(details.tabId)) {
    var sourceTabId = createdTargets.get(details.tabId);
    createdTargets["delete"](details.tabId);
    var sourceTab = tabManager.get({
      tabId: sourceTabId
    });
    if (sourceTab && sourceTab.adClick) {
      createdTargets.set(details.tabId, sourceTabId);
      if (sourceTab.adClick.shouldPropagateAdClickForNewTab(newTab)) {
        newTab.adClick = sourceTab.adClick.propagate(newTab.id);
      }
    }
  }
  newTab.updateSite(details.url);
  devtools.postMessage(details.tabId, 'tabChange', devtools.serializeTab(newTab));
});

/**
 * TABS
 */

var Companies = require('./companies');
_webextensionPolyfill["default"].tabs.onCreated.addListener(function (info) {
  if (info.id) {
    tabManager.createOrUpdateTab(info.id, info);
  }
});
_webextensionPolyfill["default"].tabs.onUpdated.addListener(function (id, info) {
  // sync company data to storage when a tab finishes loading
  if (info.status === 'complete') {
    Companies.syncToStorage();
  }
  tabManager.createOrUpdateTab(id, info);
});
_webextensionPolyfill["default"].tabs.onRemoved.addListener(function (id, info) {
  // remove the tab object
  tabManager["delete"](id);
});

// message popup to close when the active tab changes.
_webextensionPolyfill["default"].tabs.onActivated.addListener(function () {
  browserWrapper.notifyPopup({
    closePopup: true
  });
});

// search via omnibox
_webextensionPolyfill["default"].omnibox.onInputEntered.addListener( /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (text) {
    var tabs = yield _webextensionPolyfill["default"].tabs.query({
      currentWindow: true,
      active: true
    });
    _webextensionPolyfill["default"].tabs.update(tabs[0].id, {
      url: 'https://duckduckgo.com/?q=' + encodeURIComponent(text) + '&bext=' + utils.getOsName() + 'cl'
    });
  });
  return function (_x6) {
    return _ref4.apply(this, arguments);
  };
}());

/**
 * MESSAGES
 */
var _require2 = require('./email-utils'),
  REFETCH_ALIAS_ALARM = _require2.REFETCH_ALIAS_ALARM,
  fetchAlias = _require2.fetchAlias;

// Handle any messages that come from content/UI scripts
_webextensionPolyfill["default"].runtime.onMessage.addListener(function (req, sender) {
  if (sender.id !== browserWrapper.getExtensionId()) return;

  // TODO clean up message passing
  var legacyMessageTypes = ['addUserData', 'getUserData', 'removeUserData', 'getEmailProtectionCapabilities', 'getAddresses', 'refreshAlias', 'debuggerMessage'];
  for (var _i = 0, _legacyMessageTypes = legacyMessageTypes; _i < _legacyMessageTypes.length; _i++) {
    var legacyMessageType = _legacyMessageTypes[_i];
    if (legacyMessageType in req) {
      req.messageType = legacyMessageType;
      req.options = req[legacyMessageType];
    }
  }
  if (req.registeredTempAutofillContentScript) {
    req.messageType = 'registeredContentScript';
  }
  if (req.messageType && req.messageType in messageHandlers) {
    return Promise.resolve(messageHandlers[req.messageType](req.options, sender, req));
  }

  // TODO clean up legacy onboarding messaging
  if (browserName === 'chrome') {
    if (req === 'healthCheckRequest' || req === 'rescheduleCounterMessagingRequest') {
      return;
    }
  }
  console.error('Unrecognized message to background:', req, sender);
  return false;
});

/*
 * Referrer Trimming
 */
if (manifestVersion === 2) {
  var referrerListenerOptions = ['blocking', 'requestHeaders'];
  if (_webextensionPolyfill["default"].webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS) {
    referrerListenerOptions.push(_webextensionPolyfill["default"].webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS);
  }
  _webextensionPolyfill["default"].webRequest.onBeforeSendHeaders.addListener(limitReferrerData, {
    urls: ['<all_urls>']
  }, referrerListenerOptions);
}

/**
 * Global Privacy Control
 */
var GPC = require('./GPC');
var extraInfoSpecSendHeaders = ['requestHeaders'];
if (_webextensionPolyfill["default"].webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS) {
  extraInfoSpecSendHeaders.push(_webextensionPolyfill["default"].webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS);
}
if (manifestVersion === 2) {
  extraInfoSpecSendHeaders.push('blocking');
  // Attach GPC header to all requests if enabled.
  _webextensionPolyfill["default"].webRequest.onBeforeSendHeaders.addListener(function (request) {
    var tab = tabManager.get({
      tabId: request.tabId
    });
    var GPCHeader = GPC.getHeader();
    var GPCEnabled = tab && tab.site.isFeatureEnabled('gpc');
    var requestHeaders = request.requestHeaders;
    if (GPCHeader && GPCEnabled) {
      requestHeaders.push(GPCHeader);
    }
    return {
      requestHeaders: requestHeaders
    };
  }, {
    urls: ['<all_urls>']
  }, extraInfoSpecSendHeaders);
}
_webextensionPolyfill["default"].webRequest.onBeforeSendHeaders.addListener(dropTracking3pCookiesFromRequest, {
  urls: ['<all_urls>']
}, extraInfoSpecSendHeaders);
_webextensionPolyfill["default"].webRequest.onHeadersReceived.addListener(dropTracking3pCookiesFromResponse, {
  urls: ['<all_urls>']
}, extraInfoSpec);
if (manifestVersion === 3) {
  _webextensionPolyfill["default"].webRequest.onCompleted.addListener(validateSetCookieBlock, {
    urls: ['<all_urls>']
  }, extraInfoSpec);
}

/**
 * For each completed page load, update the extension's action icon
 */
_webextensionPolyfill["default"].webNavigation.onCompleted.addListener(function (details) {
  // only update the icon when the outermost frame is complete
  if (details.parentFrameId !== -1) return;

  // try to access the tab where this event originated
  var tab = tabManager.get({
    tabId: details.tabId
  });

  // just to be sure that we can access the current tab
  if (!tab) return;

  // select the next icon state
  (0, _privacyIconIndicator.updateActionIcon)(tab.site, tab.id)["catch"](function (e) {
    return console.error('could not set the action icon', e);
  });
});

/**
 * ALARMS
 */

var httpsService = require('./https-service');
var trackers = require('./trackers');
browserWrapper.createAlarm('updateHTTPSLists', {
  periodInMinutes: _https["default"].updatePeriodInMinutes
});
browserWrapper.createAlarm('updateLists', {
  periodInMinutes: _tds["default"].updatePeriodInMinutes
});
// update uninstall URL every 10 minutes
browserWrapper.createAlarm('updateUninstallURL', {
  periodInMinutes: 10
});
// remove expired HTTPS service entries
browserWrapper.createAlarm('clearExpiredHTTPSServiceCache', {
  periodInMinutes: 60
});
// Rotate the user agent spoofed
browserWrapper.createAlarm('rotateUserAgent', {
  periodInMinutes: 24 * 60
});
// Rotate the sessionKey
browserWrapper.createAlarm('rotateSessionKey', {
  periodInMinutes: 24 * 60
});
_webextensionPolyfill["default"].alarms.onAlarm.addListener( /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (alarmEvent) {
    // Warning: Awaiting in this function doesn't actually wait for the promise to resolve before unblocking the main thread.
    if (alarmEvent.name === 'updateHTTPSLists') {
      yield settings.ready();
      try {
        var lists = yield _https["default"].getLists();
        https.setLists(lists);
      } catch (e) {
        console.log(e);
      }
    } else if (alarmEvent.name === 'updateUninstallURL') {
      _webextensionPolyfill["default"].runtime.setUninstallURL(yield _atb["default"].getSurveyURL());
    } else if (alarmEvent.name === 'updateLists') {
      yield settings.ready();
      try {
        var _lists = yield _tds["default"].getLists();
        trackers.setLists(_lists);
      } catch (e) {
        console.log(e);
      }
    } else if (alarmEvent.name === 'clearExpiredHTTPSServiceCache') {
      httpsService.clearExpiredCache();
    } else if (alarmEvent.name === 'rotateSessionKey') {
      yield utils.resetSessionKey();
    } else if (alarmEvent.name === REFETCH_ALIAS_ALARM) {
      fetchAlias();
    }
  });
  return function (_x7) {
    return _ref3.apply(this, arguments);
  };
}());

// Count https upgrade failures to allow bad data to be removed from lists
_webextensionPolyfill["default"].webRequest.onErrorOccurred.addListener(function (e) {
  if (!(e.type === 'main_frame')) return;
  var tab = tabManager.get({
    tabId: e.tabId
  });

  // We're only looking at failed main_frame upgrades. A tab can send multiple
  // main_frame request errors so we will only look at the first one then set tab.hasHttpsError.
  if (!tab || !tab.mainFrameUpgraded || tab.hasHttpsError) {
    return;
  }
  if (e.error && e.url.match(/^https/)) {
    var errCode = constants.httpsErrorCodes[e.error];
    tab.hasHttpsError = true;
    if (errCode) {
      https.incrementUpgradeCount('failedUpgrades');
    }
  }
}, {
  urls: ['<all_urls>']
});
if (browserName === 'moz') {
  cspProtection.init();
}
devtools.init();

},{"../../data/constants":38,"./GPC":43,"./atb":47,"./before-request":49,"./companies":64,"./csp-blocking":65,"./devtools":66,"./dnr-click-to-load":67,"./dnr-session-rule-id":70,"./dnr-user-allowlist":72,"./dnr-utils":73,"./email-utils":74,"./events/3p-tracking-cookie-blocking":76,"./events/privacy-icon-indicator":77,"./events/referrer-trimming":78,"./experiments":79,"./https":82,"./https-service":81,"./message-handlers":84,"./onboarding":86,"./settings":90,"./storage/https":92,"./storage/tds":93,"./tab-manager":94,"./trackers":96,"./utils":98,"./wrapper":99,"webextension-polyfill":11}],76:[function(require,module,exports){
"use strict";

var tabManager = require('../tab-manager');
var trackerutils = require('../tracker-utils');
var utils = require('../utils');
var devtools = require('../devtools');
var browserWrapper = require('../wrapper');
var manifestVersion = browserWrapper.getManifestVersion();
/**
 * Set of requestId that we saw where we expect the cookies to be blocked.
 * Used in MV3 to detect a cookie blocking gap caused by the limitations of DNR.
 *
 * Note: this is OK to keep in a variable because we only need to keep this data for the time
 * between to phases of the webRequest lifecycle for a given request (onHeadersReceived and onCompleted).
 * As this will be, in most cases, a fraction of a second, we don't expect loss of state due to
 * Service Worker restart to be an issue.
 */
var expectedSetCookieBlocked = new Set();
function shouldBlockHeaders(request, tab, requestIsTracker) {
  if (!tab.site.isFeatureEnabled('cookie')) {
    return false;
  }
  if (tab.site.specialDomainName) {
    return false; // main frame is a special page (e.g. extension page)
  }

  var cookieSettings = utils.getFeatureSettings('cookie');
  if (requestIsTracker && cookieSettings.trackerCookie !== 'enabled') {
    return false;
  }
  if (!requestIsTracker && cookieSettings.nonTrackerCookie !== 'enabled') {
    return false;
  }
  if (trackerutils.isFirstPartyByEntity(request.url, tab.url)) {
    return false;
  }
  return true;
}

/**
 * @param {{tabId: number, requestId: number, url: string, initiator: URL, type: string, responseHeaders: Array<{name: string, value:string}>}} request
 *
 * @returns {{responseHeaders: Array<{name: string, value:string}>} | undefined}
 */
function dropTracking3pCookiesFromResponse(request) {
  if (request.type === 'main_frame' || request.responseHeaders.findIndex(function (header) {
    return header.name.toLowerCase() === 'set-cookie';
  }) === -1) {
    return;
  }
  var tab = tabManager.get({
    tabId: request.tabId
  });
  var responseHeaders = request.responseHeaders;
  if (tab) {
    var requestIsTracker = trackerutils.isTracker(request.url);
    if (!shouldBlockHeaders(request, tab, requestIsTracker)) {
      return;
    }

    // Strip 3rd party cookie response header
    if (!utils.isCookieExcluded(request.url)) {
      var _tab$site;
      responseHeaders = responseHeaders.filter(function (header) {
        return header.name.toLowerCase() !== 'set-cookie';
      });
      devtools.postMessage(request.tabId, 'cookie', {
        action: 'block',
        kind: "set-cookie-".concat(requestIsTracker ? 'tracker' : 'non-tracker'),
        url: request.url,
        siteUrl: tab === null || tab === void 0 ? void 0 : (_tab$site = tab.site) === null || _tab$site === void 0 ? void 0 : _tab$site.url,
        requestId: request.requestId,
        type: request.type
      });
      if (manifestVersion === 2) {
        return {
          responseHeaders: responseHeaders
        };
      } else {
        expectedSetCookieBlocked.add(request.requestId);
      }
    }
  }
}

/**
 * @param {{tabId: number, requestId: number, url: string, initiator: URL, type: string, requestHeaders: Array<{name: string, value:string}>}} request
 *
 * @returns {{requestHeaders: Array<{name: string, value:string}>} | undefined}
 */
function dropTracking3pCookiesFromRequest(request) {
  if (request.type === 'main_frame' || request.requestHeaders.findIndex(function (header) {
    return header.name.toLowerCase() === 'cookie';
  }) === -1) {
    return;
  }
  var tab = tabManager.get({
    tabId: request.tabId
  });
  var requestHeaders = request.requestHeaders;
  if (tab) {
    var requestIsTracker = trackerutils.isTracker(request.url);
    if (!shouldBlockHeaders(request, tab, requestIsTracker)) {
      return;
    }

    // Strip 3rd party response header
    if (!utils.isCookieExcluded(request.url)) {
      var _tab$site2;
      requestHeaders = requestHeaders.filter(function (header) {
        return header.name.toLowerCase() !== 'cookie';
      });
      devtools.postMessage(request.tabId, 'cookie', {
        action: 'block',
        kind: "cookie-".concat(requestIsTracker ? 'tracker' : 'non-tracker'),
        url: request.url,
        siteUrl: tab === null || tab === void 0 ? void 0 : (_tab$site2 = tab.site) === null || _tab$site2 === void 0 ? void 0 : _tab$site2.url,
        requestId: request.requestId,
        type: request.type
      });
      if (manifestVersion === 2) {
        return {
          requestHeaders: requestHeaders
        };
      }
    }
  }
}
function validateSetCookieBlock(request) {
  if (request.type !== 'main_frame' && expectedSetCookieBlocked.has(request.requestId)) {
    var _request$responseHead;
    var cookieHeader = (_request$responseHead = request.responseHeaders) === null || _request$responseHead === void 0 ? void 0 : _request$responseHead.find(function (header) {
      return header.name.toLowerCase() === 'set-cookie';
    });
    if (chrome.cookies && cookieHeader) {
      // Unset the cookie that got set erroneously
      var cookieName = cookieHeader.value.split(';')[0].split('=')[0];
      chrome.cookies.remove({
        name: cookieName,
        url: request.url
      });
    }
    expectedSetCookieBlocked["delete"](request.requestId);
  }
}
module.exports = {
  dropTracking3pCookiesFromResponse: dropTracking3pCookiesFromResponse,
  dropTracking3pCookiesFromRequest: dropTracking3pCookiesFromRequest,
  validateSetCookieBlock: validateSetCookieBlock
};

},{"../devtools":66,"../tab-manager":94,"../tracker-utils":95,"../utils":98,"../wrapper":99}],77:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateActionIcon = updateActionIcon;
var constants = _interopRequireWildcard(require("../../../data/constants"));
var _wrapper = require("../wrapper");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * The 'browser action icon' action has 2 possible variants
 *
 * 1) Our regular Dax Icon
 * 2) Greyed-out Dax Icon (special state)
 *
 * @param {import("../classes/site")} site
 * @param {number} tabId
 * @returns {Promise<void>}
 */
function updateActionIcon(site, tabId) {
  // For the icon state, we consider 'protections enabled' to mean
  //    1) user has not manually added this site to their `allowlist`
  //    2) AND the 'contentBlocking' feature is enabled
  var protectionsEnabled = !site.allowlisted && site.isFeatureEnabled('contentBlocking');

  // Enabled: regular icon
  // Disabled: special state, greyed-out Dax
  var nextIcon = protectionsEnabled ? constants.iconPaths.regular : constants.iconPaths.withSpecialState;

  // now call out to the browser wrapper to actually change the icon
  return (0, _wrapper.setActionIcon)(nextIcon, tabId);
}

},{"../../../data/constants":38,"../wrapper":99}],78:[function(require,module,exports){
"use strict";

var tabManager = require('../tab-manager');
var trackerutils = require('../tracker-utils');
var utils = require('../utils');
var browserName = utils.getBrowserName();

/**
 * @typedef Referrer
 * @property {string} site
 *   The referrer URL.
 * @property {string} referrerHost
 *   The referrer host.
 * @property {string} referrer
 *   The truncated referrer.
 */

/**
 * @param {{tabId: number, url: string, requestHeaders: Array<{name: string, value:string}>}} e
 *
 * @returns {{requestHeaders: Array<{name: string, value:string}>} | { redirectUrl: URL } | undefined}
 */
module.exports = function limitReferrerData(e) {
  var _e$requestHeaders$fin;
  var referrer = (_e$requestHeaders$fin = e.requestHeaders.find(function (header) {
    return header.name.toLowerCase() === 'referer';
  })) === null || _e$requestHeaders$fin === void 0 ? void 0 : _e$requestHeaders$fin.value;
  if (!referrer) return;
  var tab = tabManager.get(e);

  // Firefox only - Check if this tab had a surrogate redirect request and if it will
  // likely be blocked by CORS (Origin header). Chrome surrogate redirects happen in onBeforeRequest.
  if (browserName === 'moz' && tab && tab.surrogates && tab.surrogates[e.url]) {
    var hasOrigin = e.requestHeaders.filter(function (h) {
      return h.name.match(/^origin$/i);
    });
    if (!hasOrigin.length) {
      var redirectUrl = tab.surrogates[e.url];
      // remove redirect entry for the tab
      delete tab.surrogates[e.url];
      return {
        redirectUrl: redirectUrl
      };
    }
  }
  if (!tab || !tab.site.isFeatureEnabled('referrer')) {
    return;
  }

  // Additional safe list and broken site list checks are included in the referrer evaluation
  var modifiedReferrer = trackerutils.truncateReferrer(referrer, e.url);
  if (!modifiedReferrer) {
    return;
  }
  var requestHeaders = e.requestHeaders.filter(function (header) {
    return header.name.toLowerCase() !== 'referer';
  });
  if (!!tab && (!tab.referrer || tab.referrer.site !== tab.site.url)) {
    tab.referrer = {
      site: tab.site.url,
      referrerHost: new URL(referrer).hostname,
      referrer: modifiedReferrer
    };
  }
  requestHeaders.push({
    name: 'referer',
    value: modifiedReferrer
  });
  return {
    requestHeaders: requestHeaders
  };
};

},{"../tab-manager":94,"../tracker-utils":95,"../utils":98}],79:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var settings = require('./settings');
var atbUtils = require('./atb-utils');
var retentionExperiments = require('../../data/experiments-out');
var ATB_FORMAT_RE = /(v\d+-\d(?:[a-z_]{2})?)$/;
var Experiment = /*#__PURE__*/function () {
  function Experiment() {
    _classCallCheck(this, Experiment);
    this.variant = '';
    this.atbVariant = '';
    this.activeExperiment = {};
  }
  _createClass(Experiment, [{
    key: "getVariant",
    value: function getVariant() {
      var atbVal = settings.getSetting('atb');
      if (atbVal && atbVal.match(ATB_FORMAT_RE) && atbVal[atbVal.length - 2].match(/[a-z]/i)) {
        this.variant = atbVal[atbVal.length - 2];
      } else {
        this.variant = '_';
      }
      return this.variant;
    }
  }, {
    key: "getATBVariant",
    value: function getATBVariant() {
      var atbVal = settings.getSetting('atb');
      if (atbVal && atbVal.match(ATB_FORMAT_RE) && atbVal[atbVal.length - 1].match(/[a-z]/i)) {
        this.atbVariant = atbVal[atbVal.length - 1];
      } else {
        this.atbVariant = '_';
      }
      return this.atbVariant;
    }
  }, {
    key: "setActiveExperiment",
    value: function setActiveExperiment() {
      var _this = this;
      settings.ready().then(this.getVariant.bind(this)).then(this.getATBVariant.bind(this)).then(function () {
        var currentExp = settings.getSetting('activeExperiment');
        _this.activeExperiment = retentionExperiments[_this.variant] || {};

        // special case for existing users that were in an experiment before
        // we added the active property
        if (currentExp && !Object.hasOwnProperty.call(currentExp, 'active')) {
          currentExp.active = _this.activeExperiment.active;
          settings.updateSetting('activeExperiment', currentExp);
        }

        // We already have an active experiemnt. Bail here to avoid overriding
        // any of the settings for this experiment.
        if (currentExp && currentExp.active === true && _this.activeExperiment.active === true) {
          return;
        }

        // clear out non-active experiments
        if (_this.activeExperiment.active !== true) {
          settings.updateSetting('activeExperiment', '');
          return;
        }
        settings.updateSetting('activeExperiment', _this.activeExperiment);
        if (_this.activeExperiment.name) {
          if (_this.activeExperiment.atbExperiments && _this.activeExperiment.atbExperiments[_this.atbVariant]) {
            _this.activeExperiment.settings = _this.activeExperiment.atbExperiments[_this.atbVariant].settings;
          }
          if (_this.activeExperiment.settings) {
            _this.applySettingsChanges();
          }
        }
      });
    }
  }, {
    key: "applySettingsChanges",
    value: function applySettingsChanges() {
      for (var setting in this.activeExperiment.settings) {
        settings.updateSetting(setting, this.activeExperiment.settings[setting]);
      }
    }
  }, {
    key: "getDaysSinceInstall",
    value: function getDaysSinceInstall() {
      var cohort = settings.getSetting('atb');
      if (!cohort) return false;
      var split = cohort.split('-');
      var majorVersion = split[0];
      var minorVersion = split[1];
      if (!majorVersion || !minorVersion) return;
      majorVersion = majorVersion.substring(1);

      // remove any atb variant that may be appended to the setting.
      minorVersion = minorVersion.replace(/[a-z_]/g, '');
      return atbUtils.getDaysBetweenCohorts({
        majorVersion: parseInt(majorVersion, 10),
        minorVersion: parseInt(minorVersion, 10)
      }, atbUtils.getCurrentATB());
    }
  }]);
  return Experiment;
}();
module.exports = new Experiment();

},{"../../data/experiments-out":41,"./atb-utils":46,"./settings":90}],80:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var tldts = require('tldts');
var utils = require('../utils');
var tabManager = require('../tab-manager');
var trackerutils = require('../tracker-utils');
var settings = require('../settings');
var _require = require('../devtools'),
  isActive = _require.isActive;
var constants = require('../../../data/constants');
var _require2 = require('../classes/legacy-tab-transfer'),
  LegacyTabTransfer = _require2.LegacyTabTransfer;
function getArgumentsObject(tabId, sender, documentUrl, sessionKey) {
  var tab = tabManager.get({
    tabId: tabId
  });
  if (!tab || !tab.url) {
    return null;
  }
  var tabClone = new LegacyTabTransfer(tab);
  // Clone site so we don't retain any site changes
  // @ts-ignore
  var site = tabClone.site;
  var referrer = (tab === null || tab === void 0 ? void 0 : tab.referrer) || '';
  var cookie = {};

  // Special case for iframes that are blank we check if it's also enabled
  if (sender.url === 'about:blank') {
    var aboutBlankEnabled = utils.getEnabledFeaturesAboutBlank(tab.url);
    site.enabledFeatures = site.enabledFeatures.filter(function (feature) {
      return aboutBlankEnabled.includes(feature);
    });
  }
  var featureSettings = {};
  var _iterator = _createForOfIteratorHelper(site.enabledFeatures),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var feature = _step.value;
      var featureSetting = utils.getFeatureSettings(feature);
      if (Object.keys(featureSetting).length) {
        featureSettings[feature] = featureSetting;
      }
    }

    // Extra contextual data required for cookie protection only send if is enabled here
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (tab.site.isFeatureEnabled('cookie')) {
    cookie = {
      isThirdParty: false,
      shouldBlock: false,
      tabRegisteredDomain: null,
      isTracker: false,
      isFrame: false
    };

    // determine the register domain of the sending tab
    var parsed = tldts.parse(tab.url);
    cookie.tabRegisteredDomain = parsed.domain === null ? parsed.hostname : parsed.domain;
    if (sender.frameId !== 0) {
      cookie.isFrame = true;
    }
    if (trackerutils.hasTrackerListLoaded()) {
      if (documentUrl && trackerutils.isTracker(documentUrl)) {
        cookie.isTracker = true;
      }
      cookie.isThirdParty = !trackerutils.isFirstPartyByEntity(documentUrl, tab.url);
    }
    cookie.shouldBlock = !utils.isCookieExcluded(documentUrl);
  }
  return {
    featureSettings: featureSettings,
    debug: isActive(tabId),
    cookie: cookie,
    globalPrivacyControlValue: settings.getSetting('GPC'),
    stringExemptionLists: utils.getBrokenScriptLists(),
    sessionKey: sessionKey,
    site: site,
    referrer: referrer,
    platform: constants.platform
  };
}
module.exports = getArgumentsObject;

},{"../../../data/constants":38,"../classes/legacy-tab-transfer":54,"../devtools":66,"../settings":90,"../tab-manager":94,"../tracker-utils":95,"../utils":98,"tldts":10}],81:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('./wrapper'),
  getFromSessionStorage = _require.getFromSessionStorage,
  setToSessionStorage = _require.setToSessionStorage;
var sha1 = require('../shared-utils/sha1');
// eslint-disable-next-line n/no-deprecated-api
var punycode = require('punycode');
var constants = require('../../data/constants');
var HASH_PREFIX_SIZE = 4;
var ONE_HOUR_MS = 60 * 60 * 1000;
var sessionStoreKey = 'httpsServiceCache';
var HTTPSService = /*#__PURE__*/function () {
  function HTTPSService() {
    var _this = this;
    _classCallCheck(this, HTTPSService);
    this._cache = new Map();
    this._activeRequests = new Map();
    // Pull cache values from session storage (for MV3)
    getFromSessionStorage(sessionStoreKey).then(function (values) {
      if (values) {
        _this._cache = new Map(values);
      }
    });
  }
  _createClass(HTTPSService, [{
    key: "_cacheResponse",
    value: function _cacheResponse(query, data, expires) {
      var expiryDate = new Date(expires).getTime();
      if (isNaN(expiryDate)) {
        console.warn("Expiry date is invalid: \"".concat(expires, "\", caching for 1h"));
        expiryDate = Date.now() + ONE_HOUR_MS;
      }
      this._cache.set(query, {
        expires: expiryDate,
        data: data
      });
      this._persistCache();
    }
  }, {
    key: "_persistCache",
    value: function _persistCache() {
      // put the cache in session storage, so when the background restarts (i.e. on MV3), we can reload the previous cache state.
      setToSessionStorage(sessionStoreKey, _toConsumableArray(this._cache.entries()));
    }
  }, {
    key: "_hostToHash",
    value: function _hostToHash(host) {
      return sha1(punycode.toASCII(host.toLowerCase()));
    }

    // added here for easy mocking in tests
  }, {
    key: "_fetch",
    value: function _fetch(url) {
      return fetch(url);
    }

    /**
     * @param {string} host
     * @returns {Boolean|null}
     */
  }, {
    key: "checkInCache",
    value: function checkInCache(host) {
      var hash = this._hostToHash(host);
      var query = hash.substr(0, HASH_PREFIX_SIZE);
      var result = this._cache.get(query);
      if (result) {
        return result.data.includes(hash);
      }
      return null;
    }

    /**
     * @param {string} host
     * @returns {Promise<Boolean>}
     */
  }, {
    key: "checkInService",
    value: function checkInService(host) {
      var _this2 = this;
      var hash = this._hostToHash(host);
      var query = hash.substring(0, HASH_PREFIX_SIZE);
      if (this._activeRequests.has(query)) {
        console.info("HTTPS Service: Request for ".concat(host, " is already in progress."));
        return this._activeRequests.get(query);
      }
      console.info("HTTPS Service: Requesting information for ".concat(host, " (").concat(hash, ")."));
      var queryUrl = new URL(constants.httpsService);
      queryUrl.searchParams.append('pv1', query);
      var request = this._fetch(queryUrl.toString()).then(function (response) {
        _this2._activeRequests["delete"](query);
        return response.json().then(function (data) {
          var expires = response.headers.get('expires');
          _this2._cacheResponse(query, data, expires);
          return data;
        });
      }).then(function (data) {
        var result = data.includes(hash);
        console.info("HTTPS Service: ".concat(host, " is").concat(result ? '' : ' not', " upgradable."));
        return result;
      })["catch"](function (e) {
        _this2._activeRequests["delete"](query);
        console.error('HTTPS Service: Failed contacting service: ' + e.message);
        throw e;
      });
      this._activeRequests.set(query, request);
      return request;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this._cache.clear();
      this._persistCache();
    }
  }, {
    key: "clearExpiredCache",
    value: function clearExpiredCache() {
      var _this3 = this;
      var now = Date.now();
      Array.from(this._cache.keys()).filter(function (key) {
        return _this3._cache.get(key).expires < now;
      }).forEach(function (key) {
        return _this3._cache["delete"](key);
      });
      this._persistCache();
    }
  }]);
  return HTTPSService;
}();
module.exports = new HTTPSService();

},{"../../data/constants":38,"../shared-utils/sha1":101,"./wrapper":99,"punycode":3}],82:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var settings = require('./settings');
var utils = require('./utils');
var BloomFilter = require('@duckduckgo/jsbloom').filter;
var httpsService = require('./https-service');
var tabManager = require('./tab-manager');
var browserWrapper = require('./wrapper');
var tldts = require('tldts');
var _require = require('./dnr-smarter-encryption'),
  addSmarterEncryptionSessionRule = _require.addSmarterEncryptionSessionRule;
// as defined in https://tools.ietf.org/html/rfc6761
var PRIVATE_TLDS = ['example', 'invalid', 'localhost', 'test'];
var manifestVersion = browserWrapper.getManifestVersion();
function base64ToUint8Array(base64) {
  var binaryString = globalThis.atob(base64);
  var len = binaryString.length;
  var bytes = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
var HTTPS = /*#__PURE__*/function () {
  function HTTPS() {
    _classCallCheck(this, HTTPS);
    // Store multiple upgrade / don't upgrade bloom filters
    this.upgradeBloomFilters = new Map();
    this.dontUpgradeBloomFilters = new Map();
    // Upgrade / don't upgrade safelists for the bloom filters
    this.dontUpgradeList = [];
    this.upgradeList = [];
    this.isReady = false;
  }

  // Sets a list by type and name. This is data that
  // is gathered from HTTPSStorage.
  // 'upgrade bloom filter' and 'don't upgrade bloom filter' are assumed to be bloom filters
  // 'upgrade safelist' and 'don't upgrade safelist' should be arrays
  _createClass(HTTPS, [{
    key: "setLists",
    value: function setLists(lists) {
      var _this = this;
      try {
        lists.forEach(function (list) {
          if (!list.data) {
            throw new Error("HTTPS: ".concat(list.name, " missing data"));
          }
          if (list.type === 'upgrade bloom filter') {
            _this.upgradeBloomFilters.set(list.name, _this.createBloomFilter(list));
          } else if (list.type === 'don\'t upgrade bloom filter') {
            _this.dontUpgradeBloomFilters.set(list.name, _this.createBloomFilter(list));
          } else if (list.type === 'upgrade safelist') {
            _this.upgradeList = list.data;
          } else if (list.type === 'don\'t upgrade safelist') {
            _this.dontUpgradeList = list.data;
          }
        });
        this.isReady = true;
        console.log('HTTPS: is ready');
      } catch (e) {
        // a failed setLists update will turn https off
        // validation of the data should happen before calling setLists
        this.isReady = false;
        console.log('HTTPS: setLists error, not ready');
        console.log(e);
      }
    }

    // create a new BloomFilter
    // filterData is assumed to be base64 encoded 8 bit typed array
  }, {
    key: "createBloomFilter",
    value: function createBloomFilter(filterData) {
      var bloom = new BloomFilter(filterData.totalEntries, filterData.errorRate);
      var buffer = base64ToUint8Array(filterData.data);
      bloom.importData(buffer);
      return bloom;
    }

    /**
     * @param {string} url either domain (example.com) or a full URL (http://example.com/about)
     * @returns {null|boolean|Promise<boolean>} returns true if host can be upgraded, false if it shouldn't be upgraded and a promise if we don't know yet and we are checking against a remote service
     */
  }, {
    key: "canUpgradeUrl",
    value: function canUpgradeUrl(url) {
      var parsedUrl = tldts.parse(url);
      var host = parsedUrl.hostname;
      if (!host) {
        console.warn('HTTPS: Error parsing out hostname', url);
        return false;
      }
      if (parsedUrl.isIp) {
        console.warn('HTTPS: hostname is an IP - host is not upgradable', host);
        return false;
      }

      // @ts-ignore
      if (host === 'localhost' || PRIVATE_TLDS.includes(parsedUrl.publicSuffix)) {
        console.warn('HTTPS: localhost or local TLD - host is not upgradable', host);
        return false;
      }
      if (!this.isReady) {
        console.warn('HTTPS: not ready');
        return null;
      }
      if (this.dontUpgradeList.includes(host)) {
        console.log('HTTPS: Safelist - host is not upgradable', host);
        return false;
      }
      if (this.upgradeList.includes(host)) {
        console.log('HTTPS: Safelist - host is upgradable', host);
        return true;
      }
      var foundInDontUpgradeBloomFilters = Array.from(this.dontUpgradeBloomFilters.values()).some(function (list) {
        return list.checkEntry(host);
      });
      if (foundInDontUpgradeBloomFilters) {
        console.log('HTTPS: Bloom filter - host is not upgradable', host);
        return false;
      }
      var foundInUpgradeBloomFilters = Array.from(this.upgradeBloomFilters.values()).some(function (list) {
        return list.checkEntry(host);
      });
      if (foundInUpgradeBloomFilters) {
        console.log('HTTPS: Bloom filter - host is upgradable', host);
        return true;
      }
      var foundInServiceCache = httpsService.checkInCache(host);
      if (foundInServiceCache === true && manifestVersion === 3) {
        // This domain should be upgraded and is not in the bloom filter.
        // Ensure that we have an upgrade rule in place for it for this session
        addSmarterEncryptionSessionRule(host);
      }
      if (foundInServiceCache !== null) {
        console.log("HTTPS: Service cache - host is".concat(foundInServiceCache ? '' : ' not', " upgradable"), host);
        return foundInServiceCache;
      }
      var serviceCheck = httpsService.checkInService(host);
      if (manifestVersion === 3) {
        // Once we get the result from the service, ensure we add a session upgrade rule
        serviceCheck.then(function (result) {
          if (result) {
            addSmarterEncryptionSessionRule(host);
          }
        }, function (e) {});
      }
      return serviceCheck;
    }
  }, {
    key: "downgradeTab",
    value: function downgradeTab(_ref) {
      var tabId = _ref.tabId,
        expectedUrl = _ref.expectedUrl,
        targetUrl = _ref.targetUrl;
      // make sure that tab still has expected url (user could have navigated away or been redirected)
      var tab = tabManager.get({
        tabId: tabId
      });
      if (tab.url !== expectedUrl && tab.url !== targetUrl) {
        console.warn("HTTPS: Not downgrading, expected and actual tab URLs don't match: ".concat(expectedUrl, " vs ").concat(tab.url));
      } else {
        console.log("HTTPS: Downgrading from ".concat(tab.url, " to ").concat(targetUrl));
        browserWrapper.changeTabURL(tabId, targetUrl);
      }
    }
  }, {
    key: "getUpgradedUrl",
    value: function getUpgradedUrl(reqUrl, tab, isMainFrame, isPost) {
      var _this2 = this;
      if (!this.isReady) {
        console.warn('HTTPS: not ready');
        return reqUrl;
      }

      // Obey global settings (options page)
      if (!settings.getSetting('httpsEverywhereEnabled')) {
        return reqUrl;
      }

      // Skip upgrading sites that have been disabled by user or through broken sites
      if (!tab || !tab.site.isFeatureEnabled('https')) {
        return reqUrl;
      }
      var urlObj;
      try {
        urlObj = new URL(reqUrl);
      } catch (e) {
        // invalid URL
        console.warn("HTTPS: Invalid url - ".concat(reqUrl));
        return reqUrl;
      }

      // Only deal with http calls
      if (!['http:', 'ws:'].includes(urlObj.protocol)) {
        return reqUrl;
      }
      var isUpgradable = this.canUpgradeUrl(reqUrl);

      // request is not upgradable or extension is not ready yet
      if (isUpgradable === false || isUpgradable === null) {
        return reqUrl;
      }

      // create an upgraded URL
      urlObj.protocol = urlObj.protocol === 'http:' ? 'https:' : 'wss:';
      var upgradedUrl = urlObj.toString();

      // request is upgradable
      if (isUpgradable === true) {
        return upgradedUrl;
      }

      /**
       * If we got to this point hostname was not recognized by our bloom filters and safelists,
       * we are waiting for a response from our remote service
       */
      if (!(isUpgradable instanceof Promise)) {
        console.error('HTTPS: Fatal error - unexpected type of isUpgradable');
        return reqUrl;
      }

      // if this is a non-navigational request (subresource request) let it continue over HTTP
      if (!isMainFrame) {
        return reqUrl;
      }

      // if this is a POST navigational request and browser doesn't support async blocking
      // let it continue over HTTP to avoid data loss
      if (isMainFrame && isPost && !utils.getAsyncBlockingSupport()) {
        return reqUrl;
      }

      // if async blocking is available:
      // we hold the request until we hear back from our service
      if (utils.getAsyncBlockingSupport()) {
        return isUpgradable.then(function (result) {
          if (result) {
            tab.mainFrameUpgraded = true;
            _this2.incrementUpgradeCount('totalUpgrades');
          }
          return result ? upgradedUrl : reqUrl;
        })["catch"](function (e) {
          console.error('HTTPS: Error connecting to the HTTPS service: ' + e.message);
          return upgradedUrl;
        });
      } else {
        // if async blocking is NOT available:
        // we upgrade it proactively while waiting for a response from a remote service
        isUpgradable.then(function (result) {
          if (result === false) {
            console.info('HTTPS: Remote check returned - downgrade request', reqUrl);
            _this2.downgradeTab({
              tabId: tab.id,
              expectedUrl: upgradedUrl,
              targetUrl: reqUrl
            });
          } else {
            console.info('HTTPS: Remote check returned - let request continue', reqUrl);
          }
        })["catch"](function (e) {
          console.error('HTTPS: Error connecting to the HTTPS service: ' + e.message);
        });
        tab.mainFrameUpgraded = true;
        this.incrementUpgradeCount('totalUpgrades');
        if (manifestVersion === 3) {
          // returning from webRequest won't cause the upgrade, so we have to do it manually with webNavigation
          browserWrapper.changeTabURL(tab.id, upgradedUrl);
        }
        return upgradedUrl;
      }
    }

    // Increment upgrade or failed upgrade settings
  }, {
    key: "incrementUpgradeCount",
    value: function incrementUpgradeCount(setting) {
      var value = parseInt(settings.getSetting(setting)) || 0;
      value += 1;
      settings.updateSetting(setting, value);
    }
  }]);
  return HTTPS;
}();
module.exports = new HTTPS();

},{"./dnr-smarter-encryption":71,"./https-service":81,"./settings":90,"./tab-manager":94,"./utils":98,"./wrapper":99,"@duckduckgo/jsbloom":1,"tldts":10}],83:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var browserWrapper = require('./wrapper');
function JSONfromLocalFile(path) {
  return loadExtensionFile({
    url: path,
    returnType: 'json'
  });
}
function JSONfromExternalFile(urlString) {
  return loadExtensionFile({
    url: urlString,
    returnType: 'json',
    source: 'external'
  });
}
function url(urlString) {
  return loadExtensionFile({
    url: urlString,
    source: 'external'
  });
}

/*
 * Params:
 *  - url: request URL
 *  - source: requests are internal by default. set source to 'external' for non-extension URLs
 *  - etag: set an if-none-match header
 */
function loadExtensionFile(_x) {
  return _loadExtensionFile.apply(this, arguments);
}
function _loadExtensionFile() {
  _loadExtensionFile = _asyncToGenerator(function* (params) {
    var headers = new Headers();
    var urlString = params.url;
    if (params.source === 'external') {
      if (yield browserWrapper.getFromSessionStorage('dev')) {
        if (urlString.indexOf('?') > -1) {
          urlString += '&';
        } else {
          urlString += '?';
        }
        urlString += 'test=1';
      }
      if (params.etag) {
        headers.append('If-None-Match', params.etag);
      }
    } else {
      urlString = browserWrapper.getExtensionURL(urlString);
    }
    var rej;
    var timeoutPromise = new Promise(function (resolve, reject) {
      rej = reject;
    });
    // @ts-ignore
    var fetchTimeout = setTimeout(rej, params.timeout || 30000);
    var fetchResult = fetch(urlString, {
      method: 'GET',
      headers: headers
    }).then( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (response) {
        clearTimeout(fetchTimeout);
        var status = response.status;
        var etag = response.headers.get('etag');
        var date = response.headers.get('Date');
        var data;
        if (status === 200) {
          if (params.returnType === 'json') {
            data = yield response.json();
          } else if (params.returnType === 'arraybuffer') {
            data = yield response.arrayBuffer();
          } else {
            data = yield response.text();
          }
          return {
            status: status,
            date: date,
            etag: etag,
            data: data
          };
        } else if (status === 304) {
          console.log("".concat(urlString, " returned 304, resource not changed"));
          return {
            status: status,
            date: date,
            etag: etag
          };
        } else {
          throw new Error("".concat(urlString, " returned ").concat(response.status));
        }
      });
      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
    return Promise.race([timeoutPromise, fetchResult]);
  });
  return _loadExtensionFile.apply(this, arguments);
}
module.exports = {
  loadExtensionFile: loadExtensionFile,
  JSONfromLocalFile: JSONfromLocalFile,
  JSONfromExternalFile: JSONfromExternalFile,
  url: url
};

},{"./wrapper":99}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addUserData = addUserData;
exports.allowlistOptIn = allowlistOptIn;
exports.debuggerMessage = debuggerMessage;
exports.getAddresses = void 0;
exports.getAlias = getAlias;
exports.getBrowser = getBrowser;
exports.getClickToLoadState = getClickToLoadState;
exports.getCurrentTab = getCurrentTab;
exports.getEmailProtectionCapabilities = getEmailProtectionCapabilities;
exports.getExtensionVersion = getExtensionVersion;
exports.getIncontextSignupDismissedAt = getIncontextSignupDismissedAt;
exports.getListContents = getListContents;
exports.getPrivacyDashboardData = getPrivacyDashboardData;
exports.getSetting = getSetting;
exports.getTopBlocked = getTopBlocked;
exports.getTopBlockedByPages = getTopBlockedByPages;
exports.getUserData = getUserData;
exports.getYouTubeVideoDetails = getYouTubeVideoDetails;
exports.isClickToLoadYoutubeEnabled = isClickToLoadYoutubeEnabled;
exports.logout = logout;
exports.openOptions = openOptions;
exports.openShareFeedbackPage = openShareFeedbackPage;
exports.refreshAlias = refreshAlias;
exports.registeredContentScript = registeredContentScript;
exports.reloadList = reloadList;
exports.removeUserData = removeUserData;
exports.resetTrackersData = resetTrackersData;
exports.search = search;
exports.sendJSPixel = void 0;
exports.setIncontextSignupPermanentlyDismissedAt = setIncontextSignupPermanentlyDismissedAt;
exports.setList = setList;
exports.setListContents = setListContents;
exports.setLists = setLists;
exports.setYoutubePreviewsEnabled = setYoutubePreviewsEnabled;
exports.submitBrokenSiteReport = submitBrokenSiteReport;
exports.unblockClickToLoadContent = unblockClickToLoadContent;
exports.updateSetting = updateSetting;
exports.updateYouTubeCTLAddedFlag = updateYouTubeCTLAddedFlag;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _privacyDashboardData = require("./classes/privacy-dashboard-data");
var _brokenSiteReport = require("./broken-site-report");
var _parseUserAgentString = _interopRequireDefault(require("../shared-utils/parse-user-agent-string"));
var _wrapper = require("./wrapper");
var _utils = require("./utils");
var _dnrClickToLoad = require("./dnr-click-to-load");
var _tds = _interopRequireDefault(require("./storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var _require = require('tldts'),
  getDomain = _require.getDomain;
var utils = require('./utils');
var settings = require('./settings');
var tabManager = require('./tab-manager');
var trackers = require('./trackers');
var constants = require('../../data/constants');
var Companies = require('./companies');
var browserName = utils.getBrowserName();
var devtools = require('./devtools');
var browserWrapper = require('./wrapper');
var getArgumentsObject = require('./helpers/arguments-object');
function registeredContentScript(_x, _x2, _x3) {
  return _registeredContentScript.apply(this, arguments);
}
function _registeredContentScript() {
  _registeredContentScript = _asyncToGenerator(function* (options, sender, req) {
    var sessionKey = yield utils.getSessionKey();
    var argumentsObject = getArgumentsObject(sender.tab.id, sender, (options === null || options === void 0 ? void 0 : options.documentUrl) || req.documentUrl, sessionKey);
    if (!argumentsObject) {
      // No info for the tab available, do nothing.
      return;
    }
    return argumentsObject;
  });
  return _registeredContentScript.apply(this, arguments);
}
function resetTrackersData() {
  return Companies.resetData();
}
function getExtensionVersion() {
  return browserWrapper.getExtensionVersion();
}

/**
 * This is used from the options page - to manually update the user allow list
 *
 * @param options
 */
function setList(options) {
  tabManager.setList(options);
}

/**
 * This is used by the Dashboard to update the allow/deny lists, close the popup + reload
 *
 * @param {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').SetListOptions} options
 */
function setLists(_x4) {
  return _setLists.apply(this, arguments);
}
function _setLists() {
  _setLists = _asyncToGenerator(function* (options) {
    var _iterator = _createForOfIteratorHelper(options.lists),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var listItem = _step.value;
        tabManager.setList(listItem);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    try {
      (0, _wrapper.notifyPopup)({
        closePopup: true
      });
      (0, _utils.reloadCurrentTab)();
    } catch (e) {
      console.error('Error trying to reload+refresh following `setLists` message', e);
    }
  });
  return _setLists.apply(this, arguments);
}
function allowlistOptIn(optInData) {
  tabManager.setGlobalAllowlist('allowlistOptIn', optInData.domain, optInData.value);
}

// popup will ask for the browser type then it is created
function getBrowser() {
  return browserName;
}
function openOptions() {
  if (browserName === 'moz') {
    _webextensionPolyfill["default"].tabs.create({
      url: (0, _wrapper.getExtensionURL)('/html/options.html')
    });
  } else {
    _webextensionPolyfill["default"].runtime.openOptionsPage();
  }
}

/**
 * Only the dashboard sends this message, so we import the types from there.
 * @param {import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').BreakageReportRequest} breakageReport
 * @returns {Promise<void>}
 */
function submitBrokenSiteReport(_x5) {
  return _submitBrokenSiteReport.apply(this, arguments);
}
/**
 * @param tabId
 * @returns {Promise<import("./classes/tab")>}
 */
function _submitBrokenSiteReport() {
  _submitBrokenSiteReport = _asyncToGenerator(function* (breakageReport) {
    var category = breakageReport.category,
      description = breakageReport.description;
    var currentTab = yield utils.getCurrentTab();
    if (!(currentTab !== null && currentTab !== void 0 && currentTab.id)) {
      console.error('could not access the current tab...');
      return;
    }
    var tab = yield getTab(currentTab.id);
    if (!tab) {
      console.error('cannot access current tab with ID ' + currentTab.id);
      return;
    }
    var tsd = settings.getSetting('tds-etag');
    return (0, _brokenSiteReport.breakageReportForTab)(tab, tsd, category, description);
  });
  return _submitBrokenSiteReport.apply(this, arguments);
}
function getTab(_x6) {
  return _getTab.apply(this, arguments);
}
/**
 * This message is here to ensure the privacy dashboard can render
 * from a single call to the extension.
 *
 * Currently, it will collect data for the current tab and email protection
 * user data.
 */
function _getTab() {
  _getTab = _asyncToGenerator(function* (tabId) {
    // Await for storage to be ready; this happens on service worker closing mostly.
    yield settings.ready();
    yield _tds["default"].ready('config');
    return tabManager.getOrRestoreTab(tabId);
  });
  return _getTab.apply(this, arguments);
}
function getPrivacyDashboardData(_x7) {
  return _getPrivacyDashboardData.apply(this, arguments);
}
function _getPrivacyDashboardData() {
  _getPrivacyDashboardData = _asyncToGenerator(function* (options) {
    var tabId = options.tabId;
    if (tabId === null) {
      var currentTab = yield utils.getCurrentTab();
      if (!(currentTab !== null && currentTab !== void 0 && currentTab.id)) {
        throw new Error('could not get the current tab...');
      }
      tabId = currentTab === null || currentTab === void 0 ? void 0 : currentTab.id;
    }
    var tab = yield getTab(tabId);
    if (!tab) throw new Error('unreachable - cannot access current tab with ID ' + tabId);
    var userData = settings.getSetting('userData');
    return (0, _privacyDashboardData.dashboardDataFromTab)(tab, userData);
  });
  return _getPrivacyDashboardData.apply(this, arguments);
}
function getTopBlockedByPages(options) {
  return Companies.getTopBlockedByPages(options);
}

/**
 * @typedef getClickToLoadStateResponse
 * @property {boolean} devMode
 *   True if developer mode is enabled (e.g. this is a development build or a
 *   test run), false if this is a release build.
 * @property {boolean} youtubePreviewsEnabled
 *   True if the user has enabled YouTube video previews, false otherwise.
 */

/**
 * Returns the current state of the Click to Load feature.
 * @returns {Promise<getClickToLoadStateResponse>}
 */
function getClickToLoadState() {
  return _getClickToLoadState.apply(this, arguments);
}
function _getClickToLoadState() {
  _getClickToLoadState = _asyncToGenerator(function* () {
    var devMode = (yield browserWrapper.getFromSessionStorage('dev')) || false;
    yield settings.ready();
    var youtubePreviewsEnabled = (yield settings.getSetting('youtubePreviewsEnabled')) || false;
    return {
      devMode: devMode,
      youtubePreviewsEnabled: youtubePreviewsEnabled
    };
  });
  return _getClickToLoadState.apply(this, arguments);
}
function getYouTubeVideoDetails(_x8) {
  return _getYouTubeVideoDetails.apply(this, arguments);
}
function _getYouTubeVideoDetails() {
  _getYouTubeVideoDetails = _asyncToGenerator(function* (videoURL) {
    var endpointURL = new URL('https://www.youtube.com/oembed?format=json');
    var parsedVideoURL = new URL(videoURL);
    var playlistID = parsedVideoURL.searchParams.get('list');
    var videoId = parsedVideoURL.pathname.split('/').pop();
    if (playlistID) {
      parsedVideoURL.hostname = endpointURL.hostname;
      endpointURL.searchParams.set('url', parsedVideoURL.href);
    } else {
      endpointURL.searchParams.set('url', 'https://youtu.be/' + videoId);
    }
    try {
      var youTubeVideoResponse = yield fetch(endpointURL.href, {
        referrerPolicy: 'no-referrer',
        credentials: 'omit'
      }).then(function (response) {
        return response.json();
      });
      var title = youTubeVideoResponse.title,
        previewImage = youTubeVideoResponse.thumbnail_url;
      return {
        status: 'success',
        videoURL: videoURL,
        title: title,
        previewImage: previewImage
      };
    } catch (e) {
      return {
        status: 'failed',
        videoURL: videoURL
      };
    }
  });
  return _getYouTubeVideoDetails.apply(this, arguments);
}
function getCurrentTab() {
  return utils.getCurrentTab();
}
function unblockClickToLoadContent(_x9, _x10) {
  return _unblockClickToLoadContent.apply(this, arguments);
}
function _unblockClickToLoadContent() {
  _unblockClickToLoadContent = _asyncToGenerator(function* (data, sender) {
    var tab = tabManager.get({
      tabId: sender.tab.id
    });
    if (!tab.disabledClickToLoadRuleActions.includes(data.action)) {
      tab.disabledClickToLoadRuleActions.push(data.action);
    }
    if (browserWrapper.getManifestVersion() === 3) {
      yield (0, _dnrClickToLoad.ensureClickToLoadRuleActionDisabled)(data.action, tab);
    }
  });
  return _unblockClickToLoadContent.apply(this, arguments);
}
function updateYouTubeCTLAddedFlag(value, sender) {
  var tab = tabManager.get({
    tabId: sender.tab.id
  });
  tab.ctlYouTube = Boolean(value);
}
function setYoutubePreviewsEnabled(value, sender) {
  return updateSetting({
    name: 'youtubePreviewsEnabled',
    value: value
  });
}
function updateSetting(_x11) {
  return _updateSetting.apply(this, arguments);
}
function _updateSetting() {
  _updateSetting = _asyncToGenerator(function* (_ref) {
    var name = _ref.name,
      value = _ref.value;
    yield settings.ready();
    settings.updateSetting(name, value);
    utils.sendAllTabsMessage({
      messageType: "ddg-settings-".concat(name),
      value: value
    });
    return {
      messageType: "ddg-settings-".concat(name),
      value: value
    };
  });
  return _updateSetting.apply(this, arguments);
}
function getSetting(_x12) {
  return _getSetting.apply(this, arguments);
}
function _getSetting() {
  _getSetting = _asyncToGenerator(function* (_ref2) {
    var name = _ref2.name;
    yield settings.ready();
    return settings.getSetting(name);
  });
  return _getSetting.apply(this, arguments);
}
var _require2 = require('./email-utils'),
  isValidToken = _require2.isValidToken,
  isValidUsername = _require2.isValidUsername,
  getAddresses = _require2.getAddresses,
  sendJSPixel = _require2.sendJSPixel,
  fetchAlias = _require2.fetchAlias,
  showContextMenuAction = _require2.showContextMenuAction,
  hideContextMenuAction = _require2.hideContextMenuAction;
exports.sendJSPixel = sendJSPixel;
exports.getAddresses = getAddresses;
function getAlias() {
  var userData = settings.getSetting('userData');
  return {
    alias: userData === null || userData === void 0 ? void 0 : userData.nextAlias
  };
}

/**
 * @returns {Promise<import('@duckduckgo/privacy-dashboard/schema/__generated__/schema.types').RefreshAliasResponse>}
 */
function refreshAlias() {
  return _refreshAlias.apply(this, arguments);
}
function _refreshAlias() {
  _refreshAlias = _asyncToGenerator(function* () {
    yield fetchAlias();
    return getAddresses();
  });
  return _refreshAlias.apply(this, arguments);
}
function getTopBlocked(options) {
  return Companies.getTopBlocked(options);
}
function isExpectedSender(sender) {
  try {
    var domain = getDomain(sender.url);
    var _URL = new URL(sender.url),
      pathname = _URL.pathname;
    return domain === 'duckduckgo.com' && pathname.startsWith('/email');
  } catch (_unused) {
    return false;
  }
}
function getEmailProtectionCapabilities(_, sender) {
  if (!isExpectedSender(sender)) return;
  return {
    addUserData: true,
    getUserData: true,
    removeUserData: true
  };
}
function getIncontextSignupDismissedAt() {
  var permanentlyDismissedAt = settings.getSetting('incontextSignupPermanentlyDismissedAt');
  var isInstalledRecently = utils.isInstalledWithinDays(3);
  return {
    success: {
      permanentlyDismissedAt: permanentlyDismissedAt,
      isInstalledRecently: isInstalledRecently
    }
  };
}
function setIncontextSignupPermanentlyDismissedAt(_ref3) {
  var value = _ref3.value;
  settings.updateSetting('incontextSignupPermanentlyDismissedAt', value);
}

// Get user data to be used by the email web app settings page. This includes
// username, last alias, and a token for generating additional aliases.
function getUserData(_x13, _x14) {
  return _getUserData.apply(this, arguments);
}
function _getUserData() {
  _getUserData = _asyncToGenerator(function* (_, sender) {
    if (!isExpectedSender(sender)) return;
    yield settings.ready();
    var userData = settings.getSetting('userData');
    if (userData) {
      return userData;
    } else {
      return {
        error: 'Something seems wrong with the user data'
      };
    }
  });
  return _getUserData.apply(this, arguments);
}
function addUserData(_x15, _x16) {
  return _addUserData.apply(this, arguments);
}
function _addUserData() {
  _addUserData = _asyncToGenerator(function* (userData, sender) {
    var userName = userData.userName,
      token = userData.token;
    if (!isExpectedSender(sender)) return;
    var sendDdgUserReady = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* () {
        var tabs = yield _webextensionPolyfill["default"].tabs.query({});
        tabs.forEach(function (tab) {
          return utils.sendTabMessage(tab.id, {
            type: 'ddgUserReady'
          });
        });
      });
      return function sendDdgUserReady() {
        return _ref6.apply(this, arguments);
      };
    }();
    yield settings.ready();
    var _ref7 = settings.getSetting('userData') || {},
      existingToken = _ref7.existingToken;

    // If the user is already registered, just notify tabs that we're ready
    if (existingToken === token) {
      sendDdgUserReady();
      return {
        success: true
      };
    }

    // Check general data validity
    if (isValidUsername(userName) && isValidToken(token)) {
      settings.updateSetting('userData', userData);
      // Once user is set, fetch the alias and notify all tabs
      var response = yield fetchAlias();
      if (response && 'error' in response) {
        return {
          error: response.error.message
        };
      }
      sendDdgUserReady();
      showContextMenuAction();
      return {
        success: true
      };
    } else {
      return {
        error: 'Something seems wrong with the user data'
      };
    }
  });
  return _addUserData.apply(this, arguments);
}
function removeUserData(_x17, _x18) {
  return _removeUserData.apply(this, arguments);
}
function _removeUserData() {
  _removeUserData = _asyncToGenerator(function* (_, sender) {
    if (!isExpectedSender(sender)) return;
    yield logout();
  });
  return _removeUserData.apply(this, arguments);
}
function logout() {
  return _logout.apply(this, arguments);
}
function _logout() {
  _logout = _asyncToGenerator(function* () {
    settings.updateSetting('userData', {});
    settings.updateSetting('lastAddressUsedAt', '');
    // Broadcast the logout to all tabs
    var tabs = yield _webextensionPolyfill["default"].tabs.query({});
    tabs.forEach(function (tab) {
      utils.sendTabMessage(tab.id, {
        type: 'logout'
      });
    });
    hideContextMenuAction();
  });
  return _logout.apply(this, arguments);
}
function getListContents(list) {
  return {
    data: _tds["default"].getSerializableList(list),
    etag: settings.getSetting("".concat(list, "-etag")) || ''
  };
}

/**
 * Manually override the value of a list
 * @param {{ name: string, value: object}} list value
 */
function setListContents(_x19) {
  return _setListContents.apply(this, arguments);
}
function _setListContents() {
  _setListContents = _asyncToGenerator(function* (_ref4) {
    var name = _ref4.name,
      value = _ref4.value;
    var parsed = _tds["default"].parsedata(name, value);
    _tds["default"][name] = parsed;
    trackers.setLists([{
      name: name,
      data: parsed
    }]);
    // create an etag hash based on the content
    var hash = yield crypto.subtle.digest('SHA-256', new TextEncoder().encode(JSON.stringify(parsed)));
    var etag = _toConsumableArray(new Uint8Array(hash)).map(function (x) {
      return x.toString(16).padStart(2, '0');
    }).join('');
    settings.updateSetting("".concat(name, "-lastUpdate"), Date.now());
    settings.updateSetting("".concat(name, "-etag"), etag);
    yield _tds["default"]._internalOnListUpdate(name, value);
    return etag;
  });
  return _setListContents.apply(this, arguments);
}
function reloadList(_x20) {
  return _reloadList.apply(this, arguments);
}
function _reloadList() {
  _reloadList = _asyncToGenerator(function* (listName) {
    var list = constants.tdsLists.find(function (l) {
      return l.name === listName;
    });
    if (list) {
      trackers.setLists([yield _tds["default"].getList(list)]);
    }
  });
  return _reloadList.apply(this, arguments);
}
function debuggerMessage(message, sender) {
  var _sender$tab;
  devtools.postMessage((_sender$tab = sender.tab) === null || _sender$tab === void 0 ? void 0 : _sender$tab.id, message.action, message.message);
}
function search(_ref5) {
  var term = _ref5.term;
  var browserInfo = (0, _parseUserAgentString["default"])();
  if (browserInfo !== null && browserInfo !== void 0 && browserInfo.os) {
    var url = new URL('https://duckduckgo.com');
    url.searchParams.set('q', term);
    url.searchParams.set('bext', browserInfo.os + 'cr');
    _webextensionPolyfill["default"].tabs.create({
      url: url.toString()
    });
  }
}
function openShareFeedbackPage() {
  return browserWrapper.openExtensionPage('/html/feedback.html');
}
function isClickToLoadYoutubeEnabled() {
  return _isClickToLoadYoutubeEnabled.apply(this, arguments);
}
function _isClickToLoadYoutubeEnabled() {
  _isClickToLoadYoutubeEnabled = _asyncToGenerator(function* () {
    var _tdsStorage$config, _tdsStorage$config$fe, _tdsStorage$config$fe2, _tdsStorage$config$fe3, _tdsStorage$config$fe4;
    yield _tds["default"].ready('config');
    return (0, _utils.isFeatureEnabled)('clickToLoad') && (_tds["default"] === null || _tds["default"] === void 0 ? void 0 : (_tdsStorage$config = _tds["default"].config) === null || _tdsStorage$config === void 0 ? void 0 : (_tdsStorage$config$fe = _tdsStorage$config.features) === null || _tdsStorage$config$fe === void 0 ? void 0 : (_tdsStorage$config$fe2 = _tdsStorage$config$fe.clickToLoad) === null || _tdsStorage$config$fe2 === void 0 ? void 0 : (_tdsStorage$config$fe3 = _tdsStorage$config$fe2.settings) === null || _tdsStorage$config$fe3 === void 0 ? void 0 : (_tdsStorage$config$fe4 = _tdsStorage$config$fe3.Youtube) === null || _tdsStorage$config$fe4 === void 0 ? void 0 : _tdsStorage$config$fe4.state) === 'enabled';
  });
  return _isClickToLoadYoutubeEnabled.apply(this, arguments);
}

},{"../../data/constants":38,"../shared-utils/parse-user-agent-string":100,"./broken-site-report":50,"./classes/privacy-dashboard-data":55,"./companies":64,"./devtools":66,"./dnr-click-to-load":67,"./email-utils":74,"./helpers/arguments-object":80,"./settings":90,"./storage/tds":93,"./tab-manager":94,"./trackers":96,"./utils":98,"./wrapper":99,"tldts":10,"webextension-polyfill":11}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NewTabTrackerStats = void 0;
exports.mv2Redirect = mv2Redirect;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _constants = _interopRequireDefault(require("../../data/constants"));
var browserWrapper = _interopRequireWildcard(require("./wrapper.js"));
var _tds = _interopRequireDefault(require("./storage/tds"));
var _beforeRequest = require("./before-request.js");
var _utils = require("@duckduckgo/ddg2dnr/lib/utils");
var _rulePriorities = require("@duckduckgo/ddg2dnr/lib/rulePriorities");
var _dnrUtils = require("./dnr-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _constants$trackerSta = _constants["default"].trackerStats.events,
  incoming = _constants$trackerSta.incoming,
  outgoing = _constants$trackerSta.outgoing;
var clientPortName = _constants["default"].trackerStats.clientPortName;

/**
 * The extension-specific interface to tracker stats.
 *
 * This class handles all interaction with the extension like event handlers, alarms etc.
 *
 * Example:
 *
 * ```js
 * const stats = new TrackerStats();
 * const newtab = new NewTabTrackerStats(stats)
 *
 * await newtab.restoreFromStorage();
 * newtab.register()
 * ```
 */
var NewTabTrackerStats = /*#__PURE__*/function () {
  /**
   * The key to use when persisting data into storage
   */

  /**
   * The key to use when we don't want to record the company name
   */

  /**
   * The prefix used for events. This is used to ensure we only handle events we care about
   */

  /**
   * @type {Map<string, number> | null}
   */

  /**
   * Internal flag to enable some certain types of logging when developing
   */

  /**
   * @param {import('./classes/tracker-stats').TrackerStats} stats
   */
  function NewTabTrackerStats(stats) {
    _classCallCheck(this, NewTabTrackerStats);
    _defineProperty(this, "top100Companies", null);
    _defineProperty(this, "_debug", false);
    _defineProperty(this, "ports", []);
    _defineProperty(this, "throttleFlags", {});
    this.stats = stats;
  }

  /**
   * Register *all* communications with the extension here.
   *
   * The purpose of this method is to co-locate all extension handlers in a single
   * place for this module.
   */
  _createClass(NewTabTrackerStats, [{
    key: "register",
    value: function register() {
      var _this = this;
      var manifestVersion = browserWrapper.getManifestVersion();
      if (manifestVersion === 3) {
        mv3Redirect();
      } else {
        mv2Redirect();
      }

      /**
       * Maintain a pool of connections - these will occur for every New Tab Page
       * instance.
       */
      chrome.runtime.onConnect.addListener(function (port) {
        if (port.name !== clientPortName) return;

        // keep a reference to this port
        _this.ports.push(port);

        // handle every message on this port
        port.onMessage.addListener(function (msg) {
          _this._handleIncomingEvent(msg);
        });

        // ensure we're not holding on to zombie ports (those that have disconnected)
        port.onDisconnect.addListener(function (msg) {
          var index = _this.ports.indexOf(port);
          if (index > -1) {
            console.log('removing port with index:', index);
            _this.ports.splice(index, 1);
          }
        });
      });

      /**
       * Register an alarm and handle when it fires.
       * For now, we're pruning data every 5 min
       */
      var pruneAlarmName = 'pruneNewTabData';
      browserWrapper.createAlarm(pruneAlarmName, {
        periodInMinutes: 5
      });
      _webextensionPolyfill["default"].alarms.onAlarm.addListener( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (alarmEvent) {
          if (alarmEvent.name === pruneAlarmName) {
            _this._handlePruneAlarm();
          }
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      /**
       * listen for the 'tracker-blocked' event that is fired from `before-request.js`
       * when a request is either blocked or a surrogate was used
       */
      _beforeRequest.emitter.on(_beforeRequest.TrackerBlockedEvent.eventName, function (event) {
        if (!(event instanceof _beforeRequest.TrackerBlockedEvent)) return;
        _this.record(event.companyDisplayName);
      });

      /**
       * Assign the entities from the initial `tds` data
       */
      this.assignTopCompanies(_tds["default"].tds.entities);

      /**
       * Observe changes to the 'tds' data and update the topCompanies
       */
      _tds["default"].onUpdate('tds', function (name, etag, updatedValue) {
        var _updatedValue$tds;
        // just double-checking, is this incoming data validated anywhere else?
        if (updatedValue !== null && updatedValue !== void 0 && (_updatedValue$tds = updatedValue.tds) !== null && _updatedValue$tds !== void 0 && _updatedValue$tds.entities) {
          _this.assignTopCompanies(updatedValue.tds.entities);
        }
      });
    }

    /**
     * Create a Map of 'top companies' based on entity prevalence
     * This is used to ensure we only store the names of companies in the top 100 list
     *
     * @param {Record<string, { displayName: string, prevalence: number }>} entities
     * @param {number} [maxCount] - how many to consider 'top companies'
     */
  }, {
    key: "assignTopCompanies",
    value: function assignTopCompanies(entities) {
      var maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var sorted = Object.keys(entities).map( /** @returns {[string, number]} */
      function (key) {
        var current = entities[key];
        return [current.displayName, current.prevalence];
      }).sort(function (a, b) {
        return b[1] - a[1];
      }).slice(0, maxCount);
      this.top100Companies = new Map(sorted);
    }

    /**
     * This will be called for every 'blocked' event. It can be called many times
     * and in quick succession, hence the debouncing
     *
     * @param {string} displayName
     * @param {number} [timestamp] - optional timestamp
     */
  }, {
    key: "record",
    value: function record(displayName, timestamp) {
      var _this$top100Companies,
        _this2 = this;
      /**
       * Increment the count of this company if the following 2 predicates are satisfied
       *
       * 1) the `displayName` of the company is in our top100Companies list
       * 2) the `displayName` of the company is NOT in our `excludedCompanies` list
       */
      if ((_this$top100Companies = this.top100Companies) !== null && _this$top100Companies !== void 0 && _this$top100Companies.has(displayName) && !_constants["default"].trackerStats.excludedCompanies.includes(displayName)) {
        this.stats.increment(displayName, timestamp);
      } else {
        /**
         * Otherwise just increase the 'Other' count
         */
        this.stats.increment(NewTabTrackerStats.otherCompaniesKey, timestamp);
      }

      // enqueue a sync + data push
      this._throttled('record', 1000, function () {
        _this2.syncToStorage();
        _this2.sendToNewTab('following a recorded tracker-blocked event');
      });
    }

    /**
     * Persist data into the extensions storage in the following format
     */
  }, {
    key: "syncToStorage",
    value: function syncToStorage() {
      var serializedData = this.stats.serialize();
      var toSync = _defineProperty({}, NewTabTrackerStats.storageKey, {
        // making this an object to ensure we can store more things under this
        // namespace later if we need to
        stats: serializedData
      });
      browserWrapper.syncToStorage(toSync);
    }

    /**
     * Attempt to re-populate stats from storage.
     * @returns {Promise<void>}
     */
  }, {
    key: "restoreFromStorage",
    value: function () {
      var _restoreFromStorage = _asyncToGenerator(function* () {
        try {
          var prev = yield browserWrapper.getFromStorage(NewTabTrackerStats.storageKey);
          if (prev) {
            this.stats.deserialize(prev.stats);
          }
        } catch (e) {
          console.warn('could not deserialize data from _cachedDisplayData \'trackerStats\' storage');
        }

        // also evictExpired once we've restored
        this.stats.evictExpired();
      });
      function restoreFromStorage() {
        return _restoreFromStorage.apply(this, arguments);
      }
      return restoreFromStorage;
    }()
    /**
     * Convert locally stored data into data that can be consumed by a UI
     * @param {string} reason - a reason or path that caused this
     */
  }, {
    key: "sendToNewTab",
    value: function sendToNewTab(reason) {
      var _this3 = this;
      if (!reason) throw new Error('you must provide a \'reason\' for sending new data');
      this._throttled('sendToNewTab', 200, function () {
        return _this3._publish(reason);
      });
    }

    /**
     * A single handler for all incoming events relating
     * to the new tab page such as heartbeat etc
     * @returns {void}
     */
  }, {
    key: "_handleIncomingEvent",
    value: function _handleIncomingEvent(event) {
      // only handle messages prefixed with `newTabPage_`
      if (typeof event.messageType === 'string' && event.messageType.startsWith(NewTabTrackerStats.eventPrefix)) {
        // currently this is the only incoming message we accept
        if (event.messageType === incoming.newTabPage_heartbeat) {
          this.sendToNewTab("response to '".concat(event.messageType, "'"));
        } else {
          console.error('unhandled event prefixed with: ', NewTabTrackerStats.eventPrefix, event);
        }
      }
    }

    /**
     * Private method for doing the actual send in a single place
     * that's easy to debug
     */
  }, {
    key: "_publish",
    value: function _publish() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';
      if (this._debug) {
        console.info("sending new tab data because: ".concat(reason));
      }

      /** @type {import('zod').infer<typeof import('../newtab/schema').dataMessage>} */
      var msg = {
        messageType: outgoing.newTabPage_data,
        options: this.toDisplayData()
      };
      var invalidPorts = [];
      var _iterator = _createForOfIteratorHelper(this.ports),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var port = _step.value;
          try {
            port.postMessage(msg);
          } catch (e) {
            invalidPorts.push(port);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (invalidPorts.length) {
        console.error('Stale ports detected...', invalidPorts);
      }
    }

    /**
     * When the evictExpired alarm fires:
     *   - cleanup data structure
     *   - store cleaned data
     *   - publish the changed data
     * @param {number} [now] - optional timestamp to use in comparisons
     */
  }, {
    key: "_handlePruneAlarm",
    value: function _handlePruneAlarm() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();
      this.stats.evictExpired();
      this.syncToStorage();
      this.sendToNewTab('following a evictExpired alarm');
    }

    /**
     * Convert the internal data into a format that can be used in the New Tab Page UI
     *
     * First, we group & sort the data, and then we increase the count of "Other" to account
     * for overflows or for trackers where the owner was not in the top 100 list
     *
     * @param {number} maxCount
     * @param {number} [now] - optional timestamp to use in comparisons
     * @returns {import('zod').infer<typeof import('../newtab/schema').dataFormatSchema>}
     */
  }, {
    key: "toDisplayData",
    value: function toDisplayData() {
      var maxCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
      // access the entries once they are sorted and grouped
      var stats = this.stats.sorted(maxCount, now);

      // is there an entry for 'otherCompaniesKey'? (meaning an entry where the company name was skipped)
      var index = stats.results.findIndex(function (result) {
        return result.key === NewTabTrackerStats.otherCompaniesKey;
      });

      // if there is an entry, add the 'overflow' count and move it to the end of the list
      if (index > -1) {
        var _stats$results;
        var element = stats.results[index];
        if (stats.overflow) {
          element.count += stats.overflow;
        }
        var spliced = stats.results.splice(index, 1);
        (_stats$results = stats.results).push.apply(_stats$results, _toConsumableArray(spliced));
      } else {
        // if we get here, there was no entry for `otherCompaniesKey`, so we need to add one to cover the overflow
        if (stats.overflow) {
          stats.results.push({
            key: NewTabTrackerStats.otherCompaniesKey,
            count: stats.overflow
          });
        }
      }

      // now produce the data in the shape consumers require for rendering their UI
      // see 'dataFormatSchema' for the required format, it's in the `../newtab/schema` file
      return {
        totalCount: this.stats.totalCount,
        totalPeriod: 'install-time',
        trackerCompaniesPeriod: 'last-hour',
        trackerCompanies: stats.results.map(function (item) {
          // convert our known key into the 'Other'
          var displayName = item.key === NewTabTrackerStats.otherCompaniesKey ? 'Other' : item.key;
          return {
            displayName: displayName,
            count: item.count
          };
        })
      };
    }
  }, {
    key: "_throttled",
    value:
    /**
     * A trailing throttle implementation.
     *
     * This will ensure a given operation does not execute more
     * than once within the given timeframe;
     *
     * @param {string} name
     * @param {number} timeout
     * @param {() => unknown} fn
     */
    function _throttled(name, timeout, fn) {
      var _this4 = this;
      if (this.throttleFlags[name] === true) {
        // do nothing, if we get here we're already _throttled
      } else {
        // mark this operation as active
        this.throttleFlags[name] = true;

        // schedule the callback
        setTimeout(function () {
          // mark this operation as 'inactive'
          _this4.throttleFlags[name] = false;
          fn();
        }, timeout);
      }
    }
  }]);
  return NewTabTrackerStats;
}();
/**
 * Respond to requests for `tracker-stats.html` - if we determine
 * that the request was from an allowed origin, re-direct the
 * request to the web_accessible_resource file 'html/tracker-stats.html'
 *
 * @param details
 */
exports.NewTabTrackerStats = NewTabTrackerStats;
_defineProperty(NewTabTrackerStats, "storageKey", 'trackerStats');
_defineProperty(NewTabTrackerStats, "otherCompaniesKey", '__others__');
_defineProperty(NewTabTrackerStats, "eventPrefix", 'newTabPage_');
function mv2Redirect() {
  var incomingUrl = new URL(_constants["default"].trackerStats.allowedPathname, _constants["default"].trackerStats.allowedOrigin);
  /**
   * This listener will redirect the request for tracker-stats.html
   * on the new tab page to our own HTML file under `web_accessible_resources`
   */
  _webextensionPolyfill["default"].webRequest.onBeforeRequest.addListener(function (details) {
    // Only do the redirect if we're being iframed into a known origin
    if (details.type === 'sub_frame') {
      var parsed = new URL(details.url);
      if (parsed.origin === _constants["default"].trackerStats.allowedOrigin) {
        if (parsed.pathname.includes(_constants["default"].trackerStats.allowedPathname)) {
          return {
            redirectUrl: chrome.runtime.getURL(_constants["default"].trackerStats.redirectTarget)
          };
        }
      }
    }
    return undefined;
  }, {
    urls: [incomingUrl.toString()],
    types: ['sub_frame']
  }, ['blocking']);
}
function mv3Redirect() {
  var targetUrl = chrome.runtime.getURL(_constants["default"].trackerStats.redirectTarget);
  var incomingUrl = new URL(_constants["default"].trackerStats.allowedPathname, _constants["default"].trackerStats.allowedOrigin);
  var redirectRule = (0, _utils.generateDNRRule)({
    id: _dnrUtils.NEWTAB_TRACKER_STATS_REDIRECT_RULE_ID,
    priority: _rulePriorities.NEWTAB_TRACKER_STATS_REDIRECT_PRIORITY,
    actionType: 'redirect',
    redirect: {
      url: targetUrl
    },
    urlFilter: incomingUrl.toString(),
    resourceTypes: ['sub_frame']
  });
  chrome.declarativeNetRequest.updateDynamicRules({
    removeRuleIds: [redirectRule.id],
    addRules: [redirectRule]
  });
}

},{"../../data/constants":38,"./before-request.js":49,"./dnr-utils":73,"./storage/tds":93,"./wrapper.js":99,"@duckduckgo/ddg2dnr/lib/rulePriorities":27,"@duckduckgo/ddg2dnr/lib/utils":33,"webextension-polyfill":11}],86:[function(require,module,exports){
"use strict";

/**
* This is injected programatically on the DuckDuckGo SERP (mostly during the first search
* post extension install) to assist with user onboarding
* We handle 2 cases:
* - Firefox: we simply call a method on window so that the SERP can display a welcome
* message to users
* - Chrome: we do the same thing (but provide more data) and set-up listeners so that
* the SERP can:
*    - Assess if the extension has been deactivated by Chrome
*    - Reschedule the onboarding for the next restart
*/
function onDocumentEnd(_ref) {
  var isAddressBarQuery = _ref.isAddressBarQuery,
    showWelcomeBanner = _ref.showWelcomeBanner,
    showCounterMessaging = _ref.showCounterMessaging,
    extensionId = _ref.extensionId,
    duckDuckGoSerpHostname = _ref.duckDuckGoSerpHostname,
    browserName = _ref.browserName;
  var origin = "https://".concat(duckDuckGoSerpHostname);

  /**
   * Helper function that grabs value of the content-script created by
   * `createOnboardingCodeInjectedAtDocumentStart` that was injected earlier to capture
   * variables at an earlier stage of the page lifecycle
   */
  function getDocumentStartData(cb) {
    if (browserName !== 'chrome') {
      return cb();
    }
    window.postMessage({
      type: 'documentStartDataRequest'
    }, origin);
    window.addEventListener('message', function handleMessage(e) {
      if (e.origin === origin && e.data.type === 'documentStartDataResponse') {
        window.removeEventListener('message', handleMessage);
        cb(e.data.payload);
      }
    });
  }
  function start() {
    getDocumentStartData(function (documentStartData) {
      // DDG privacy policy prevents us to use `chrome.runtime` on the SERP so we
      // setup a relay here so that the SERP can communicate with the background process
      if (browserName === 'chrome') {
        window.addEventListener('message', function (e) {
          if (e.origin === origin) {
            switch (e.data.type) {
              case 'healthCheckRequest':
                {
                  try {
                    chrome.runtime.sendMessage(extensionId, e.data.type, function (response) {
                      e.source.postMessage({
                        type: 'healthCheckResponse',
                        isAlive: !chrome.runtime.lastError
                      }, e.origin);
                    });
                  } catch (err) {
                    e.source.postMessage({
                      type: 'healthCheckResponse',
                      isAlive: false
                    }, e.origin);
                  }
                  break;
                }
              case 'rescheduleCounterMessagingRequest':
                {
                  chrome.runtime.sendMessage(extensionId, e.data.type, function (response) {
                    if (chrome.runtime.lastError) {
                      console.error(chrome.runtime.lastError);
                    }
                  });
                  break;
                }
            }
          }
        });
      }

      // The content script do not share the same `window` as the page
      // so we inject a `<script>` to be able to access the page `window`
      //
      // Note that this is not done through messaging in order to prevent
      // setting up an event listner on the SERP (this would be wasteful)
      // as this is only needed on the _first_ search post extension install
      var script = document.createElement('script');
      script.textContent = "\n                    if (window.onFirstSearchPostExtensionInstall) {\n                        window.onFirstSearchPostExtensionInstall(".concat(JSON.stringify(Object.assign({
        isAddressBarQuery: isAddressBarQuery,
        showWelcomeBanner: showWelcomeBanner,
        showCounterMessaging: showCounterMessaging
      }, documentStartData)), ")\n                    }\n                ");
      document.head.appendChild(script);
    });
  }
  if (document.readyState === 'interactive' || document.readyState === 'complete') {
    start();
  } else {
    document.addEventListener('DOMContentLoaded', start);
  }
}
function onDocumentStart(_ref2) {
  var duckDuckGoSerpHostname = _ref2.duckDuckGoSerpHostname;
  var hadFocusOnStart = document.hasFocus();
  window.addEventListener('message', function handleMessage(e) {
    if (e.origin === "https://".concat(duckDuckGoSerpHostname) && e.data.type === 'documentStartDataRequest') {
      window.removeEventListener('message', handleMessage);
      e.source.postMessage({
        type: 'documentStartDataResponse',
        payload: {
          hadFocusOnStart: hadFocusOnStart
        }
      }, e.origin);
    }
  });
}
module.exports = {
  onDocumentEnd: onDocumentEnd,
  onDocumentStart: onDocumentStart
};

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getURL = getURL;
/**
 *
 * Return URL for the pixel request
 * @param {string} pixelName
 * @returns {string}
 */
function getURL(pixelName) {
  if (!pixelName) throw new Error('pixelName is required');
  var url = 'https://improving.duckduckgo.com/t/';
  return url + pixelName;
}

},{}],88:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// @ts-nocheck
var tldts = require('tldts');
var tosdr = require('../../data/tosdr');
var constants = require('../../data/constants');
var utils = require('./utils');
var tosdrRegexList = [];
var tosdrScores = {};
var PrivacyPractices = /*#__PURE__*/function () {
  function PrivacyPractices() {
    _classCallCheck(this, PrivacyPractices);
    Object.keys(tosdr).forEach(function (site) {
      // only match domains, and from the start of the URL
      tosdrRegexList.push(new RegExp("(^)".concat(tldts.getDomain(site))));

      // generate scores for the privacy grade
      var tosdrClass = tosdr[site]["class"];
      var tosdrScore = tosdr[site].score;
      if (tosdrClass || tosdrScore) {
        var score = 5;

        // asign a score value to the classes/scores provided in the JSON file
        if (tosdrClass === 'A') {
          score = 0;
        } else if (tosdrClass === 'B') {
          score = 1;
        } else if (tosdrClass === 'D' || tosdrScore > 150) {
          score = 10;
        } else if (tosdrClass === 'C' || tosdrScore > 100) {
          score = 7;
        }
        tosdrScores[site] = score;

        // if the site has a parent entity, propagate the score to that, too
        // but only if the score is higher
        //
        // basically, a parent entity's privacy score is as bad as
        // that of the worst site it owns
        var parentEntity = utils.findParent(site);
        if (parentEntity && (!tosdrScores[parentEntity] || tosdrScores[parentEntity] < score)) {
          tosdrScores[parentEntity] = score;
        }
      }
    });
  }
  _createClass(PrivacyPractices, [{
    key: "getTosdr",
    value: function getTosdr(url) {
      var domain = tldts.getDomain(url);
      var tosdrData;
      tosdrRegexList.some(function (tosdrSite) {
        var match = tosdrSite.exec(domain);
        if (!match) return false;
        tosdrData = tosdr[match[0]];
        return tosdrData;
      });
      if (!tosdrData) return {};
      var matchGood = tosdrData.match && tosdrData.match.good || [];
      var matchBad = tosdrData.match && tosdrData.match.bad || [];

      // tosdr message
      // 1. If we have a defined tosdr class look up the message in constants
      //    for the corresponding letter class
      // 2. If there are both good and bad points -> 'mixed'
      // 3. Else use the calculated tosdr score to determine the message
      var message = constants.tosdrMessages.unknown;
      if (tosdrData["class"]) {
        message = constants.tosdrMessages[tosdrData["class"]];
      } else if (matchGood.length && matchBad.length) {
        message = constants.tosdrMessages.mixed;
      } else {
        if (tosdrData.score < 0) {
          message = constants.tosdrMessages.good;
        } else if (tosdrData.score === 0 && (matchGood.length || matchBad.length)) {
          message = constants.tosdrMessages.mixed;
        } else if (tosdrData.score > 0) {
          message = constants.tosdrMessages.bad;
        }
      }
      return {
        score: tosdrData.score,
        "class": tosdrData["class"],
        reasons: {
          good: matchGood,
          bad: matchBad
        },
        message: message
      };
    }
  }, {
    key: "getTosdrScore",
    value: function getTosdrScore(hostname, parent) {
      var domain = tldts.getDomain(hostname);

      // look for tosdr match in list of parent properties
      var parentMatch = '';
      if (parent && parent.domains) {
        Object.keys(tosdrScores).some(function (tosdrName) {
          var match = parent.domains.find(function (d) {
            return d === tosdrName;
          });
          if (match) {
            parentMatch = match;
            return true;
          }
          return false;
        });
      }

      // grab the first available val
      // starting with most general first

      // minor potential for an edge case:
      // foo.bar.com and bar.com have entries in tosdr.json
      // and different scores - should they propagate
      // the same way parent entity ones do?
      var score = [tosdrScores[parentMatch], tosdrScores[domain], tosdrScores[hostname]].find(function (s) {
        return typeof s === 'number';
      });
      return score;
    }
  }]);
  return PrivacyPractices;
}();
module.exports = new PrivacyPractices();

},{"../../data/constants":38,"../../data/tosdr":42,"./utils":98,"tldts":10}],89:[function(require,module,exports){
"use strict";

var browserWrapper = require('./wrapper');

// With Manifest V2 the content scripts are run directly from the manifest and
// they inject into the main world of websites by adding a <script> element to
// the DOM. With Manifest V3 however the chrome.scripting API must be used to
// inject scripts into the main world.
// Note: It's important that the isolated world script runs first. The order the
//       scripts are added by registerContentScripts is based on the script ID,
//       but note that's an implementation detail (from use of std::set for new
//       script IDs[1]) and could change in the future.
// 1 - https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/extensions/api/scripting/scripting_api.cc;l=929
if (browserWrapper.getManifestVersion() === 3) {
  // @ts-ignore - The chrome type does not yet know about
  //              registerContentScripts.
  chrome.scripting.registerContentScripts([{
    id: '1-script-injection-isolated-world',
    allFrames: true,
    js: ['public/js/content-scripts/content-scope-messaging.js'],
    runAt: 'document_start',
    world: 'ISOLATED',
    matches: ['<all_urls>']
  }, {
    id: '2-script-injection-main-world',
    allFrames: true,
    js: ['public/js/inject.js'],
    runAt: 'document_start',
    world: 'MAIN',
    matches: ['<all_urls>']
  }]);
}

},{"./wrapper":99}],90:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var defaultSettings = require('../../data/defaultSettings');
var browserWrapper = require('./wrapper');

/**
 * Settings whose defaults can by managed by the system administrator
 */
var MANAGED_SETTINGS = ['hasSeenPostInstall'];
/**
 * Public api
 * Usage:
 * You can use promise callbacks to check readyness before getting and updating
 * settings.ready().then(() => settings.updateSetting('settingName', settingValue))
 */
var settings = {};
var isReady = false;
var _ready = init().then(function () {
  isReady = true;
  console.log('Settings are loaded');
});
function init() {
  return _init.apply(this, arguments);
}
function _init() {
  _init = _asyncToGenerator(function* () {
    buildSettingsFromDefaults();
    yield buildSettingsFromManagedStorage();
    yield buildSettingsFromLocalStorage();
  });
  return _init.apply(this, arguments);
}
function ready() {
  return _ready;
}

// Ensures we have cleared up old storage keys we have renamed
function checkForLegacyKeys() {
  var legacyKeys = {
    // Keys to migrate
    whitelisted: 'allowlisted',
    whitelistOptIn: 'allowlistOptIn',
    // Keys to remove
    advanced_options: null,
    clickToLoadClicks: null,
    cookieExcludeList: null,
    dev: null,
    ducky: null,
    extensionIsEnabled: null,
    failedUpgrades: null,
    last_search: null,
    lastsearch_enabled: null,
    meanings: null,
    safesearch: null,
    socialBlockingIsEnabled: null,
    totalUpgrades: null,
    trackerBlockingEnabled: null,
    use_post: null,
    version: null,
    zeroclick_google_right: null,
    'surrogates-etag': null,
    'brokenSiteList-etag': null,
    'surrogateList-etag': null,
    'trackersWhitelist-etag': null,
    'trackersWhitelistTemporary-etag': null
  };
  var syncNeeded = false;
  for (var legacyKey in legacyKeys) {
    var key = legacyKeys[legacyKey];
    if (!(legacyKey in settings)) {
      continue;
    }
    syncNeeded = true;
    var legacyValue = settings[legacyKey];
    if (key && legacyValue) {
      settings[key] = legacyValue;
    }
    delete settings[legacyKey];
  }
  if (syncNeeded) {
    syncSettingTolocalStorage();
  }
}
function buildSettingsFromLocalStorage() {
  return _buildSettingsFromLocalStorage.apply(this, arguments);
}
function _buildSettingsFromLocalStorage() {
  _buildSettingsFromLocalStorage = _asyncToGenerator(function* () {
    var results = yield browserWrapper.getFromStorage(['settings']);
    // copy over saved settings from storage
    if (!results) return;
    settings = browserWrapper.mergeSavedSettings(settings, results);
    checkForLegacyKeys();
  });
  return _buildSettingsFromLocalStorage.apply(this, arguments);
}
function buildSettingsFromManagedStorage() {
  return _buildSettingsFromManagedStorage.apply(this, arguments);
}
function _buildSettingsFromManagedStorage() {
  _buildSettingsFromManagedStorage = _asyncToGenerator(function* () {
    var results = yield browserWrapper.getFromManagedStorage(MANAGED_SETTINGS);
    settings = browserWrapper.mergeSavedSettings(settings, results);
  });
  return _buildSettingsFromManagedStorage.apply(this, arguments);
}
function buildSettingsFromDefaults() {
  // initial settings are a copy of default settings
  settings = Object.assign({}, defaultSettings);
}
function syncSettingTolocalStorage() {
  browserWrapper.syncToStorage({
    settings: settings
  });
}
function getSetting(name) {
  if (!isReady) {
    console.warn("Settings: getSetting() Settings not loaded: ".concat(name));
    return;
  }

  // let all and null return all settings
  if (name === 'all') name = null;
  if (name) {
    return settings[name];
  } else {
    return settings;
  }
}
function updateSetting(name, value) {
  if (!isReady) {
    console.warn("Settings: updateSetting() Setting not loaded: ".concat(name));
    return;
  }
  settings[name] = value;
  syncSettingTolocalStorage();
}
function removeSetting(name) {
  if (!isReady) {
    console.warn("Settings: removeSetting() Setting not loaded: ".concat(name));
    return;
  }
  if (settings[name]) {
    delete settings[name];
    syncSettingTolocalStorage();
  }
}
function logSettings() {
  browserWrapper.getFromStorage(['settings']).then(function (s) {
    console.log(s.settings);
  });
}
module.exports = {
  getSetting: getSetting,
  updateSetting: updateSetting,
  removeSetting: removeSetting,
  logSettings: logSettings,
  ready: ready
};

},{"../../data/defaultSettings":39,"./wrapper":99}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onStartup = onStartup;
exports.ready = ready;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _newtabTrackerStats = require("./newtab-tracker-stats");
var _trackerStats = require("./classes/tracker-stats");
var _https = _interopRequireDefault(require("./storage/https"));
var _tds = _interopRequireDefault(require("./storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var utils = require('./utils');
var browserWrapper = require('./wrapper');
var Companies = require('./companies');
var experiment = require('./experiments');
var https = require('./https');
var settings = require('./settings');
var tabManager = require('./tab-manager');
var trackers = require('./trackers');
var dnrSessionId = require('./dnr-session-rule-id');
var _require = require('./email-utils'),
  fetchAlias = _require.fetchAlias,
  showContextMenuAction = _require.showContextMenuAction;
var manifestVersion = browserWrapper.getManifestVersion();
/** @module */

var resolveReadyPromise;
var readyPromise = new Promise(function (resolve) {
  resolveReadyPromise = resolve;
});
function onStartup() {
  return _onStartup.apply(this, arguments);
}
function _onStartup() {
  _onStartup = _asyncToGenerator(function* () {
    if (manifestVersion === 3) {
      yield dnrSessionId.setSessionRuleOffsetFromStorage();
    }
    yield settings.ready();
    experiment.setActiveExperiment();
    try {
      var httpsLists = yield _https["default"].getLists( /* preferLocal= */true);
      https.setLists(httpsLists);
    } catch (e) {
      console.warn('Error loading https lists', e);
    }
    try {
      var tdsLists = yield _tds["default"].getLists( /* preferLocal= */true);
      trackers.setLists(tdsLists);
    } catch (e) {
      console.warn('Error loading tds lists', e);
    }
    Companies.buildFromStorage();

    /**
     * in Chrome only, try to initiate the `NewTabTrackerStats` feature
     */
    if (utils.getBrowserName() === 'chrome') {
      try {
        // build up dependencies
        var trackerStats = new _trackerStats.TrackerStats();
        var newTabTrackerStats = new _newtabTrackerStats.NewTabTrackerStats(trackerStats);

        // restore from storage first
        yield newTabTrackerStats.restoreFromStorage();

        // now setup extension listeners
        newTabTrackerStats.register();
      } catch (e) {
        console.warn('an error occurred setting up TrackerStats', e);
      }
    }

    // fetch alias if needed
    var userData = settings.getSetting('userData');
    if (userData && userData.token) {
      if (!userData.nextAlias) yield fetchAlias();
      showContextMenuAction();
    }
    var savedTabs = yield _webextensionPolyfill["default"].tabs.query({
      status: 'complete'
    });
    for (var i = 0; i < savedTabs.length; i++) {
      var tab = savedTabs[i];
      if (tab.url) {
        // On reinstall we wish to create the tab again
        yield tabManager.restoreOrCreate(tab);
      }
    }
    if (resolveReadyPromise) {
      resolveReadyPromise();
      resolveReadyPromise = null;
    }
  });
  return _onStartup.apply(this, arguments);
}
function ready() {
  return readyPromise;
}

},{"./classes/tracker-stats":61,"./companies":64,"./dnr-session-rule-id":70,"./email-utils":74,"./experiments":79,"./https":82,"./newtab-tracker-stats":85,"./settings":90,"./storage/https":92,"./storage/tds":93,"./tab-manager":94,"./trackers":96,"./utils":98,"./wrapper":99,"webextension-polyfill":11}],92:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _dexie = _interopRequireDefault(require("dexie"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var load = require('./../load');
var constants = require('../../../data/constants');
var settings = require('./../settings');
var HTTPSStorage = /*#__PURE__*/function () {
  function HTTPSStorage() {
    _classCallCheck(this, HTTPSStorage);
    // @ts-ignore - TypeScript is not following the Dexie import property.
    this.dbc = new _dexie["default"](constants.httpsDBName);
    this.dbc.version(1).stores({
      httpsStorage: 'name,type,data,checksum'
    });

    // Update the lists every 12 hours.
    this.updatePeriodInMinutes = 12 * 60;
  }

  // Load https data defined in constants.httpsLists.
  // We wait until all promises resolve to send data to https.
  // This is all or nothing. We gather data for each of the lists
  // and validate. If any list fails validation then promise.all will
  // reject the whole update.
  _createClass(HTTPSStorage, [{
    key: "getLists",
    value: function getLists() {
      var _this = this;
      var preferLocal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return Promise.all(constants.httpsLists.map( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (list) {
          var listCopy = JSON.parse(JSON.stringify(list));
          var etag = settings.getSetting("".concat(listCopy.name, "-etag")) || '';
          if (preferLocal) {
            var lastUpdate = settings.getSetting("".concat(listCopy.name, "-lastUpdate")) || 0;
            var millisecondsSinceUpdate = Date.now() - lastUpdate;
            if (millisecondsSinceUpdate < _this.updatePeriodInMinutes * 60 * 1000) {
              var result = yield _this.getListFromLocalDB(listCopy);
              if (result) {
                return result;
              }
            }
          }
          return _this.getDataXHR(listCopy.url, etag).then(function (response) {
            // Set the lastUpdate time.
            // Notes:
            //  - Take the earliest time between server and local, that way if
            //    the local time is set far in the future updates will still
            //    happen.
            //  - Date.parse() returns NaN for invalid (or missing) Date
            //    headers, and Math.min() always considers NaN to be the
            //    smallest value. So before calling Math.min(), replace
            //    serverTime with localTime if serverTime is falsey (NaN).
            var localTime = Date.now();
            var serverTime = Date.parse(response.date);
            var updateTime = Math.min(localTime, serverTime || localTime);
            settings.updateSetting("".concat(listCopy.name, "-lastUpdate"), updateTime);

            // for 200 response we update etags
            if (response && response.status === 200) {
              var newEtag = response.etag || '';
              settings.updateSetting("".concat(listCopy.name, "-etag"), newEtag);
            }

            // We try to process both 200 and 304 responses. 200s will validate
            // and update the db. 304s will try to grab the previous data from db
            // or throw an error if none exists.
            return _this.processData(listCopy, response.data).then(function (resultData) {
              if (resultData) {
                return resultData;
              } else {
                throw new Error("HTTPS: process list xhr failed  ".concat(listCopy.name));
              }
            });
          })["catch"]( /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator(function* (e) {
              var result = yield _this.getListFromLocalDB(listCopy);
              if (result) {
                return result;
              }

              // Reset etag and lastUpdate time to force us to get
              // fresh server data in case of an error.
              settings.updateSetting("".concat(listCopy.name, "-etag"), '');
              settings.updateSetting("".concat(listCopy.name, "-lastUpdate"), '');
              throw new Error("HTTPS: data update for ".concat(listCopy.name, " failed"));
            });
            return function (_x2) {
              return _ref2.apply(this, arguments);
            };
          }());
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()));
    }

    // validate xhr data and lookup previous data from local db if needed
    // verify the checksum before returning the processData result
  }, {
    key: "processData",
    value: function processData(listDetails, xhrData) {
      var _this2 = this;
      if (xhrData) {
        return this.hasCorrectChecksum(xhrData).then(function (isValid) {
          if (isValid) {
            _this2.storeInLocalDB(listDetails.name, listDetails.type, xhrData);
            return Object.assign(listDetails, xhrData);
          }
        });
      } else {
        return Promise.resolve();
      }
    }
  }, {
    key: "getDataXHR",
    value: function getDataXHR(url, etag) {
      return load.loadExtensionFile({
        url: url,
        etag: etag,
        returnType: 'json',
        source: 'external',
        timeout: 60000
      });
    }
  }, {
    key: "getListFromLocalDB",
    value: function () {
      var _getListFromLocalDB = _asyncToGenerator(function* (listDetails) {
        console.log('HTTPS: getting from db', listDetails.name);
        try {
          yield this.dbc.open();
          var list = yield this.dbc.table('httpsStorage').get({
            name: listDetails.name
          });
          if (list && list.data && (yield this.hasCorrectChecksum(list.data))) {
            return Object.assign(listDetails, list.data);
          }
        } catch (e) {
          console.warn("getListFromLocalDB failed for ".concat(listDetails.name), e);
          return null;
        }
      });
      function getListFromLocalDB(_x3) {
        return _getListFromLocalDB.apply(this, arguments);
      }
      return getListFromLocalDB;
    }()
  }, {
    key: "storeInLocalDB",
    value: function storeInLocalDB(name, type, data) {
      return this.dbc.table('httpsStorage').put({
        name: name,
        type: type,
        data: data
      })["catch"](function (e) {
        console.warn("storeInLocalDB failed for ".concat(name, ": resetting stored etag"), e);
        settings.updateSetting("".concat(name, "-etag"), '');
        settings.updateSetting("".concat(name, "-lastUpdate"), '');
      });
    }
  }, {
    key: "hasCorrectChecksum",
    value: function hasCorrectChecksum(data) {
      // not everything has a checksum
      if (!data.checksum) return Promise.resolve(true);

      // TODO: rewrite this check without needing a Buffer polyfill
      if (typeof Buffer === 'undefined') {
        return Promise.resolve(true);
      }

      // need a buffer to send to crypto.subtle
      var buffer = Buffer.from(data.data, 'base64');
      return crypto.subtle.digest('SHA-256', buffer).then(function (arrayBuffer) {
        var sha256 = Buffer.from(arrayBuffer).toString('base64');
        if (data.checksum.sha256 && data.checksum.sha256 === sha256) {
          return true;
        } else {
          return false;
        }
      });
    }
  }]);
  return HTTPSStorage;
}();
var _default = new HTTPSStorage();
exports["default"] = _default;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../../data/constants":38,"./../load":83,"./../settings":90,"buffer":4,"dexie":5}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _dexie = _interopRequireDefault(require("dexie"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var load = require('./../load');
var constants = require('../../../data/constants');
var settings = require('./../settings');
var browserWrapper = require('./../wrapper');
var extensionConfig = require('./../../../data/bundled/extension-config.json');
var etags = require('../../../data/etags.json');
var configNames = constants.tdsLists.map(function (_ref) {
  var name = _ref.name;
  return name;
});

/**
 * @typedef {Object} TDSList
 * @property {string} name
 * @property {string} source
 * @property {string} url
 * @property {Record<string,string>} [channels]
 */
var TDSStorage = /*#__PURE__*/function () {
  function TDSStorage() {
    var _this = this;
    _classCallCheck(this, TDSStorage);
    this.dbc = new _dexie["default"]('tdsStorage');
    this.dbc.version(1).stores({
      tdsStorage: 'name,data'
    });
    this.table = this.dbc.table('tdsStorage');
    this.tds = {
      entities: {},
      trackers: {},
      domains: {},
      cnames: {}
    };
    this.surrogates = '';
    this.config = {
      features: {}
    };
    this.isInstalling = false;
    this._onUpdatedListeners = new Map();
    this._onReadyResolvers = new Map();
    this._onReadyPromises = new Map();
    var _iterator = _createForOfIteratorHelper(configNames),
      _step;
    try {
      var _loop = function _loop() {
        var configName = _step.value;
        _this._onReadyPromises.set(configName, new Promise(function (resolve) {
          _this._onReadyResolvers.set(configName, resolve);
        }));
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }

      // Update the lists every half an hour.
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    this.updatePeriodInMinutes = 30;
    this.removeLegacyLists();
  }
  _createClass(TDSStorage, [{
    key: "initOnInstall",
    value: function () {
      var _initOnInstall = _asyncToGenerator(function* () {
        this.isInstalling = true;
        this._installingPromise = yield this._internalInitOnInstall();
        this.isInstalling = false;
      });
      function initOnInstall() {
        return _initOnInstall.apply(this, arguments);
      }
      return initOnInstall;
    }()
  }, {
    key: "_internalInitOnInstall",
    value: function () {
      var _internalInitOnInstall2 = _asyncToGenerator(function* () {
        yield settings.ready();
        var etagKey = 'config-etag';
        var etagValue = settings.getSetting(etagKey);
        // If there's an existing value ignore the bundled values
        if (!etagValue) {
          settings.updateSetting(etagKey, etags[etagKey]);
          this.config = extensionConfig;
          yield this.storeInLocalDB('config', extensionConfig);
        }
      });
      function _internalInitOnInstall() {
        return _internalInitOnInstall2.apply(this, arguments);
      }
      return _internalInitOnInstall;
    }()
  }, {
    key: "_internalOnListUpdate",
    value: function _internalOnListUpdate(configName, configValue) {
      var _this2 = this;
      return new Promise(function (resolve, reject) {
        self.setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {
          // Ensure the onReady promise for this configuration is resolved.
          try {
            var readyResolve = _this2._onReadyResolvers.get(configName);
            if (readyResolve) {
              readyResolve();
              _this2._onReadyResolvers["delete"](configName);
            }

            // Check the current etag for this configuration, so that can be
            // passed to the listeners.
            var etag = settings.getSetting("".concat(configName, "-etag")) || '';

            // Notify any listeners that this list has updated.
            var listeners = _this2._onUpdatedListeners.get(configName);
            if (listeners) {
              var _iterator2 = _createForOfIteratorHelper(listeners.slice()),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var listener = _step2.value;
                  yield listener(configName, etag, configValue);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
            resolve(null);
          } catch (e) {
            reject(e);
          }
        }), 0);
      });
    }
  }, {
    key: "getLists",
    value: function getLists() {
      var _this3 = this;
      var preferLocal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return Promise.all(constants.tdsLists.map( /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function* (list) {
          // Skip fetching the lists on extension startup if a new enough
          // local copy exists.
          if (preferLocal) {
            var lastUpdate = settings.getSetting("".concat(list.name, "-lastUpdate")) || 0;
            var millisecondsSinceUpdate = Date.now() - lastUpdate;
            if (millisecondsSinceUpdate < _this3.updatePeriodInMinutes * 60 * 1000) {
              var localList = yield _this3.getListFromLocalDB(list.name);
              if (localList) {
                return localList;
              }
            }
          }
          return yield _this3.getList(list);
        });
        return function (_x) {
          return _ref3.apply(this, arguments);
        };
      }()));
    }

    /**
     * @param {TDSList} list
     */
  }, {
    key: "getList",
    value: function () {
      var _getList = _asyncToGenerator(function* (list) {
        var _this4 = this;
        // If initOnInstall was called, await the updating from the local bundles before fetching
        if (this.isInstalling) {
          yield this._installingPromise;
        }
        /** @type {TDSList} */
        var listCopy = JSON.parse(JSON.stringify(list));
        var etag = settings.getSetting("".concat(listCopy.name, "-etag")) || '';
        var version = this.getVersionParam();
        var activeExperiment = settings.getSetting('activeExperiment');
        var channel = settings.getSetting("".concat(listCopy.name, "-channel")) || '';
        var experiment = '';
        if (activeExperiment) {
          experiment = settings.getSetting('experimentData');
        }

        // select custom version of the list from the config
        if (channel && listCopy.channels && listCopy.channels[channel]) {
          listCopy.url = listCopy.channels[channel];
        }

        // @ts-ignore
        if (experiment && experiment.listName === listCopy.name) {
          // @ts-ignore
          listCopy.url = experiment.url;
        }
        if (version && listCopy.source === 'external') {
          listCopy.url += version;
        }
        var source = listCopy.source ? listCopy.source : 'external';
        return this.getDataXHR(listCopy, etag, source).then(function (response) {
          // Set the lastUpdate time.
          // Notes:
          //  - Take the earliest time between server and local, that way if
          //    the local time is set far in the future updates will still
          //    happen.
          //  - Date.parse() returns NaN for invalid (or missing) Date
          //    headers, and Math.min() always considers NaN to be the
          //    smallest value. So before calling Math.min(), replace
          //    serverTime with localTime if serverTime is falsey (NaN).
          var localTime = Date.now();
          var serverTime = Date.parse(response.date);
          var updateTime = Math.min(localTime, serverTime || localTime);
          settings.updateSetting("".concat(listCopy.name, "-lastUpdate"), updateTime);

          // for 200 response we update etags
          if (response && response.status === 200) {
            var newEtag = response.etag || '';
            settings.updateSetting("".concat(listCopy.name, "-etag"), newEtag);
          }

          // We try to process both 200 and 304 responses. 200s will validate
          // and update the db. 304s will try to grab the previous data from db
          // or throw an error if none exists.
          return _this4.processData(listCopy.name, response.data).then(function (resultData) {
            if (resultData) {
              // store tds in memory so we can access it later if needed
              _this4[listCopy.name] = resultData;
              _this4._internalOnListUpdate(listCopy.name, resultData);
              return {
                name: listCopy.name,
                data: resultData
              };
            } else {
              throw new Error('TDS: process list xhr failed');
            }
          });
        })["catch"]( /*#__PURE__*/function () {
          var _ref4 = _asyncToGenerator(function* (e) {
            var result = yield _this4.getListFromLocalDB(listCopy.name);
            if (result) {
              return result;
            }

            // Reset the etag and lastUpdate time to force us to get
            // fresh server data in case of an error.
            settings.updateSetting("".concat(listCopy.name, "-etag"), '');
            settings.updateSetting("".concat(listCopy.name, "-lastUpdate"), '');
            throw new Error('TDS: data update failed');
          });
          return function (_x3) {
            return _ref4.apply(this, arguments);
          };
        }());
      });
      function getList(_x2) {
        return _getList.apply(this, arguments);
      }
      return getList;
    }()
  }, {
    key: "processData",
    value: function processData(name, xhrData) {
      if (xhrData) {
        var parsedData = this.parsedata(name, xhrData);
        this.storeInLocalDB(name, parsedData);
        return Promise.resolve(parsedData);
      } else {
        return Promise.resolve();
      }
    }
  }, {
    key: "getDataXHR",
    value: function getDataXHR(list, etag, source) {
      return load.loadExtensionFile({
        url: list.url,
        etag: etag,
        returnType: list.format,
        source: source,
        timeout: 60000
      });
    }
  }, {
    key: "getListFromLocalDB",
    value: function () {
      var _getListFromLocalDB = _asyncToGenerator(function* (name) {
        console.log('TDS: getting from db', name);
        try {
          yield this.dbc.open();
          var list = yield this.dbc.table('tdsStorage').get({
            name: name
          });
          if (list && list.data) {
            this[name] = list.data;
            this._internalOnListUpdate(name, list.data);
            return {
              name: name,
              data: list.data
            };
          }
        } catch (e) {
          console.warn("getListFromLocalDB failed for ".concat(name), e);
          return null;
        }
      });
      function getListFromLocalDB(_x4) {
        return _getListFromLocalDB.apply(this, arguments);
      }
      return getListFromLocalDB;
    }()
  }, {
    key: "storeInLocalDB",
    value: function storeInLocalDB(name, data) {
      return this.table.put({
        name: name,
        data: data
      })["catch"](function (e) {
        console.warn("storeInLocalDB failed for ".concat(name, ": resetting stored etag"), e);
        settings.updateSetting("".concat(name, "-etag"), '');
        settings.updateSetting("".concat(name, "-lastUpdate"), '');
      });
    }
  }, {
    key: "parsedata",
    value: function parsedata(name, data) {
      var parsers = {
        brokenSiteList: function brokenSiteList(dataIn) {
          return dataIn.trim().split('\n');
        }
      };
      if (parsers[name]) {
        return parsers[name](data);
      } else {
        return data;
      }
    }

    // add version param to url on the first install and only once a day after that
  }, {
    key: "getVersionParam",
    value: function getVersionParam() {
      var ONEDAY = 1000 * 60 * 60 * 24;
      var version = browserWrapper.getExtensionVersion();
      var lastTdsUpdate = settings.getSetting('lastTdsUpdate');
      var now = Date.now();
      var versionParam;

      // check delta for last update
      if (lastTdsUpdate) {
        // @ts-ignore
        var delta = now - new Date(lastTdsUpdate);
        if (delta > ONEDAY) {
          versionParam = "&v=".concat(version);
        }
      } else {
        versionParam = "&v=".concat(version);
      }
      if (versionParam) settings.updateSetting('lastTdsUpdate', now);
      return versionParam;
    }

    /**
     * Convert the given list into stringified form.
     * @param {*} name
     * @returns list in a fully serialisable format
     */
  }, {
    key: "getSerializableList",
    value: function getSerializableList(name) {
      var _this5 = this;
      if (name === 'tds') {
        // copy and convert regexes to string
        var listCopy = JSON.parse(JSON.stringify(this.tds));
        Object.values(listCopy.trackers).forEach(function (tracker) {
          var _tracker$rules;
          (_tracker$rules = tracker.rules) === null || _tracker$rules === void 0 ? void 0 : _tracker$rules.forEach(function (rule, i) {
            // convert Regex to string and cut slashes and flags
            var ruleRegexStr = _this5.tds.trackers[tracker.domain].rules[i].rule.toString();
            rule.rule = ruleRegexStr.slice(1, ruleRegexStr.length - 3);
          });
        });
        return listCopy;
      } else {
        return this[name];
      }
    }
  }, {
    key: "removeLegacyLists",
    value: function removeLegacyLists() {
      this.table["delete"]('ReferrerExcludeList');
      this.table["delete"]('brokenSiteList');
      this.table["delete"]('protections');
    }
  }, {
    key: "onUpdate",
    value: function onUpdate(name, listener) {
      var listeners = this._onUpdatedListeners.get(name);
      if (!listeners) {
        listeners = [];
        this._onUpdatedListeners.set(name, listeners);
      }
      listeners.push(listener);
    }
  }, {
    key: "ready",
    value: function ready(configName) {
      if (!configName) {
        return Promise.all(this._onReadyPromises.values());
      }
      var readyPromise = this._onReadyPromises.get(configName);
      if (!readyPromise) {
        throw new Error("Unknown configuration: ".concat(configName));
      }
      return readyPromise;
    }
  }]);
  return TDSStorage;
}();
var _default = new TDSStorage();
exports["default"] = _default;

},{"../../../data/constants":38,"../../../data/etags.json":40,"./../../../data/bundled/extension-config.json":37,"./../load":83,"./../settings":90,"./../wrapper":99,"dexie":5}],94:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Companies = require('./companies');
var settings = require('./settings');
var Tab = require('./classes/tab');
var ServiceWorkerTab = require('./classes/sw-tab');
var _require = require('./classes/tab-state'),
  TabState = _require.TabState;
var browserWrapper = require('./wrapper');
var _require2 = require('./dnr-user-allowlist.js'),
  toggleUserAllowlistDomain = _require2.toggleUserAllowlistDomain,
  updateUserDenylist = _require2.updateUserDenylist;
var _require3 = require('./dnr-click-to-load'),
  clearClickToLoadDnrRulesForTab = _require3.clearClickToLoadDnrRulesForTab;

/**
 * @typedef {import('./classes/site.js').allowlistName} allowlistName
 */

// These tab properties are preserved when a new tab Object replaces an existing
// one for the same tab ID.
var persistentTabProperties = ['ampUrl', 'cleanAmpUrl', 'dnrRuleIdsByDisabledClickToLoadRuleAction'];
var TabManager = /*#__PURE__*/function () {
  function TabManager() {
    _classCallCheck(this, TabManager);
    /** @type {Record<number, Tab>} */
    this.tabContainer = {};
    /** @type {Record<string, Tab>} */
    this.swContainer = {};
  }

  /* This overwrites the current tab data for a given
   * id and is only called in three cases:
   * 1. When a new tab is opened. See onUpdated listener below
   * 2. When we get a new main_frame request
   */
  _createClass(TabManager, [{
    key: "create",
    value: function create(tabData) {
      var normalizedData = browserWrapper.normalizeTabData(tabData);
      var newTab = new Tab(normalizedData);
      var oldTab = this.tabContainer[newTab.id];
      if (oldTab) {
        var _oldTab$adClick;
        for (var _i = 0, _persistentTabPropert = persistentTabProperties; _i < _persistentTabPropert.length; _i++) {
          var property = _persistentTabPropert[_i];
          newTab[property] = oldTab[property];
        }
        if ((_oldTab$adClick = oldTab.adClick) !== null && _oldTab$adClick !== void 0 && _oldTab$adClick.shouldPropagateAdClickForNavigation(oldTab)) {
          newTab.adClick = oldTab.adClick.clone();
        }
      }
      this.tabContainer[newTab.id] = newTab;
      return newTab;
    }
  }, {
    key: "restoreOrCreate",
    value: function () {
      var _restoreOrCreate = _asyncToGenerator(function* (tabData) {
        var restored = yield this.restore(tabData.id);
        if (!restored) {
          yield this.create(tabData);
        }
      });
      function restoreOrCreate(_x) {
        return _restoreOrCreate.apply(this, arguments);
      }
      return restoreOrCreate;
    }()
  }, {
    key: "restore",
    value: function () {
      var _restore = _asyncToGenerator(function* (tabId) {
        var restoredState = yield Tab.restore(tabId);
        if (restoredState) {
          this.tabContainer[tabId] = restoredState;
        }
        return restoredState;
      });
      function restore(_x2) {
        return _restore.apply(this, arguments);
      }
      return restore;
    }()
  }, {
    key: "delete",
    value: function _delete(id) {
      var tabToRemove = this.tabContainer[id];
      if (tabToRemove) {
        var _tabToRemove$adClick;
        tabToRemove === null || tabToRemove === void 0 ? void 0 : (_tabToRemove$adClick = tabToRemove.adClick) === null || _tabToRemove$adClick === void 0 ? void 0 : _tabToRemove$adClick.removeDNR();
        if (browserWrapper.getManifestVersion() === 3) {
          clearClickToLoadDnrRulesForTab(tabToRemove);
        }
      }
      delete this.tabContainer[id];
      TabState["delete"](id);
    }
  }, {
    key: "has",
    value: function has(id) {
      return id in this.tabContainer;
    }

    /**
     * Called using either a chrome tab object or by id
     * get({tabId: ###});
     * @returns {Tab}
     */
  }, {
    key: "get",
    value: function get(tabData) {
      if (tabData.tabId === -1 && (tabData.initiator || tabData.documentUrl)) {
        // service worker request - use a 'ServiceWorkerTab' for the origin as a proxy for the real tab(s)
        var swUrl = tabData.initiator || tabData.documentUrl;
        var swOrigin = new URL(swUrl).origin;
        if (!this.swContainer[swOrigin]) {
          this.swContainer[swOrigin] = new ServiceWorkerTab(swUrl, this.tabContainer);
        }
        return this.swContainer[swOrigin];
      }
      return this.tabContainer[tabData.tabId];
    }
  }, {
    key: "getOrRestoreTab",
    value: function () {
      var _getOrRestoreTab = _asyncToGenerator(function* (tabId) {
        if (!tabManager.has(tabId)) {
          yield tabManager.restore(tabId);
        }
        return tabManager.get({
          tabId: tabId
        });
      });
      function getOrRestoreTab(_x3) {
        return _getOrRestoreTab.apply(this, arguments);
      }
      return getOrRestoreTab;
    }()
    /**
     * This will allowlist any open tabs with the same domain
     *
     * @param {object} data
     * @param {allowlistName} data.list - name of the allowlist to update
     * @param {string} data.domain - domain to allowlist
     * @param {boolean} data.value - allowlist value, true or false
     * @return {Promise}
     */
  }, {
    key: "setList",
    value: function () {
      var _setList = _asyncToGenerator(function* (data) {
        this.setGlobalAllowlist(data.list, data.domain, data.value);
        for (var tabId in this.tabContainer) {
          var tab = this.tabContainer[tabId];
          if (tab.site && tab.site.domain === data.domain) {
            tab.site.setListValue(data.list, data.value);
          }
        }

        // Ensure that user allowlisting/denylisting is honoured for manifest v3
        // builds of the extension, by adding/removing the necessary
        // declarativeNetRequest rules.
        if (browserWrapper.getManifestVersion() === 3) {
          if (data.list === 'allowlisted') {
            yield toggleUserAllowlistDomain(data.domain, data.value);
          } else if (data.list === 'denylisted') {
            yield updateUserDenylist();
          }
        }
      });
      function setList(_x4) {
        return _setList.apply(this, arguments);
      }
      return setList;
    }()
    /**
     * Update the allowlists kept in settings
     *
     * @param {allowlistName} list
     * @param {string} domain
     * @param {boolean} value
     */
  }, {
    key: "setGlobalAllowlist",
    value: function setGlobalAllowlist(list, domain, value) {
      var globalallowlist = settings.getSetting(list) || {};
      if (value) {
        globalallowlist[domain] = true;
      } else {
        delete globalallowlist[domain];
      }
      settings.updateSetting(list, globalallowlist);
    }

    /* This handles the new tab case. You have clicked to
     * open a new tab and haven't typed in a url yet.
     * This will fire an onUpdated event and we can create
     * an intital tab instance here. We'll update this instance
     * later on when webrequests start coming in.
     */
  }, {
    key: "createOrUpdateTab",
    value: function createOrUpdateTab(id, info) {
      if (!tabManager.get({
        tabId: id
      })) {
        info.id = id;
        return tabManager.create(info);
      } else {
        var tab = tabManager.get({
          tabId: id
        });
        if (tab && info.status) {
          tab.status = info.status;

          /**
           * Re: HTTPS. When the tab finishes loading:
           * 1. check main_frame url (via tab.url) for http/s, update site grade
           * 2. check for incomplete upgraded https upgrade requests, allowlist
           * the entire site if there are any then notify tabManager
           * NOTE: we aren't making a distinction between active and passive
           * content when https content is mixed after a forced upgrade
           */
          if (tab.status === 'complete') {
            var hasHttps = !!(tab.url && tab.url.match(/^https:\/\//));
            tab.site.grade.setHttps(hasHttps, hasHttps);
            console.info(tab.site.grade);
            if (tab.statusCode === 200 && !tab.site.didIncrementCompaniesData) {
              if (tab.trackers && Object.keys(tab.trackers).length > 0) {
                Companies.incrementTotalPagesWithTrackers();
              }
              Companies.incrementTotalPages();
              tab.site.didIncrementCompaniesData = true;
            }
          }
        }
        return tab;
      }
    }
  }, {
    key: "updateTabUrl",
    value: function updateTabUrl(request) {
      // Update tab data. This makes
      // sure we have the correct url after any https rewrites
      var tab = tabManager.get({
        tabId: request.tabId
      });
      if (tab) {
        tab.statusCode = request.statusCode;
        if (tab.statusCode === 200) {
          tab.updateSite(request.url);
        }
      }
    }
  }]);
  return TabManager;
}();
var tabManager = new TabManager();
module.exports = tabManager;

},{"./classes/sw-tab":57,"./classes/tab":59,"./classes/tab-state":58,"./companies":64,"./dnr-click-to-load":67,"./dnr-user-allowlist.js":72,"./settings":90,"./wrapper":99}],95:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasTrackerListLoaded = hasTrackerListLoaded;
exports.isFirstPartyByEntity = isFirstPartyByEntity;
exports.isSameEntity = isSameEntity;
exports.isTracker = isTracker;
exports.truncateReferrer = truncateReferrer;
var utils = _interopRequireWildcard(require("./utils"));
var _trackers = _interopRequireDefault(require("./trackers"));
var tldts = _interopRequireWildcard(require("tldts"));
var _tds = _interopRequireDefault(require("./storage/tds"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// Utility functions for dealing with tracker information

function hasTrackerListLoaded() {
  return !!_trackers["default"].trackerList;
}

// Determine if two URL's belong to the same entity.
function isSameEntity(url1, url2) {
  try {
    var domain1 = tldts.parse(url1).domain;
    var domain2 = tldts.parse(url2).domain;
    if (domain1 === domain2) return true;
    var entity1 = _trackers["default"].findWebsiteOwner({
      siteUrlSplit: utils.extractHostFromURL(url1).split('.')
    });
    var entity2 = _trackers["default"].findWebsiteOwner({
      siteUrlSplit: utils.extractHostFromURL(url2).split('.')
    });
    if (entity1 === undefined && entity2 === undefined) return false;
    return entity1 === entity2;
  } catch (e) {
    // tried to parse invalid URL
    return false;
  }
}

// return true if URL is in our tracker list
function isTracker(url) {
  var data = {
    urlToCheckSplit: utils.extractHostFromURL(url).split('.')
  };
  var tracker = _trackers["default"].findTracker(data);
  return !!tracker;
}

/*
 * Truncate the referrer header/API value according to the following rules:
 *   Don't modify the value when:
 *   - If the referrer is blank, it will not be modified.
 *   - If the referrer domain OR request domain are safe listed, the referrer will not be modified
 *   - If the referrer domain and request domain are part of the same entity (as defined in our
 *     entities file for first party sets), the referrer will not be modified.
 *
 *   Modify the referrer when:
 *   - If the destination is in our tracker list, we will trim it to eTLD+1 (remove path and subdomain information)
 *   - In all other cases (the general case), the referrer will be modified to only the referrer origin (includes subdomain).
 */
function truncateReferrer(referrer, target) {
  if (!referrer || referrer === '') {
    return undefined;
  }
  if (utils.isSafeListed(referrer) || utils.isSafeListed(target)) {
    return undefined;
  }

  // tracker can be cloaked using CNAME
  var _trackers$resolveCnam = _trackers["default"].resolveCname(target),
    fromCname = _trackers$resolveCnam.fromCname,
    finalURL = _trackers$resolveCnam.finalURL;
  if (isSameEntity(referrer, target) && (!fromCname || isSameEntity(referrer, finalURL))) {
    return undefined;
  }
  var exceptionList = _tds["default"].config.features.referrer.exceptions;
  if (utils.brokenListIndex(referrer, exceptionList) !== -1 || utils.brokenListIndex(target, exceptionList) !== -1) {
    return undefined;
  }
  var modifiedReferrer = referrer;
  if (isTracker(target) || fromCname && isTracker(finalURL)) {
    modifiedReferrer = utils.extractLimitedDomainFromURL(referrer, {
      keepSubdomains: false
    });
  } else {
    modifiedReferrer = utils.extractLimitedDomainFromURL(referrer, {
      keepSubdomains: true
    });
  }
  // If extractLimitedDomainFromURL fails (for instance, invalid referrer URL), it
  // returns undefined, (in practice, don't modify the referrer), so sometimes this value could be undefined.
  return modifiedReferrer;
}

/**
 * Checks if a tracker is a first party by checking entity data
 * @param {string} trackerUrl
 * @param {string} siteUrl
 * @returns {boolean}
 */
function isFirstPartyByEntity(trackerUrl, siteUrl) {
  var cnameResolution = _trackers["default"].resolveCname(trackerUrl);
  trackerUrl = cnameResolution.finalURL;
  if (utils.isSameTopLevelDomain(trackerUrl, siteUrl)) {
    return true;
  }
  var trackerDomain = tldts.parse(trackerUrl).domain;
  if (!trackerDomain) return false;
  var trackerOwner = _trackers["default"].findTrackerOwner(trackerDomain);
  var websiteOwner = _trackers["default"].findWebsiteOwner({
    siteUrlSplit: utils.extractHostFromURL(siteUrl).split('.')
  });
  return trackerOwner && websiteOwner ? trackerOwner === websiteOwner : false;
}

},{"./storage/tds":93,"./trackers":96,"./utils":98,"tldts":10}],96:[function(require,module,exports){
"use strict";

var utils = require('./utils');
var tldts = require('tldts');
var Trackers = require('@duckduckgo/privacy-grade').Trackers;

/**
 * @typedef {import("../../../node_modules/@duckduckgo/privacy-grade/src/classes/trackers.js").ActionName} ActionName
 * @typedef {import("../../../node_modules/@duckduckgo/privacy-grade/src/classes/trackers.js").TrackerData} TrackerData
 **/

/** @type {import("../../../node_modules/@duckduckgo/privacy-grade/src/classes/trackers.js")} */
var TrackersInstance = new Trackers({
  tldjs: tldts,
  utils: utils
});
module.exports = TrackersInstance;

},{"./utils":98,"@duckduckgo/privacy-grade":34,"tldts":10}],97:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var Site = require('./classes/site');
var tdsStorage = require('./storage/tds')["default"];

/** @module */

// Tracking parameters listed in the configuration are sometimes to be treated
// as plain-text, but sometimes as regular expressions. The implementation guide
// dictates that tracking parameter should be treated as plain-text unless they
// contain one of the following characters: * + ? { } [ ]
var regexpParameterTest = /[*+?{}[\]]/;

// Note: These lists of parameters would need to be stored in session storage if
//       this code was used by MV3 builds of the extension.
//       See https://developer.chrome.com/docs/extensions/mv3/migrating_to_service_workers/#state
var plainTextTrackingParameters = null;
var regexpTrackingParameters = null;
function ensureTrackingParametersConfig() {
  if (plainTextTrackingParameters && regexpTrackingParameters) {
    return true;
  }
  if (!tdsStorage.config || !tdsStorage.config.features || !tdsStorage.config.features.trackingParameters || !tdsStorage.config.features.trackingParameters.settings || !tdsStorage.config.features.trackingParameters.settings.parameters) {
    return false;
  }
  plainTextTrackingParameters = [];
  regexpTrackingParameters = [];
  var _iterator = _createForOfIteratorHelper(tdsStorage.config.features.trackingParameters.settings.parameters),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (regexpParameterTest.test(key)) {
        regexpTrackingParameters.push(new RegExp(key));
      } else {
        plainTextTrackingParameters.push(key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}

/**
 * Strip any known tracking GET parameters from the given URL. Return true if
 * any parameters were stripped, false otherwise.
 * @param {URL} url
 *   The request URL.
 *   Note: This is mutated to add parameters where necessary.
 * @returns {boolean}
 *   True if tracking parameters were stripped, false otherwise.
 */
function stripTrackingParameters(url) {
  var parametersRemoved = false;

  // No parameters, nothing to remove.
  if (url.search.length <= 1) {
    return parametersRemoved;
  }

  // Make sure that the tracking parameters configuration has been processed
  // since the extension config was last updated.
  if (!ensureTrackingParametersConfig()) {
    return parametersRemoved;
  }

  // Remove any plain-text tracking parameters first, since they are cheaper
  // to remove.
  var _iterator2 = _createForOfIteratorHelper(plainTextTrackingParameters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _key = _step2.value;
      if (url.searchParams.has(_key)) {
        url.searchParams["delete"](_key);
        parametersRemoved = true;
      }
    }

    // No parameters left, nothing further to remove.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (url.search.length <= 1) {
    return parametersRemoved;
  }

  // Remove any regular expression tracking parameters.
  // Note: This is potentially slow, in the future it might be worth
  //       optimising. For example, perhaps the minimum match lengths could
  //       be stored with the regular expression tracking parameters. That
  //       way, shorter keys could be skipped cheaply.
  for (var _i = 0, _Array$from = Array.from(url.searchParams.keys()); _i < _Array$from.length; _i++) {
    var key = _Array$from[_i];
    var _iterator3 = _createForOfIteratorHelper(regexpTrackingParameters),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var regexp = _step3.value;
        if (regexp.test(key)) {
          url.searchParams["delete"](key);
          parametersRemoved = true;
          break;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  return parametersRemoved;
}

/**
 * Returns true if the 'trackingParameters' feature is active for the given site
 * and initiator URL.
 * @param {Site} site
 *   The Site Object for the request URL in question.
 * @param {string} [initiatorUrl]
 *   The initiator URL of the request (if any).
 * @returns {boolean}
 *   True if the 'trackingParameters' feature is active, false otherwise.
 */
function trackingParametersStrippingEnabled(site, initiatorUrl) {
  // Only strip tracking parameters if the feature is enabled for the
  // request URL (URL that the user is navigating to).
  if (site.specialDomainName || !site.isFeatureEnabled('trackingParameters')) {
    return false;
  }

  // Also only strip tracking parameters if the feature is enabled for
  // the initiating URL (the URL that the user navigated from, if any).
  if (initiatorUrl) {
    var initiatorSite = new Site(initiatorUrl);
    if (initiatorSite.specialDomainName || !initiatorSite.isFeatureEnabled('trackingParameters')) {
      return false;
    }
  }
  return true;
}
tdsStorage.onUpdate('config', function () {
  plainTextTrackingParameters = null;
  regexpTrackingParameters = null;
});
module.exports = {
  trackingParametersStrippingEnabled: trackingParametersStrippingEnabled,
  stripTrackingParameters: stripTrackingParameters
};

},{"./classes/site":56,"./storage/tds":93}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brokenListIndex = brokenListIndex;
exports.extractHostFromURL = extractHostFromURL;
exports.extractLimitedDomainFromURL = extractLimitedDomainFromURL;
exports.extractTopSubdomainFromHost = extractTopSubdomainFromHost;
exports.findParent = findParent;
exports.findParentDisplayName = findParentDisplayName;
exports.getAsyncBlockingSupport = getAsyncBlockingSupport;
exports.getBaseDomain = getBaseDomain;
exports.getBrokenScriptLists = getBrokenScriptLists;
exports.getBrowserName = getBrowserName;
exports.getCurrentTab = getCurrentTab;
exports.getCurrentURL = getCurrentURL;
exports.getEnabledFeatures = getEnabledFeatures;
exports.getEnabledFeaturesAboutBlank = getEnabledFeaturesAboutBlank;
exports.getFeatureSettings = getFeatureSettings;
exports.getInstallTimestamp = getInstallTimestamp;
exports.getOsName = getOsName;
exports.getSessionKey = getSessionKey;
exports.getURLWithoutQueryString = getURLWithoutQueryString;
exports.getUpgradeToSecureSupport = getUpgradeToSecureSupport;
exports.isBroken = isBroken;
exports.isCookieExcluded = isCookieExcluded;
exports.isFeatureEnabled = isFeatureEnabled;
exports.isInstalledWithinDays = isInstalledWithinDays;
exports.isRedirect = isRedirect;
exports.isSafeListed = isSafeListed;
exports.isSameTopLevelDomain = isSameTopLevelDomain;
exports.parseVersionString = parseVersionString;
exports.reloadCurrentTab = reloadCurrentTab;
exports.removeBroken = removeBroken;
exports.resetSessionKey = resetSessionKey;
exports.satisfiesMinVersion = satisfiesMinVersion;
exports.sendAllTabsMessage = sendAllTabsMessage;
exports.sendTabMessage = sendTabMessage;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _wrapper = require("./wrapper");
var _tds = _interopRequireDefault(require("./storage/tds"));
var _settings = _interopRequireDefault(require("./settings"));
var tldts = _interopRequireWildcard(require("tldts"));
var _parseUserAgentString = _interopRequireDefault(require("../shared-utils/parse-user-agent-string"));
var _sha = _interopRequireDefault(require("../shared-utils/sha1"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var browserInfo = (0, _parseUserAgentString["default"])();

/**
 * Produce a random float, matches the output of Math.random() but much more cryptographically psudo-random.
 * @returns {number}
 */
function getRandomFloat() {
  return crypto.getRandomValues(new Uint32Array(1))[0] / Math.pow(2, 32);
}
function getSessionKey() {
  return _getSessionKey.apply(this, arguments);
}
function _getSessionKey() {
  _getSessionKey = _asyncToGenerator(function* () {
    var sessionKey = yield (0, _wrapper.getFromSessionStorage)('sessionKey');
    if (!sessionKey) {
      sessionKey = yield resetSessionKey();
    }
    return sessionKey;
  });
  return _getSessionKey.apply(this, arguments);
}
function resetSessionKey() {
  return _resetSessionKey.apply(this, arguments);
}
function _resetSessionKey() {
  _resetSessionKey = _asyncToGenerator(function* () {
    var sessionKey = (0, _sha["default"])(getRandomFloat().toString());
    yield (0, _wrapper.setToSessionStorage)('sessionKey', sessionKey);
    return sessionKey;
  });
  return _resetSessionKey.apply(this, arguments);
}
function sendTabMessage(_x, _x2, _x3) {
  return _sendTabMessage.apply(this, arguments);
}
function _sendTabMessage() {
  _sendTabMessage = _asyncToGenerator(function* (id, message, details) {
    try {
      yield _webextensionPolyfill["default"].tabs.sendMessage(id, message, details);
    } catch (_unused) {
      // Ignore errors
    }
  });
  return _sendTabMessage.apply(this, arguments);
}
function sendAllTabsMessage(_x4, _x5) {
  return _sendAllTabsMessage.apply(this, arguments);
}
/**
 * @param {string} urlString
 * @returns {string | null} etld plus one of the URL
 */
function _sendAllTabsMessage() {
  _sendAllTabsMessage = _asyncToGenerator(function* (message, details) {
    try {
      var _iterator = _createForOfIteratorHelper(yield _webextensionPolyfill["default"].tabs.query({})),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tabId = _step.value.id;
          sendTabMessage(tabId, message, details);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } catch (_unused2) {
      // Ignore errors
    }
  });
  return _sendAllTabsMessage.apply(this, arguments);
}
function getBaseDomain(urlString) {
  var _parsedUrl$hostname;
  var parsedUrl = tldts.parse(urlString, {
    allowPrivateDomains: true
  });
  if (parsedUrl.hostname === 'localhost' || (_parsedUrl$hostname = parsedUrl.hostname) !== null && _parsedUrl$hostname !== void 0 && _parsedUrl$hostname.endsWith('.localhost') || parsedUrl.isIp) {
    return parsedUrl.hostname;
  }
  return parsedUrl.domain;
}
function extractHostFromURL(url, shouldKeepWWW) {
  if (!url) return '';

  // Tweak the URL for Firefox about:* pages to ensure that they are parsed
  // correctly. For example, 'about:example' becomes 'about://example'.
  if (url.startsWith('about:') && url[6] !== '/') {
    url = 'about://' + url.substr(6);
  }
  var urlObj = tldts.parse(url);
  var hostname = urlObj.hostname || '';
  if (!shouldKeepWWW) {
    hostname = hostname.replace(/^www\./, '');
  }
  return hostname;
}

// Removes information from a URL, such as path, user information, and optionally sub domains
// @ts-ignore
function extractLimitedDomainFromURL(url) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    keepSubdomains = _ref.keepSubdomains;
  if (!url) return undefined;
  try {
    var parsedURL = new URL(url);
    var tld = tldts.parse(url);
    if (!parsedURL || !tld) return '';
    // tld.domain is null if this is an IP or the domain does not use a known TLD (e.g. localhost)
    // in that case use the hostname (no truncation)
    var finalURL = tld.domain || tld.hostname;
    if (keepSubdomains) {
      finalURL = tld.hostname;
    } else if (tld.subdomain && tld.subdomain.toLowerCase() === 'www') {
      // This is a special case where if a domain requires 'www' to work
      // we keep it, even if we wouldn't normally keep subdomains.
      // note that even mutliple subdomains like www.something.domain.com has
      // subdomain of www.something, and wouldn't trigger this case.
      finalURL = 'www.' + tld.domain;
    }
    var port = parsedURL.port ? ":".concat(parsedURL.port) : '';
    return "".concat(parsedURL.protocol, "//").concat(finalURL).concat(port, "/");
  } catch (e) {
    // tried to parse invalid URL, such as an extension URL. In this case, don't modify anything
    return undefined;
  }
}
function extractTopSubdomainFromHost(host) {
  if (typeof host !== 'string') return false;
  var rgx = /\./g;
  // @ts-ignore
  if (host.match(rgx) && host.match(rgx).length > 1) {
    return host.split('.')[0];
  }
  return false;
}

// pull off subdomains and look for parent companies
function findParent(url) {
  var parts = extractHostFromURL(url).split('.');
  while (parts.length > 1) {
    var _tdsStorage$tds$track, _tdsStorage$tds$track2;
    var joinURL = parts.join('.');

    // check if tracker owner has 'ownedBy' to indicate a parent.
    if ((_tdsStorage$tds$track = _tds["default"].tds.trackers[joinURL]) !== null && _tdsStorage$tds$track !== void 0 && (_tdsStorage$tds$track2 = _tdsStorage$tds$track.owner) !== null && _tdsStorage$tds$track2 !== void 0 && _tdsStorage$tds$track2.ownedBy) {
      return _tds["default"].tds.trackers[joinURL].owner.ownedBy;
    } else if (_tds["default"].tds.domains[joinURL]) {
      return _tds["default"].tds.domains[joinURL];
    }
    parts.shift();
  }
}

/**
 * There are situations where we want to access the parent's displayName
 * only - for instance in the NewtabTrackerStats feature.
 * @param {string} url
 * @returns {string}
 */
function findParentDisplayName(url) {
  var parent = findParent(url);
  var entity = _tds["default"].tds.entities[parent];
  if (entity && entity.displayName) {
    return entity.displayName;
  }
  return 'unknown';
}
function getCurrentURL(callback) {
  _webextensionPolyfill["default"].tabs.query({
    active: true,
    lastFocusedWindow: true
  }).then(function (tabData) {
    if (tabData.length) {
      callback(tabData[0].url);
    }
  });
}
function getCurrentTab(_x6) {
  return _getCurrentTab.apply(this, arguments);
} // Browser / Version detection
// Get correct name for fetching UI assets
function _getCurrentTab() {
  _getCurrentTab = _asyncToGenerator(function* (callback) {
    var tabData = yield _webextensionPolyfill["default"].tabs.query({
      active: true,
      lastFocusedWindow: true
    });
    if (tabData.length) {
      return tabData[0];
    }
  });
  return _getCurrentTab.apply(this, arguments);
}
function getBrowserName() {
  if (!browserInfo || !browserInfo.browser) return;
  var browserName = browserInfo.browser.toLowerCase();
  if (browserName === 'firefox') browserName = 'moz';
  return browserName;
}
function getOsName() {
  if (!browserInfo || !browserInfo.os) return;
  return browserInfo.os;
}

// Determine if upgradeToSecure supported (Firefox 59+)
function getUpgradeToSecureSupport() {
  var canUpgrade = false;
  if (getBrowserName() !== 'moz') return canUpgrade;
  if (browserInfo && browserInfo.version >= 59) {
    canUpgrade = true;
  }
  return canUpgrade;
}

// return true if browser allows to handle request async
function getAsyncBlockingSupport() {
  var browserName = getBrowserName();
  if (browserName === 'moz' && browserInfo && browserInfo.version >= 52) {
    return true;
  } else if (['edg', 'edge', 'brave', 'chrome'].includes(browserName)) {
    return false;
  }
  console.warn("Unrecognized browser \"".concat(browserName, "\" - async response disallowed"));
  return false;
}

/**
 * @param {number} statusCode
 * @returns {boolean}
 */
function isRedirect(statusCode) {
  return statusCode >= 300 && statusCode <= 399;
}

/*
 * check to see if this is a broken site reported on github
*/
function isBroken(url) {
  if (!(_tds["default"] !== null && _tds["default"] !== void 0 && _tds["default"].config.unprotectedTemporary)) return;
  return brokenListIndex(url, _tds["default"] === null || _tds["default"] === void 0 ? void 0 : _tds["default"].config.unprotectedTemporary) !== -1;
}
function removeBroken(domain) {
  var index = brokenListIndex(domain, _tds["default"].config.unprotectedTemporary);
  if (index !== -1) {
    console.log('remove', _tds["default"].config.unprotectedTemporary.splice(index, 1));
  }
}
function getEnabledFeaturesAboutBlank(url) {
  if (!_tds["default"].config.features) return [];
  var enabledFeatures = [];
  for (var feature in _tds["default"].config.features) {
    var featureSettings = getFeatureSettings(feature);
    if (featureSettings.aboutBlankEnabled !== 'disabled' && brokenListIndex(url, featureSettings.aboutBlankSites || []) === -1) {
      enabledFeatures.push(feature);
    }
  }
  return enabledFeatures;
}
function getEnabledFeatures(url) {
  if (!_tds["default"].config.features) return [];
  var enabledFeatures = [];
  for (var feature in _tds["default"].config.features) {
    if (isFeatureEnabled(feature) && brokenListIndex(url, _tds["default"].config.features[feature].exceptions || []) === -1) {
      enabledFeatures.push(feature);
    }
  }
  return enabledFeatures;
}
function brokenListIndex(url, list) {
  var parsedDomain = tldts.parse(url);
  var hostname = parsedDomain.hostname || url;

  // If root domain in temp unprotected list, return true
  return list.findIndex(function (brokenSiteDomain) {
    if (brokenSiteDomain.domain) {
      return hostname === brokenSiteDomain.domain || hostname.endsWith(".".concat(brokenSiteDomain.domain));
    }
    return false;
  });
}

// We inject this into content scripts
function getBrokenScriptLists() {
  var brokenScripts = {};
  for (var key in _tds["default"].config.features) {
    var _featureSettings$scri;
    var featureSettings = getFeatureSettings(key);
    brokenScripts[key] = ((_featureSettings$scri = featureSettings.scripts) === null || _featureSettings$scri === void 0 ? void 0 : _featureSettings$scri.map(function (obj) {
      return obj.domain;
    })) || [];
  }
  return brokenScripts;
}

// return true if the given url is in the safelist. For checking if the current tab is in the safelist,
// tabManager.site.isProtectionEnabled() is the preferred method.
function isSafeListed(url) {
  var hostname = extractHostFromURL(url);
  var safeList = _settings["default"].getSetting('allowlisted');
  var subdomains = hostname.split('.');
  // Check user safe list
  // TODO make the same as brokenListIndex matching
  while (subdomains.length > 1) {
    if (safeList && safeList[subdomains.join('.')]) {
      return true;
    }
    subdomains.shift();
  }

  // Check broken sites
  if (isBroken(hostname)) {
    return true;
  }
  return false;
}
function isCookieExcluded(url) {
  var domain = new URL(url).host;
  return isDomainCookieExcluded(domain);
}
function isDomainCookieExcluded(domain) {
  var cookieSettings = getFeatureSettings('cookie');
  if (!cookieSettings || !cookieSettings.excludedCookieDomains) {
    return false;
  }
  if (cookieSettings.excludedCookieDomains.find(function (elem) {
    return elem.domain === domain;
  })) {
    return true;
  }
  var comps = domain.split('.');
  if (comps.length > 2) {
    comps.shift();
    return isDomainCookieExcluded(comps.join('.'));
  }
  return false;
}

/**
 * Tests whether the two URL's belong to the same
 * top level domain.
 */
function isSameTopLevelDomain(url1, url2) {
  var first = getBaseDomain(url1);
  var second = getBaseDomain(url2);
  if (!first || !second) {
    return false;
  }
  return first === second;
}
function parseVersionString(versionString) {
  var _versionString$split$ = versionString.split('.').map(Number),
    _versionString$split$2 = _slicedToArray(_versionString$split$, 3),
    _versionString$split$3 = _versionString$split$2[0],
    major = _versionString$split$3 === void 0 ? 0 : _versionString$split$3,
    _versionString$split$4 = _versionString$split$2[1],
    minor = _versionString$split$4 === void 0 ? 0 : _versionString$split$4,
    _versionString$split$5 = _versionString$split$2[2],
    patch = _versionString$split$5 === void 0 ? 0 : _versionString$split$5;
  return {
    major: major,
    minor: minor,
    patch: patch
  };
}
function satisfiesMinVersion(minVersionString, extensionVersionString) {
  var _parseVersionString = parseVersionString(minVersionString),
    minMajor = _parseVersionString.major,
    minMinor = _parseVersionString.minor,
    minPatch = _parseVersionString.patch;
  var _parseVersionString2 = parseVersionString(extensionVersionString),
    major = _parseVersionString2.major,
    minor = _parseVersionString2.minor,
    patch = _parseVersionString2.patch;
  return major > minMajor || major >= minMajor && minor > minMinor || major >= minMajor && minor >= minMinor && patch >= minPatch;
}

/**
 * Checks the config to see if a feature is enabled. You can optionally pass a second "customState"
 * parameter to check if the state is equeal to other states (i.e. state === 'beta').
 *
 * @param {String} featureName - the name of the feature
 * @returns {boolean} - if feature is enabled
 */
function isFeatureEnabled(featureName) {
  var feature = _tds["default"].config.features[featureName];
  if (!feature) {
    return false;
  }

  // If we have a supplied min version for the feature ensure the extension meets it
  if ('minSupportedVersion' in feature) {
    var extensionVersionString = (0, _wrapper.getExtensionVersion)();
    if (!satisfiesMinVersion(feature.minSupportedVersion, extensionVersionString)) {
      return false;
    }
  }
  return feature.state === 'enabled';
}

/**
 * Returns the settings object associated with featureName in the config
 *
 * @param {String} featureName - the name of the feature
 * @returns {Object} - Settings associated in the config with featureName
 */
function getFeatureSettings(featureName) {
  var feature = _tds["default"].config.features[featureName];
  if (_typeof(feature) !== 'object' || feature === null || !feature.settings) {
    return {};
  }
  return feature.settings;
}

/**
 * Strips off a query string from the URL
 * @param {string} urlString
 * @returns {string}
 */
function getURLWithoutQueryString(urlString) {
  return urlString === null || urlString === void 0 ? void 0 : urlString.split('?')[0];
}
function reloadCurrentTab() {
  return _reloadCurrentTab.apply(this, arguments);
}
function _reloadCurrentTab() {
  _reloadCurrentTab = _asyncToGenerator(function* () {
    var tab = yield getCurrentTab();
    if (tab && tab.id) {
      _webextensionPolyfill["default"].tabs.reload(tab.id);
    }
  });
  return _reloadCurrentTab.apply(this, arguments);
}
var dayMultiplier = 24 * 60 * 60 * 1000;

/**
 * Converts ATB value into date
 * @param {string} atb
 * @returns {number|null}
 */
function getInstallTimestamp(atb) {
  var match = atb.match(/^v?(\d+)-(\d)(.+)?$/i);
  if (!match) return null;
  var startDate = 1456272000000;
  var weeksSince = (parseInt(match[1], 10) - 1) * 7 * dayMultiplier;
  var daysSince = (parseInt(match[2], 10) - 1) * dayMultiplier;
  var installTimestamp = new Date(startDate + weeksSince + daysSince).getTime();
  return isNaN(installTimestamp) ? null : installTimestamp;
}

/**
 * Checks if the extension was installed within days of the from date
 * @param {number} numberOfDays
 * @param {number} [fromDate]
 * @param {string} [atb]
 * @returns {boolean}
 */
function isInstalledWithinDays(numberOfDays) {
  var fromDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
  var atb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _settings["default"].getSetting('atb');
  if (!atb) return false;
  var installTimestamp = getInstallTimestamp(atb);
  // If we can't get the install date, assume it wasn't installed in time period
  if (!installTimestamp) return false;
  var daysInstalled = (fromDate - installTimestamp) / dayMultiplier;
  return daysInstalled <= numberOfDays;
}

},{"../shared-utils/parse-user-agent-string":100,"../shared-utils/sha1":101,"./settings":90,"./storage/tds":93,"./wrapper":99,"tldts":10,"webextension-polyfill":11}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changeTabURL = changeTabURL;
exports.createAlarm = createAlarm;
exports.executeScript = executeScript;
exports.getDDGTabUrls = getDDGTabUrls;
exports.getExtensionId = getExtensionId;
exports.getExtensionURL = getExtensionURL;
exports.getExtensionVersion = getExtensionVersion;
exports.getFromManagedStorage = getFromManagedStorage;
exports.getFromSessionStorage = getFromSessionStorage;
exports.getFromStorage = getFromStorage;
exports.getManifestVersion = getManifestVersion;
exports.insertCSS = insertCSS;
exports.mergeSavedSettings = mergeSavedSettings;
exports.normalizeTabData = normalizeTabData;
exports.notifyPopup = notifyPopup;
exports.openExtensionPage = openExtensionPage;
exports.removeFromSessionStorage = removeFromSessionStorage;
exports.sessionStorageFallback = void 0;
exports.setActionIcon = setActionIcon;
exports.setToSessionStorage = setToSessionStorage;
exports.setUninstallURL = setUninstallURL;
exports.syncToStorage = syncToStorage;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function getExtensionURL(path) {
  return _webextensionPolyfill["default"].runtime.getURL(path);
}
function getExtensionVersion() {
  var manifest = _webextensionPolyfill["default"].runtime.getManifest();
  return manifest.version;
}
function openExtensionPage(path) {
  _webextensionPolyfill["default"].tabs.create({
    url: getExtensionURL(path)
  });
}

/**
 * @param {string} iconPath
 * @param {number} tabId
 * @returns {Promise<void>}
 */
function setActionIcon(_x, _x2) {
  return _setActionIcon.apply(this, arguments);
}
function _setActionIcon() {
  _setActionIcon = _asyncToGenerator(function* (iconPath, tabId) {
    if (typeof _webextensionPolyfill["default"].action === 'undefined') {
      return _webextensionPolyfill["default"].browserAction.setIcon({
        path: iconPath,
        tabId: tabId
      });
    }
    return _webextensionPolyfill["default"].action.setIcon({
      path: iconPath,
      tabId: tabId
    });
  });
  return _setActionIcon.apply(this, arguments);
}
function getManifestVersion() {
  var manifest = _webextensionPolyfill["default"].runtime.getManifest();
  return manifest.manifest_version;
}
function syncToStorage(data) {
  _webextensionPolyfill["default"].storage.local.set(data);
}

// @ts-ignore
function getFromStorage(_x3, _x4) {
  return _getFromStorage.apply(this, arguments);
} // @ts-ignore
function _getFromStorage() {
  _getFromStorage = _asyncToGenerator(function* (key, cb) {
    var result = yield _webextensionPolyfill["default"].storage.local.get(key);
    return result[key];
  });
  return _getFromStorage.apply(this, arguments);
}
function getFromManagedStorage(_x5, _x6) {
  return _getFromManagedStorage.apply(this, arguments);
}
function _getFromManagedStorage() {
  _getFromManagedStorage = _asyncToGenerator(function* (keys, cb) {
    try {
      return yield _webextensionPolyfill["default"].storage.managed.get(keys);
    } catch (e) {
      console.log('get managed failed', e);
    }
    return {};
  });
  return _getFromManagedStorage.apply(this, arguments);
}
function getExtensionId() {
  return _webextensionPolyfill["default"].runtime.id;
}
function notifyPopup(_x7) {
  return _notifyPopup.apply(this, arguments);
}
/**
 * @param {browser.WebRequest.OnBeforeRedirectDetailsType | browser.Tabs.Tab | browser.Tabs.OnUpdatedChangeInfoType} tabData
 * @returns {{tabId: number, url: string | undefined, requestId?: string, status: string | null | undefined}}
 */
function _notifyPopup() {
  _notifyPopup = _asyncToGenerator(function* (message) {
    try {
      yield _webextensionPolyfill["default"].runtime.sendMessage(message);
    } catch (_unused) {
      // Ignore this as can throw an error message when the popup is not open.
    }
  });
  return _notifyPopup.apply(this, arguments);
}
function normalizeTabData(tabData) {
  // @ts-expect-error - id doesn't exist onUpdatedChangeInfoType but we rectify in onCreateOrUpdateTab
  var tabId = 'tabId' in tabData ? tabData.tabId : tabData.id;
  var url = tabData.url;
  var status = 'status' in tabData ? tabData.status : null;
  var requestId = 'requestId' in tabData ? tabData.requestId : undefined;
  return {
    tabId: tabId,
    url: url,
    requestId: requestId,
    status: status
  };
}
function mergeSavedSettings(settings, results) {
  return Object.assign(settings, results);
}
function getDDGTabUrls() {
  return _getDDGTabUrls.apply(this, arguments);
}
function _getDDGTabUrls() {
  _getDDGTabUrls = _asyncToGenerator(function* () {
    var tabs = (yield _webextensionPolyfill["default"].tabs.query({
      url: 'https://*.duckduckgo.com/*'
    })) || [];
    tabs.forEach(function (tab) {
      insertCSS({
        target: {
          tabId: tab.id
        },
        files: ['/public/css/noatb.css']
      });
    });
    return tabs.map(function (tab) {
      return tab.url;
    });
  });
  return _getDDGTabUrls.apply(this, arguments);
}
function setUninstallURL(url) {
  _webextensionPolyfill["default"].runtime.setUninstallURL(url);
}
function changeTabURL(tabId, url) {
  return _webextensionPolyfill["default"].tabs.update(tabId, {
    url: url
  });
}
function convertScriptingAPIOptionsForTabsAPI(options) {
  if (_typeof(options) !== 'object') {
    throw new Error('Missing/invalid options Object.');
  }
  if (typeof options.file !== 'undefined' || typeof options.frameId !== 'undefined' || typeof options.runAt !== 'undefined' || typeof options.allFrames !== 'undefined' || typeof options.code !== 'undefined') {
    throw new Error('Please provide options compatible with the (MV3) scripting API, ' + 'instead of the (MV2) tabs API.');
  }
  if (typeof options.world !== 'undefined') {
    throw new Error('World targetting not supported by MV2.');
  }
  var _options$target = options.target,
    allFrames = _options$target.allFrames,
    frameIds = _options$target.frameIds,
    tabId = _options$target.tabId;
  delete options.target;
  if (Array.isArray(frameIds) && frameIds.length > 0) {
    if (frameIds.length > 1) {
      throw new Error('Targetting multiple frames by ID not supported by MV2.');
    }
    options.frameId = frameIds[0];
  }
  if (typeof options.files !== 'undefined') {
    if (Array.isArray(options.files) && options.files.length > 0) {
      if (options.files.length > 1) {
        throw new Error('Inserting multiple stylesheets/scripts in one go not supported by MV2.');
      }
      options.file = options.files[0];
    }
    delete options.files;
  }
  if (typeof allFrames !== 'undefined') {
    options.allFrames = allFrames;
  }
  if (typeof options.injectImmediately !== 'undefined') {
    if (options.injectImmediately) {
      options.runAt = 'document_start';
    }
    delete options.injectImmediately;
  }
  var stringifiedArgs = '';
  if (typeof options.args !== 'undefined') {
    if (Array.isArray(options.args)) {
      stringifiedArgs = '...' + JSON.stringify(options.args);
    }
    delete options.args;
  }
  if (typeof options.func !== 'undefined') {
    if (typeof options.func === 'function') {
      options.code = '(' + options.func.toString() + ')(' + stringifiedArgs + ')';
    }
    delete options.func;
  }
  return [tabId, options];
}

/**
 * Execute a script/function in the target tab.
 * This is a wrapper around tabs.executeScript (MV2) and
 * scripting.executeScript (MV3). Arguments are expected in the
 * scripting.executeScript[1] format.
 * Notes:
 *   - Instead of passing the `code` option (JavaScript string to execute), pass
 *     the `func` option (JavaScript function to execute).
 *   - Some features are not supported in MV2, including targetting multiple
 *     specific frames and targetting execution 'world'.
 * 1 - https://developer.chrome.com/docs/extensions/reference/scripting/#method-executeScript
 * @param {object} options
 *   Script injection options.
 * @returns {Promise<*>}
 */
function executeScript(_x8) {
  return _executeScript.apply(this, arguments);
}
/**
 * Insert CSS in the target tab.
 * This is a wrapper around tabs.insertCSS (MV2) and scripting.insertCSS (MV3).
 * Arguments are expected in the scripting.insertCSS[1] format.
 * Notes:
 *   - Some features are not supported in MV2, including targetting multiple
 *     specific frames and targetting execution 'world'.
 * 1 - https://developer.chrome.com/docs/extensions/reference/scripting/#method-insertCSS
 * @param {object} options
 *   CSS insertion options.
 */
function _executeScript() {
  _executeScript = _asyncToGenerator(function* (options) {
    if (typeof _webextensionPolyfill["default"].scripting === 'undefined') {
      var _browser$tabs;
      return yield (_browser$tabs = _webextensionPolyfill["default"].tabs).executeScript.apply(_browser$tabs, _toConsumableArray(convertScriptingAPIOptionsForTabsAPI(options)));
    }
    return yield _webextensionPolyfill["default"].scripting.executeScript(options);
  });
  return _executeScript.apply(this, arguments);
}
function insertCSS(_x9) {
  return _insertCSS.apply(this, arguments);
} // Session storage
// @ts-ignore
function _insertCSS() {
  _insertCSS = _asyncToGenerator(function* (options) {
    if (typeof _webextensionPolyfill["default"].scripting === 'undefined') {
      var _browser$tabs2;
      return yield (_browser$tabs2 = _webextensionPolyfill["default"].tabs).insertCSS.apply(_browser$tabs2, _toConsumableArray(convertScriptingAPIOptionsForTabsAPI(options)));
    }
    return yield _webextensionPolyfill["default"].scripting.insertCSS(options);
  });
  return _insertCSS.apply(this, arguments);
}
var sessionStorageSupported = typeof _webextensionPolyfill["default"].storage.session !== 'undefined';
var sessionStorageFallback = sessionStorageSupported ? null : new Map();

/**
 * Save some data to memory, which persists until the session ends (e.g. until
 * the browser is closed).
 * Note: There is a quota for how much data can be stored in memory. At the time
 *       of writing that was about 1 megabyte. Attempting to write more data
 *       than this will result in an error. For large values, please use
 *       `syncToStorage` (browser.storage.local) instead.
 *       See https://developer.chrome.com/docs/extensions/reference/storage/#property-session-session-QUOTA_BYTES
 * @param {string} key
 *   The storage key to write to.
 * @param {*} data
 *   The value to write.
 * @return {Promise<undefined>}
 */
exports.sessionStorageFallback = sessionStorageFallback;
function setToSessionStorage(_x10, _x11) {
  return _setToSessionStorage.apply(this, arguments);
}
/**
 * Retrieve a value from memory.
 * @param {string} key
 *   The storage key to retrieve.
 * @return {Promise<*>}
 *   The retrieved value.
 */
function _setToSessionStorage() {
  _setToSessionStorage = _asyncToGenerator(function* (key, data) {
    if (typeof key !== 'string') {
      throw new Error('Invalid storage key, string expected.');
    }
    if (sessionStorageSupported) {
      // @ts-ignore
      return yield _webextensionPolyfill["default"].storage.session.set(_defineProperty({}, key, data));
    }

    // @ts-ignore - TS doesn't know it is a Map
    sessionStorageFallback.set(key, data);
  });
  return _setToSessionStorage.apply(this, arguments);
}
function getFromSessionStorage(_x12) {
  return _getFromSessionStorage.apply(this, arguments);
}
/**
 * Removes a value from memory.
 * @param {string} key
 *   The storage key to remove.
 * @return {Promise<undefined>}
 */
function _getFromSessionStorage() {
  _getFromSessionStorage = _asyncToGenerator(function* (key) {
    if (typeof key !== 'string') {
      throw new Error('Invalid storage key, string expected.');
    }
    if (sessionStorageSupported) {
      // @ts-ignore
      var result = yield _webextensionPolyfill["default"].storage.session.get([key]);
      return result[key];
    }

    // @ts-ignore
    return sessionStorageFallback.get(key);
  });
  return _getFromSessionStorage.apply(this, arguments);
}
function removeFromSessionStorage(_x13) {
  return _removeFromSessionStorage.apply(this, arguments);
}
/**
 * Create an alarm, taking care to check it doesn't exist first.
 * See https://stackoverflow.com/questions/66391018/how-do-i-call-a-function-periodically-in-a-manifest-v3-chrome-extension/66391601#66391601
 * @param {string} name
 *   The alarm name.
 * @param {Object} alarmInfo
 *   Details that determine when the alarm should fire.
 *   See https://developer.chrome.com/docs/extensions/reference/alarms/#type-AlarmCreateInfo
 * @return {Promise}
 */
function _removeFromSessionStorage() {
  _removeFromSessionStorage = _asyncToGenerator(function* (key) {
    if (typeof key !== 'string') {
      throw new Error('Invalid storage key, string expected.');
    }
    if (sessionStorageSupported) {
      // @ts-ignore
      return yield _webextensionPolyfill["default"].storage.session.remove(key);
    }

    // @ts-ignore
    return sessionStorageFallback["delete"](key);
  });
  return _removeFromSessionStorage.apply(this, arguments);
}
function createAlarm(_x14, _x15) {
  return _createAlarm.apply(this, arguments);
}
function _createAlarm() {
  _createAlarm = _asyncToGenerator(function* (name, alarmInfo) {
    var existingAlarm = yield _webextensionPolyfill["default"].alarms.get(name);
    if (!existingAlarm) {
      return yield _webextensionPolyfill["default"].alarms.create(name, alarmInfo);
    }
  });
  return _createAlarm.apply(this, arguments);
}

},{"webextension-polyfill":11}],100:[function(require,module,exports){
"use strict";

module.exports = function (uaString) {
  if (!globalThis.navigator) return;
  if (!uaString) uaString = globalThis.navigator.userAgent;
  var browser;
  var version;
  try {
    var parsedUaParts = uaString.match(/(Firefox|Chrome|Edg)\/([0-9]+)/);
    var isEdge = /(Edge?)\/([0-9]+)/;
    var isOpera = /(OPR)\/([0-9]+)/;
    // Above regex matches on Chrome first, so check if this is really Edge
    if (uaString.match(isEdge)) {
      parsedUaParts = uaString.match(isEdge);
    } else if (uaString.match(isOpera)) {
      parsedUaParts = uaString.match(isOpera);
      parsedUaParts[1] = 'Opera';
    }
    browser = parsedUaParts[1];
    version = parsedUaParts[2];

    // Brave doesn't include any information in the UserAgent
    // @ts-ignore
    if (globalThis.navigator.brave) {
      browser = 'Brave';
    }
  } catch (e) {
    // unlikely, prevent extension from exploding if we don't recognize the UA
    browser = version = '';
  }
  var os = 'o';
  if (globalThis.navigator.userAgent.indexOf('Windows') !== -1) os = 'w';
  if (globalThis.navigator.userAgent.indexOf('Mac') !== -1) os = 'm';
  if (globalThis.navigator.userAgent.indexOf('Linux') !== -1) os = 'l';
  return {
    os: os,
    browser: browser,
    version: version
  };
};

},{}],101:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* eslint-disable */
// @ts-nocheck
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : {};
  var NODE_JS = !root.JS_SHA1_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && (typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];
  var blocks = [];
  var createOutputMethod = function createOutputMethod(outputType) {
    return function (message) {
      return new Sha1(true).update(message)[outputType]();
    };
  };
  var createMethod = function createMethod() {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Sha1();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };
  var nodeWrap = function nodeWrap(method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function nodeMethod(message) {
      if (typeof message === 'string') {
        return crypto.createHash('sha1').update(message, 'utf8').digest('hex');
      } else if (message.constructor === ArrayBuffer) {
        message = new Uint8Array(message);
      } else if (message.length === undefined) {
        return method(message);
      }
      return crypto.createHash('sha1').update(new Buffer(message)).digest('hex');
    };
    return nodeMethod;
  };
  function Sha1(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  Sha1.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof message !== 'string';
    if (notString && message.constructor === root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code,
      index = 0,
      i,
      length = message.length || 0,
      blocks = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };
  Sha1.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };
  Sha1.prototype.hash = function () {
    var a = this.h0,
      b = this.h1,
      c = this.h2,
      d = this.h3,
      e = this.h4;
    var f,
      j,
      t,
      blocks = this.blocks;
    for (j = 16; j < 80; ++j) {
      t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
      blocks[j] = t << 1 | t >>> 31;
    }
    for (j = 0; j < 20; j += 5) {
      f = b & c | ~b & d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1518500249 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | ~a & c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1518500249 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | ~e & b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1518500249 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | ~d & a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1518500249 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | ~c & e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1518500249 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 40; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1859775393 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1859775393 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1859775393 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1859775393 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1859775393 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 60; j += 5) {
      f = b & c | b & d | c & d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 1894007588 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | a & c | b & c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 1894007588 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | e & b | a & b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 1894007588 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | d & a | e & a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 1894007588 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | c & e | d & e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 1894007588 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 80; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 899497514 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 899497514 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 899497514 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 899497514 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 899497514 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
  };
  Sha1.prototype.hex = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[h4 & 0x0F];
  };
  Sha1.prototype.toString = Sha1.prototype.hex;
  Sha1.prototype.digest = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return [h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF];
  };
  Sha1.prototype.array = Sha1.prototype.digest;
  Sha1.prototype.arrayBuffer = function () {
    this.finalize();
    var buffer = new ArrayBuffer(20);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    return buffer;
  };
  var exports = createMethod();
  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha1 = exports;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":8}]},{},[48]);
